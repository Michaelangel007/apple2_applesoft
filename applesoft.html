<html>
<!--
https://web.archive.org/web/20131106182736/http://jamtronix.com/files/applesoft.html
-->
<body>
<pre>                *--------------------------------
                *   ZERO PAGE LOCATIONS:
                *--------------------------------
00-             GOWARM         .EQ $00,01,02  GETS "JMP RESTART"
03-             GOSTROUT       .EQ $03,04,05  GETS "JMP STROUT"
0A-             USR            .EQ $0A,0B,0C  GETS "JMP &lt;USER ADDR&gt;"
                *                             (INITIALLY $E199)
0D-             CHARAC         .EQ $0D        ALTERNATE STRING TERMINATOR
0E-             ENDCHR         .EQ $0E        STRING TERMINATOR
0F-             TKN.CNTR       .EQ $0F        USED IN PARSE
0F-             EOL.PNTR       .EQ $0F        USED IN NXLIN
0F-             NUMDIM         .EQ $0F        USED IN ARRAY ROUTINES
10-             DIMFLG         .EQ $10
11-             VALTYP         .EQ $11,12     $:VALTYP=$FF; %:VALTYP+1=$80
13-             DATAFLG        .EQ $13        USED IN PARSE
13-             GARFLG         .EQ $13        USED IN GARBAG
14-             SUBFLG         .EQ $14
15-             INPUTFLG       .EQ $15        = $40 FOR GET, $98 FOR READ
16-             CPRMASK        .EQ $16        RECEIVES CPRTYP IN FRMEVL
16-             SIGNFLG        .EQ $16        FLAGS SIGN IN TAN
1A-             HGR.SHAPE      .EQ $1A,1B
1C-             HGR.BITS       .EQ $1C
1D-             HGR.COUNT      .EQ $1D
24-             MON.CH         .EQ $24
26-             MON.GBASL      .EQ $26
27-             MON.GBASH      .EQ $27
2C-             MON.H2         .EQ $2C
2D-             MON.V2         .EQ $2D
30-             MON.HMASK      .EQ $30
32-             MON.INVFLG     .EQ $32
33-             MON.PROMPT     .EQ $33
3C-             MON.A1L        .EQ $3C        USED BY TAPE I/O ROUTINES
3D-             MON.A1H        .EQ $3D          "
3E-             MON.A2L        .EQ $3E          "
3F-             MON.A2H        .EQ $3F          "
50-             LINNUM         .EQ $50,51     CONVERTED LINE #
52-             TEMPPT         .EQ $52        LAST USED TEMP STRING DESC
53-             LASTPT         .EQ $53,54     LAST USED TEMP STRING PNTR
55-             TEMPST         .EQ $55 - 5D   HOLDS UP TO 3 DESCRIPTORS
5E-             INDEX          .EQ $5E,5F
60-             DEST           .EQ $60,61
62-             RESULT         .EQ $62 - 66   RESULT OF LAST * OR /
67-             TXTTAB         .EQ $67,68     START OF PROGRAM TEXT
69-             VARTAB         .EQ $69,6A     START OF VARIABLE STORAGE
6B-             ARYTAB         .EQ $6B,6C     START OF ARRAY STORAGE
6D-             STREND         .EQ $6D,6E     END OF ARRAY STORAGE
6F-             FRETOP         .EQ $6F,70     START OF STRING STORAGE
71-             FRESPC         .EQ $71,72     TEMP PNTR, STRING ROUTINES
73-             MEMSIZ         .EQ $73,74     END OF STRING SPACE (HIMEM)
75-             CURLIN         .EQ $75,76     CURRENT LINE NUMBER
                *                             ( = $FFXX IF IN DIRECT MODE)
77-             OLDLIN         .EQ $77,78     ADDR. OF LAST LINE EXECUTED
79-             OLDTEXT        .EQ $79,7A   
7B-             DATLIN         .EQ $7B,7C     LINE # OF CURRENT DATA STT.
7D-             DATPTR         .EQ $7D,7E     ADDR OF CURRENT DATA STT.
7F-             INPTR          .EQ $7F,80
81-             VARNAM         .EQ $81,82     NAME OF VARIABLE
83-             VARPNT         .EQ $83,84     ADDR OF VARIABLE
85-             FORPNT         .EQ $85,86
87-             TXPSV          .EQ $87,88     USED IN INPUT
87-             LASTOP         .EQ $87        SCRATCH FLAG USED IN FRMEVL
89-             CPRTYP         .EQ $89        &gt;,=,&lt; FLAG IN FRMEVL
8A-             TEMP3          .EQ $8A - 8E
8A-             FNCNAM         .EQ $8A
8C-             DSCPTR         .EQ $8C
8F-             DSCLEN         .EQ $8F        USED IN GARBAG
90-             JMPADRS        .EQ $90,91,92  GETS "JMP ...."
91-             LENGTH         .EQ $91        USED IN GARBAG
92-             ARG.EXTENSION  .EQ $92        FP EXTRA PRECISION
93-             TEMP1          .EQ $93 - 97   SAVE AREAS FOR FAC
94-             ARYPNT         .EQ $94        USED IN GARBAG
94-             HIGHDS         .EQ $94,95     PNTR FOR BLTU
96-             HIGHTR         .EQ $96,97     PNTR FOR BLTU
98-             TEMP2          .EQ $98 - 9C
99-             TMPEXP         .EQ $99        USED IN FIN (EVAL)
99-             INDX           .EQ $99        USED BY ARRAY RTNS
9A-             EXPON          .EQ $9A          "
9B-             DPFLG          .EQ $9B        FLAGS DEC PNT IN FIN
9B-             LOWTR          .EQ $9B,9C
9C-             EXPSGN         .EQ $9C
9D-             FAC            .EQ $9D - A1   MAIN FLT PT ACCUMULATOR
9D-             DSCTMP         .EQ $9D,9E,9F
A0-             VPNT           .EQ $A0,A1     TEMP VAR PTR
A2-             FAC.SIGN       .EQ $A2        HOLDS UNPACKED SIGN
A3-             SERLEN         .EQ $A3        HOLDS LENGTH OF SERIES-1
A4-             SHIFT.SIGN.EXT .EQ $A4        SIGN EXTENSION, RIGHT SHIFTS
A5-             ARG            .EQ $A5 - A9   SECONDARY FP ACC
AA-             ARG.SIGN       .EQ $AA
AB-             SGNCPR         .EQ $AB        FLAGS OPP SIGN IN FP ROUT.
AC-             FAC.EXTENSION  .EQ $AC        FAC EXTENSION BYTE
AD-             SERPNT         .EQ $AD        PNTR TO SERIES DATA IN FP
AB-             STRNG1         .EQ $AB,AC
AD-             STRNG2         .EQ $AD,AE
AF-             PRGEND         .EQ $AF,B0
B1-             CHRGET         .EQ $B1 - C8
B7-             CHRGOT         .EQ $B7
B8-             TXTPTR         .EQ $B8,B9
C9-             RNDSEED        .EQ $C9 - CD
D0-             HGR.DX         .EQ $D0,D1
D2-             HGR.DY         .EQ $D2
D3-             HGR.QUADRANT   .EQ $D3
D4-             HGR.E          .EQ $D4,D5
D6-             LOCK           .EQ $D6        NO USER ACCESS IF &gt; 127
D8-             ERRFLG         .EQ $D8        $80 IF ON ERR ACTIVE
DA-             ERRLIN         .EQ $DA,DB     LINE # WHERE ERROR OCCURRED
DC-             ERRPOS         .EQ $DC,DD     TXTPTR SAVE FOR HANDLERR
DE-             ERRNUM         .EQ $DE        WHICH ERROR OCCURRED
DF-             ERRSTK         .EQ $DF        STACK PNTR BEFORE ERROR
E0-             HGR.X          .EQ $E0,E1
E2-             HGR.Y          .EQ $E2
E4-             HGR.COLOR      .EQ $E4
E5-             HGR.HORIZ      .EQ $E5        BYTE INDEX FROM GBASH,L
E6-             HGR.PAGE       .EQ $E6        HGR=$20, HGR2=$40
E7-             HGR.SCALE      .EQ $E7
E8-             HGR.SHAPE.PNTR .EQ $E8,E9
EA-             HGR.COLLISIONS .EQ $EA
F0-             FIRST          .EQ $F0
F1-             SPEEDZ         .EQ $F1        OUTPUT SPEED
F2-             TRCFLG         .EQ $F2
F3-             FLASH.BIT      .EQ $F3        = $40 FOR FLASH, ELSE =$00
F4-             TXTPSV         .EQ $F4,F5
F6-             CURLSV         .EQ $F6,F7
F8-             REMSTK         .EQ $F8        STACK PNTR BEFORE EACH STT.
F9-             HGR.ROTATION   .EQ $F9
                * $FF IS ALSO USED BY THE STRING OUT ROUTINES
                *--------------------------------
0100-           STACK            .EQ $100
0200-           INPUT.BUFFER     .EQ $200
03F5-           AMPERSAND.VECTOR .EQ $3F5 - 3F7   GETS "JMP ...."
                *--------------------------------
                *      I/O &amp; SOFT SWITCHES
                *--------------------------------
C000-           KEYBOARD         .EQ $C000
C050-           SW.TXTCLR        .EQ $C050
C052-           SW.MIXCLR        .EQ $C052
C053-           SW.MIXSET        .EQ $C053
C054-           SW.LOWSCR        .EQ $C054
C055-           SW.HISCR         .EQ $C055
C056-           SW.LORES         .EQ $C056
C057-           SW.HIRES         .EQ $C057
                *--------------------------------
                *      MONITOR SUBROUTINES
                *--------------------------------
F800-           MON.PLOT         .EQ $F800
F819-           MON.HLINE        .EQ $F819
F828-           MON.VLINE        .EQ $F828
F864-           MON.SETCOL       .EQ $F864
F871-           MON.SCRN         .EQ $F871
FB1E-           MON.PREAD        .EQ $FB1E
FB39-           MON.SETTXT       .EQ $FB39
FB40-           MON.SETGR        .EQ $FB40
FB5B-           MON.TABV         .EQ $FB5B
FC58-           MON.HOME         .EQ $FC58
FCA8-           MON.WAIT         .EQ $FCA8
FCFA-           MON.RD2BIT       .EQ $FCFA
FD0C-           MON.RDKEY        .EQ $FD0C
FD6A-           MON.GETLN        .EQ $FD6A
FDED-           MON.COUT         .EQ $FDED
FE8B-           MON.INPORT       .EQ $FE8B
FE95-           MON.OUTPORT      .EQ $FE95
FECD-           MON.WRITE        .EQ $FECD
FEFD-           MON.READ         .EQ $FEFD
FF02-           MON.READ2        .EQ $FF02
                *--------------------------------
                *--------------------------------
                *   APPLESOFT TOKENS
                *--------------------------------
81-             TOKEN.FOR        .EQ $81
83-             TOKEN.DATA       .EQ $83
A1-             TOKEN.POP        .EQ $A1
AB-             TOKEN.GOTO       .EQ $AB
B0-             TOKEN.GOSUB      .EQ $B0
B2-             TOKEN.REM        .EQ $B2
BA-             TOKEN.PRINT      .EQ $BA
C0-             TOKEN.TAB        .EQ $C0
C1-             TOKEN.TO         .EQ $C1
C2-             TOKEN.FN         .EQ $C2
C3-             TOKEN.SPC        .EQ $C3
C4-             TOKEN.THEN       .EQ $C4
C5-             TOKEN.AT         .EQ $C5
C6-             TOKEN.NOT        .EQ $C6
C7-             TOKEN.STEP       .EQ $C7
C8-             TOKEN.PLUS       .EQ $C8
C9-             TOKEN.MINUS      .EQ $C9
CF-             TOKEN.GREATER    .EQ $CF
D0-             TOKEN.EQUAL      .EQ $D0
D2-             TOKEN.SGN        .EQ $D2
D7-             TOKEN.SCRN       .EQ $D7
E8-             TOKEN.LEFTSTR    .EQ $E8
                *--------------------------------
                *      BRANCH TABLE FOR TOKENS
                *--------------------------------
                <b><a name="TOKEN.ADDRESS.TABLE" id="TOKEN.ADDRESS.TABLE">TOKEN.ADDRESS.TABLE</a></b>
D000- 6F D8        .DA END-1        $80...128...END
D002- 65 D7        .DA FOR-1        $81...129...FOR
D004- F8 DC        .DA NEXT-1       $82...130...NEXT
D006- 94 D9        .DA DATA-1       $83...131...DATA
D008- B1 DB        .DA INPUT-1      $84...132...INPUT
D00A- 30 F3        .DA DEL-1        $85...133...DEL
D00C- D8 DF        .DA DIM-1        $86...134...DIM
D00E- E1 DB        .DA READ-1       $87...135...READ
D010- 8F F3        .DA GR-1         $88...136...GR
D012- 98 F3        .DA TEXT-1       $89...137...TEXT
D014- E4 F1        .DA PR.NUMBER-1  $8A...138...PR#
D016- DD F1        .DA IN.NUMBER-1  $8B...139...IN#
D018- D4 F1        .DA CALL-1       $8C...140...CALL
D01A- 24 F2        .DA PLOT-1       $8D...141...PLOT
D01C- 31 F2        .DA HLIN-1       $8E...142...HLIN
D01E- 40 F2        .DA VLIN-1       $8F...143...VLIN
D020- D7 F3        .DA HGR2-1       $90...144...HGR2
D022- E1 F3        .DA HGR-1        $91...145...HGR
D024- E8 F6        .DA HCOLOR-1     $92...146...HCOLOR=
D026- FD F6        .DA HPLOT-1      $93...147...HPLOT
D028- 68 F7        .DA DRAW-1       $94...148...DRAW
D02A- 6E F7        .DA XDRAW-1      $95...149...XDRAW
D02C- E6 F7        .DA HTAB-1       $96...150...HTAB
D02E- 57 FC        .DA MON.HOME-1   $97...151...HOME
D030- 20 F7        .DA ROT-1        $98...152...ROT=
D032- 26 F7        .DA SCALE-1      $99...153...SCALE=
D034- 74 F7        .DA SHLOAD-1     $9A...154...SHLOAD
D036- 6C F2        .DA TRACE-1      $9B...155...TRACE
D038- 6E F2        .DA NOTRACE-1    $9C...156...NOTRACE
D03A- 72 F2        .DA NORMAL-1     $9D...157...NORMAL
D03C- 76 F2        .DA INVERSE-1    $9E...158...INVERSE
D03E- 7F F2        .DA FLASH-1      $9F...159...FLASH
D040- 4E F2        .DA COLOR-1      $A0...160...COLOR=
D042- 6A D9        .DA POP-1        $A1...161...POP
D044- 55 F2        .DA VTAB-1       $A2...162...VTAB
D046- 85 F2        .DA HIMEM-1      $A3...163...HIMEM:
D048- A5 F2        .DA LOMEM-1      $A4...164...LOMEM:
D04A- CA F2        .DA ONERR-1      $A5...165...ONERR
D04C- 17 F3        .DA RESUME-1     $A6...166...RESUME
D04E- BB F3        .DA RECALL-1     $A7...167...RECALL
D050- 9E F3        .DA STORE-1      $A8...168...STORE
D052- 61 F2        .DA SPEED-1      $A9...169...SPEED=
D054- 45 DA        .DA LET-1        $AA...170...LET
D056- 3D D9        .DA GOTO-1       $AB...171...GOTO
D058- 11 D9        .DA RUN-1        $AC...172...RUN
D05A- C8 D9        .DA IF-1         $AD...173...IF
D05C- 48 D8        .DA RESTORE-1    $AE...174...RESTORE
D05E- F4 03        .DA AMPERSAND.VECTOR-1 $AF...175...&amp;
D060- 20 D9        .DA GOSUB-1      $B0...176...GOSUB
D062- 6A D9        .DA POP-1        $B1...177...RETURN
D064- DB D9        .DA REM-1        $B2...178...REM
D066- 6D D8        .DA STOP-1       $B3...179...STOP
D068- EB D9        .DA ONGOTO-1     $B4...180...ON
D06A- 83 E7        .DA WAIT-1       $B5...181...WAIT
D06C- C8 D8        .DA LOAD-1       $B6...182...LOAD
D06E- AF D8        .DA SAVE-1       $B7...183...SAVE
D070- 12 E3        .DA DEF-1        $B8...184...DEF
D072- 7A E7        .DA POKE-1       $B9...185...POKE
D074- D4 DA        .DA PRINT-1      $BA...186...PRINT
D076- 95 D8        .DA CONT-1       $BB...187...CONT
D078- A4 D6        .DA LIST-1       $BC...188...LIST
D07A- 69 D6        .DA CLEAR-1      $BD...189...CLEAR
D07C- 9F DB        .DA GET-1        $BE...190...GET
D07E- 48 D6        .DA NEW-1        $BF...191...NEW
                *--------------------------------
                <b><a name="UNFNC" id="UNFNC">UNFNC</a></b>
D080- 90 EB        .DA SGN          $D2...210...SGN
D082- 23 EC        .DA INT          $D3...211...INT
D084- AF EB        .DA ABS          $D4...212...ABS
D086- 0A 00        .DA USR          $D5...213...USR
D088- DE E2        .DA FRE          $D6...214...FRE
D08A- 12 D4        .DA ERROR        $D7...215...SCRN(
D08C- CD DF        .DA PDL          $D8...216...PDL
D08E- FF E2        .DA POS          $D9...217...POS
D090- 8D EE        .DA SQR          $DA...218...SQR
D092- AE EF        .DA RND          $DB...219...RND
D094- 41 E9        .DA LOG          $DC...220...LOG
D096- 09 EF        .DA EXP          $DD...221...EXP
D098- EA EF        .DA COS          $DE...222...COS
D09A- F1 EF        .DA SIN          $DF...223...SIN
D09C- 3A F0        .DA TAN          $E0...224...TAN
D09E- 9E F0        .DA ATN          $E1...225...ATN
D0A0- 64 E7        .DA PEEK         $E2...226...PEEK
D0A2- D6 E6        .DA LEN          $E3...227...LEN
D0A4- C5 E3        .DA STR          $E4...228...STR$
D0A6- 07 E7        .DA VAL          $E5...229...VAL
D0A8- E5 E6        .DA ASC          $E6...230...ASC
D0AA- 46 E6        .DA CHRSTR       $E7...231...CHR$
D0AC- 5A E6        .DA LEFTSTR      $E8...232...LEFT$
D0AE- 86 E6        .DA RIGHTSTR     $E9...233...RIGHT$
D0B0- 91 E6        .DA MIDSTR       $EA...234...MID$
                *--------------------------------
                *      MATH OPERATOR BRANCH TABLE
                *
                *      ONE-BYTE PRECEDENCE CODE
                *      TWO-BYTE ADDRESS
                *--------------------------------
46-             P.OR   .EQ $46      "OR" IS LOWEST PRECEDENCE
50-             P.AND  .EQ $50
64-             P.REL  .EQ $64      RELATIONAL OPERATORS
79-             P.ADD  .EQ $79      BINARY + AND -
7B-             P.MUL  .EQ $7B      * AND /
7D-             P.PWR  .EQ $7D      EXPONENTIATION
7F-             P.NEQ  .EQ $7F      UNARY - AND COMPARISON =
                *--------------------------------
                <b><a name="MATHTBL" id="MATHTBL">MATHTBL</a></b>
D0B2- 79 C0 E7         .DA #P.ADD,FADDT-1  $C8...200...+
D0B5- 79 A9 E7         .DA #P.ADD,FSUBT-1  $C9...201...-
D0B8- 7B 81 E9         .DA #P.MUL,FMULTT-1 $CA...202...*
D0BB- 7B 68 EA         .DA #P.MUL,FDIVT-1  $CB...203.../
D0BE- 7D 96 EE         .DA #P.PWR,FPWRT-1  $CC...204...^
D0C1- 50 54 DF         .DA #P.AND,AND-1    $CD...205...AND
D0C4- 46 4E DF         .DA #P.OR,OR-1      $CE...206...OR
D0C7- 7F CF EE  <b><a name="M.NEG" id="M.NEG">M.NEG</a></b>  .DA #P.NEQ,NEGOP-1  $CF...207...&gt;
D0CA- 7F 97 DE  <b><a name="M.EQU" id="M.EQU">M.EQU</a></b>  .DA #P.NEQ,EQUOP-1  $D0...208...=
D0CD- 64 64 DF  <b><a name="M.REL" id="M.REL">M.REL</a></b>  .DA #P.REL,RELOPS-1 $D1...209...&lt;
                *--------------------------------
                *      TOKEN NAME TABLE
                *--------------------------------
                <b><a name="TOKEN.NAME.TABLE" id="TOKEN.NAME.TABLE">TOKEN.NAME.TABLE</a></b>
D0D0- 45 4E C4     .AT "END"        $80...128
D0D3- 46 4F D2     .AT "FOR"        $81...129
D0D6- 4E 45 58
D0D9- D4           .AT "NEXT"       $82...130
D0DA- 44 41 54
D0DD- C1           .AT "DATA"       $83...131
D0DE- 49 4E 50
D0E1- 55 D4        .AT "INPUT"      $84...132
D0E3- 44 45 CC     .AT "DEL"        $85...133
D0E6- 44 49 CD     .AT "DIM"        $86...134
D0E9- 52 45 41
D0EC- C4           .AT "READ"       $87...135
D0ED- 47 D2        .AT "GR"         $88...136
D0EF- 54 45 58
D0F2- D4           .AT "TEXT"       $89...137
D0F3- 50 52 A3     .AT "PR#"        $8A...138
D0F6- 49 4E A3     .AT "IN#"        $8B...139
D0F9- 43 41 4C
D0FC- CC           .AT "CALL"       $8C...140
D0FD- 50 4C 4F
D100- D4           .AT "PLOT"       $8D...141
D101- 48 4C 49
D104- CE           .AT "HLIN"       $8E...142
D105- 56 4C 49
D108- CE           .AT "VLIN"       $8F...143
D109- 48 47 52
D10C- B2           .AT "HGR2"       $90...144
D10D- 48 47 D2     .AT "HGR"        $91...145
D110- 48 43 4F
D113- 4C 4F 52
D116- BD           .AT "HCOLOR="    $92...146
D117- 48 50 4C
D11A- 4F D4        .AT "HPLOT"      $93...147
D11C- 44 52 41
D11F- D7           .AT "DRAW"       $94...148
D120- 58 44 52
D123- 41 D7        .AT "XDRAW"      $95...149
D125- 48 54 41
D128- C2           .AT "HTAB"       $96...150
D129- 48 4F 4D
D12C- C5           .AT "HOME"       $97...151
D12D- 52 4F 54
D130- BD           .AT "ROT="       $98...152
D131- 53 43 41
D134- 4C 45 BD     .AT "SCALE="     $99...153
D137- 53 48 4C
D13A- 4F 41 C4     .AT "SHLOAD"     $9A...154
D13D- 54 52 41
D140- 43 C5        .AT "TRACE"      $9B...155
D142- 4E 4F 54
D145- 52 41 43
D148- C5           .AT "NOTRACE"    $9C...156
D149- 4E 4F 52
D14C- 4D 41 CC     .AT "NORMAL"     $9D...157
D14F- 49 4E 56
D152- 45 52 53
D155- C5           .AT "INVERSE"    $9E...158
D156- 46 4C 41
D159- 53 C8        .AT "FLASH"      $9F...159
D15B- 43 4F 4C
D15E- 4F 52 BD     .AT "COLOR="     $A0...160
D161- 50 4F D0     .AT "POP"        $A1...161
D164- 56 54 41
D167- C2           .AT "VTAB"       $A2...162
D168- 48 49 4D
D16B- 45 4D BA     .AT "HIMEM:"     $A3...163
D16E- 4C 4F 4D
D171- 45 4D BA     .AT "LOMEM:"     $A4...164
D174- 4F 4E 45
D177- 52 D2        .AT "ONERR"      $A5...165
D179- 52 45 53
D17C- 55 4D C5     .AT "RESUME"     $A6...166
D17F- 52 45 43
D182- 41 4C CC     .AT "RECALL"     $A7...167
D185- 53 54 4F
D188- 52 C5        .AT "STORE"      $A8...168
D18A- 53 50 45
D18D- 45 44 BD     .AT "SPEED="     $A9...169
D190- 4C 45 D4     .AT "LET"        $AA...170
D193- 47 4F 54
D196- CF           .AT "GOTO"       $AB...171
D197- 52 55 CE     .AT "RUN"        $AC...172
D19A- 49 C6        .AT "IF"         $AD...173
D19C- 52 45 53
D19F- 54 4F 52
D1A2- C5           .AT "RESTORE"    $AE...174
D1A3- A6           .AT "&amp;"          $AF...175
D1A4- 47 4F 53
D1A7- 55 C2        .AT "GOSUB"      $B0...176
D1A9- 52 45 54
D1AC- 55 52 CE     .AT "RETURN"     $B1...177
D1AF- 52 45 CD     .AT "REM"        $B2...178
D1B2- 53 54 4F
D1B5- D0           .AT "STOP"       $B3...179
D1B6- 4F CE        .AT "ON"         $B4...180
D1B8- 57 41 49
D1BB- D4           .AT "WAIT"       $B5...181
D1BC- 4C 4F 41
D1BF- C4           .AT "LOAD"       $B6...182
D1C0- 53 41 56
D1C3- C5           .AT "SAVE"       $B7...183
D1C4- 44 45 C6     .AT "DEF"        $B8...184
D1C7- 50 4F 4B
D1CA- C5           .AT "POKE"       $B9...185
D1CB- 50 52 49
D1CE- 4E D4        .AT "PRINT"      $BA...186
D1D0- 43 4F 4E
D1D3- D4           .AT "CONT"       $BB...187
D1D4- 4C 49 53
D1D7- D4           .AT "LIST"       $BC...188
D1D8- 43 4C 45
D1DB- 41 D2        .AT "CLEAR"      $BD...189
D1DD- 47 45 D4     .AT "GET"        $BE...190
D1E0- 4E 45 D7     .AT "NEW"        $BF...191
D1E3- 54 41 42
D1E6- A8           .AT "TAB("       $C0...192
D1E7- 54 CF        .AT "TO"         $C1...193
D1E9- 46 CE        .AT "FN"         $C2...194
D1EB- 53 50 43
D1EE- A8           .AT "SPC("       $C3...195
D1EF- 54 48 45
D1F2- CE           .AT "THEN"       $C4...196
D1F3- 41 D4        .AT "AT"         $C5...197
D1F5- 4E 4F D4     .AT "NOT"        $C6...198
D1F8- 53 54 45
D1FB- D0           .AT "STEP"       $C7...199
D1FC- AB           .AT "+"          $C8...200
D1FD- AD           .AT "-"          $C9...201
D1FE- AA           .AT "*"          $CA...202
D1FF- AF           .AT "/"          $CB...203
D200- DE           .AT "^"          $CC...204
D201- 41 4E C4     .AT "AND"        $CD...205
D204- 4F D2        .AT "OR"         $CE...206
D206- BE           .AT "&gt;"          $CF...207
D207- BD           .AT "="          $D0...208
D208- BC           .AT "&lt;"          $D1...209
D209- 53 47 CE     .AT "SGN"        $D2...210
D20C- 49 4E D4     .AT "INT"        $D3...211
D20F- 41 42 D3     .AT "ABS"        $D4...212
D212- 55 53 D2     .AT "USR"        $D5...213
D215- 46 52 C5     .AT "FRE"        $D6...214
D218- 53 43 52
D21B- 4E A8        .AT "SCRN("      $D7...215
D21D- 50 44 CC     .AT "PDL"        $D8...216
D220- 50 4F D3     .AT "POS"        $D9...217
D223- 53 51 D2     .AT "SQR"        $DA...218
D226- 52 4E C4     .AT "RND"        $DB...219
D229- 4C 4F C7     .AT "LOG"        $DC...220
D22C- 45 58 D0     .AT "EXP"        $DD...221
D22F- 43 4F D3     .AT "COS"        $DE...222
D232- 53 49 CE     .AT "SIN"        $DF...223
D235- 54 41 CE     .AT "TAN"        $E0...224
D238- 41 54 CE     .AT "ATN"        $E1...225
D23B- 50 45 45
D23E- CB           .AT "PEEK"       $E2...226
D23F- 4C 45 CE     .AT "LEN"        $E3...227
D242- 53 54 52
D245- A4           .AT "STR$"       $E4...228
D246- 56 41 CC     .AT "VAL"        $E5...229
D249- 41 53 C3     .AT "ASC"        $E6...230
D24C- 43 48 52
D24F- A4           .AT "CHR$"       $E7...231
D250- 4C 45 46
D253- 54 A4        .AT "LEFT$"      $E8...232
D255- 52 49 47
D258- 48 54 A4     .AT "RIGHT$"     $E9...233
D25B- 4D 49 44
D25E- A4           .AT "MID$"       $EA...234
D25F- 00           .HS 00       END OF TOKEN NAME TABLE
                *--------------------------------
                *--------------------------------
                *      ERROR MESSAGES
                *--------------------------------
                <b><a name="ERROR.MESSAGES" id="ERROR.MESSAGES">ERROR.MESSAGES</a></b>
00-             ERR.NOFOR      .EQ *-ERROR.MESSAGES
D260- 4E 45 58
D263- 54 20 57
D266- 49 54 48
D269- 4F 55 54
D26C- 20 46 4F
D26F- D2                       .AT /NEXT WITHOUT FOR/
10-             ERR.SYNTAX     .EQ *-ERROR.MESSAGES
D270- 53 59 4E
D273- 54 41 D8                 .AT /SYNTAX/
16-             ERR.NOGOSUB    .EQ *-ERROR.MESSAGES
D276- 52 45 54
D279- 55 52 4E
D27C- 20 57 49
D27F- 54 48 4F
D282- 55 54 20
D285- 47 4F 53
D288- 55 C2                    .AT /RETURN WITHOUT GOSUB/
2A-             ERR.NODATA     .EQ *-ERROR.MESSAGES
D28A- 4F 55 54
D28D- 20 4F 46
D290- 20 44 41
D293- 54 C1                    .AT /OUT OF DATA/
35-             ERR.ILLQTY     .EQ *-ERROR.MESSAGES
D295- 49 4C 4C
D298- 45 47 41
D29B- 4C 20 51
D29E- 55 41 4E
D2A1- 54 49 54
D2A4- D9                       .AT /ILLEGAL QUANTITY/
45-             ERR.OVERFLOW   .EQ *-ERROR.MESSAGES
D2A5- 4F 56 45
D2A8- 52 46 4C
D2AB- 4F D7                    .AT /OVERFLOW/
4D-             ERR.MEMFULL    .EQ *-ERROR.MESSAGES
D2AD- 4F 55 54
D2B0- 20 4F 46
D2B3- 20 4D 45
D2B6- 4D 4F 52
D2B9- D9                       .AT /OUT OF MEMORY/
5A-             ERR.UNDEFSTAT  .EQ *-ERROR.MESSAGES
D2BA- 55 4E 44
D2BD- 45 46 27
D2C0- 44 20 53
D2C3- 54 41 54
D2C6- 45 4D 45
D2C9- 4E D4                    .AT /UNDEF'D STATEMENT/
6B-             ERR.BADSUBS    .EQ *-ERROR.MESSAGES
D2CB- 42 41 44
D2CE- 20 53 55
D2D1- 42 53 43
D2D4- 52 49 50
D2D7- D4                       .AT /BAD SUBSCRIPT/
78-             ERR.REDIMD     .EQ *-ERROR.MESSAGES
D2D8- 52 45 44
D2DB- 49 4D 27
D2DE- 44 20 41
D2E1- 52 52 41
D2E4- D9                       .AT /REDIM'D ARRAY/
85-             ERR.ZERODIV    .EQ *-ERROR.MESSAGES
D2E5- 44 49 56
D2E8- 49 53 49
D2EB- 4F 4E 20
D2EE- 42 59 20
D2F1- 5A 45 52
D2F4- CF                       .AT /DIVISION BY ZERO/
95-             ERR.ILLDIR     .EQ *-ERROR.MESSAGES
D2F5- 49 4C 4C
D2F8- 45 47 41
D2FB- 4C 20 44
D2FE- 49 52 45
D301- 43 D4                    .AT /ILLEGAL DIRECT/
A3-             ERR.BADTYPE    .EQ *-ERROR.MESSAGES
D303- 54 59 50
D306- 45 20 4D
D309- 49 53 4D
D30C- 41 54 43
D30F- C8                       .AT /TYPE MISMATCH/
B0-             ERR.STRLONG    .EQ *-ERROR.MESSAGES
D310- 53 54 52
D313- 49 4E 47
D316- 20 54 4F
D319- 4F 20 4C
D31C- 4F 4E C7                 .AT /STRING TOO LONG/
BF-             ERR.FRMCPX     .EQ *-ERROR.MESSAGES
D31F- 46 4F 52
D322- 4D 55 4C
D325- 41 20 54
D328- 4F 4F 20
D32B- 43 4F 4D
D32E- 50 4C 45
D331- D8                       .AT /FORMULA TOO COMPLEX/
D2-             ERR.CANTCONT   .EQ *-ERROR.MESSAGES
D332- 43 41 4E
D335- 27 54 20
D338- 43 4F 4E
D33B- 54 49 4E
D33E- 55 C5                    .AT /CAN'T CONTINUE/
E0-             ERR.UNDEFFUNC  .EQ *-ERROR.MESSAGES
D340- 55 4E 44
D343- 45 46 27
D346- 44 20 46
D349- 55 4E 43
D34C- 54 49 4F
D34F- CE                       .AT /UNDEF'D FUNCTION/
                *--------------------------------
D350- 20 45 52
D353- 52 4F 52  <b><a name="QT.ERROR" id="QT.ERROR">QT.ERROR</a></b>   .AS / ERROR/
D356- 07 00                .HS 0700      BELL
D358- 20 49 4E
D35B- 20        <b><a name="QT.IN" id="QT.IN">QT.IN</a></b>      .AS / IN /
D35C- 00                   .HS 00
D35D- 0D        <b><a name="QT.BREAK" id="QT.BREAK">QT.BREAK</a></b>   .HS 0D
D35E- 42 52 45
D361- 41 4B                .AS /BREAK/
D363- 07 00                .HS 0700      BELL
                *--------------------------------
                *      CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
                *      THE STACK FOR A FRAME WITH THE SAME VARIABLE.
                *
                *      (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
                *               = $XXFF IF CALLED FROM "RETURN"
                *                 &lt;&lt;&lt; BUG: SHOULD BE $FFXX &gt;&gt;&gt;
                *
                *      RETURNS .NE. IF VARIABLE NOT FOUND,
                *              (X) = STACK PNTR AFTER SKIPPING ALL FRAMES
                *
                *              .EQ. IF FOUND
                *              (X) = STACK PNTR OF FRAME FOUND
                *--------------------------------
                <b><a name="GTFORPNT" id="GTFORPNT">GTFORPNT</a></b>
D365- BA               TSX
D366- E8               INX
D367- E8               INX
D368- E8               INX
D369- E8               INX
D36A- BD 01 01  .1     LDA STACK+1,X     "FOR" FRAME HERE?
D36D- C9 81            CMP #TOKEN.FOR
D36F- D0 21            BNE .4            NO
D371- A5 86            LDA FORPNT+1      YES -- "NEXT" WITH NO VARIABLE?
D373- D0 0A            BNE .2            NO, VARIABLE SPECIFIED
D375- BD 02 01         LDA STACK+2,X     YES, SO USE THIS FRAME
D378- 85 85            STA FORPNT
D37A- BD 03 01         LDA STACK+3,X
D37D- 85 86            STA FORPNT+1
D37F- DD 03 01  .2     CMP STACK+3,X     IS VARIABLE IN THIS FRAME?
D382- D0 07            BNE .3            NO
D384- A5 85            LDA FORPNT        LOOK AT 2ND BYTE TOO
D386- DD 02 01         CMP STACK+2,X     SAME VARIABLE?
D389- F0 07            BEQ .4            YES
D38B- 8A        .3     TXA               NO, SO TRY NEXT FRAME (IF ANY)
D38C- 18               CLC               18 BYTES PER FRAME
D38D- 69 12            ADC #18
D38F- AA               TAX
D390- D0 D8            BNE .1       ...ALWAYS?
D392- 60        .4     RTS
                *--------------------------------
                *      MOVE BLOCK OF MEMORY UP
                *
                *      ON ENTRY:
                *          (Y,A) = (HIGHDS) = DESTINATION END+1
                *          (LOWTR) = LOWEST ADDRESS OF SOURCE
                *          (HIGHTR) = HIGHEST SOURCE ADDRESS+1
                *--------------------------------
D393- 20 E3 D3  <b><a name="BLTU" id="BLTU">BLTU</a></b>   JSR <a href="#REASON">REASON</a>   BE SURE (Y,A) &lt; FRETOP
D396- 85 6D            STA STREND   NEW TOP OF ARRAY STORAGE
D398- 84 6E            STY STREND+1
D39A- 38        <b><a name="BLTU2" id="BLTU2">BLTU2</a></b>  SEC
D39B- A5 96            LDA HIGHTR   COMPUTE # OF BYTES TO BE MOVED
D39D- E5 9B            SBC LOWTR         (FROM LOWTR THRU HIGHTR-1)
D39F- 85 5E            STA INDEX    PARTIAL PAGE AMOUNT
D3A1- A8               TAY
D3A2- A5 97            LDA HIGHTR+1
D3A4- E5 9C            SBC LOWTR+1
D3A6- AA               TAX          # OF WHOLE PAGES IN X-REG
D3A7- E8               INX
D3A8- 98               TYA          # BYTES IN PARTIAL PAGE
D3A9- F0 23            BEQ .4       NO PARTIAL PAGE
D3AB- A5 96            LDA HIGHTR   BACK UP HIGHTR # BYTES IN PARTIAL PAGE
D3AD- 38               SEC
D3AE- E5 5E            SBC INDEX
D3B0- 85 96            STA HIGHTR
D3B2- B0 03            BCS .1
D3B4- C6 97            DEC HIGHTR+1
D3B6- 38               SEC
D3B7- A5 94     .1     LDA HIGHDS   BACK UP HIGHDS # BYTES IN PARTIAL PAGE
D3B9- E5 5E            SBC INDEX
D3BB- 85 94            STA HIGHDS
D3BD- B0 08            BCS .3
D3BF- C6 95            DEC HIGHDS+1
D3C1- 90 04            BCC .3       ...ALWAYS
D3C3- B1 96     .2     LDA (HIGHTR),Y    MOVE THE BYTES
D3C5- 91 94            STA (HIGHDS),Y
D3C7- 88        .3     DEY
D3C8- D0 F9            BNE .2       LOOP TO END OF THIS 256 BYTES
D3CA- B1 96            LDA (HIGHTR),Y    MOVE ONE MORE BYTE
D3CC- 91 94            STA (HIGHDS),Y
D3CE- C6 97     .4     DEC HIGHTR+1      DOWN TO NEXT BLOCK OF 256
D3D0- C6 95            DEC HIGHDS+1
D3D2- CA               DEX          ANOTHER BLOCK OF 256 TO MOVE?
D3D3- D0 F2            BNE .3       YES
D3D5- 60               RTS          NO, FINISHED
                *--------------------------------
                *      CHECK IF ENOUGH ROOM LEFT ON STACK
                *      FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
                *--------------------------------
D3D6- 0A        <b><a name="CHKMEM" id="CHKMEM">CHKMEM</a></b> ASL
D3D7- 69 36            ADC #54
D3D9- B0 35            BCS <a href="#MEMERR">MEMERR</a>   ...MEM FULL ERR
D3DB- 85 5E            STA INDEX
D3DD- BA               TSX
D3DE- E4 5E            CPX INDEX
D3E0- 90 2E            BCC <a href="#MEMERR">MEMERR</a>   ...MEM FULL ERR
D3E2- 60               RTS
                *--------------------------------
                *      CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
                *      (Y,A) = ADDR ARRAYS NEED TO GROW TO
                *--------------------------------
D3E3- C4 70     <b><a name="REASON" id="REASON">REASON</a></b> CPY FRETOP+1      HIGH BYTE
D3E5- 90 28            BCC .4       PLENTY OF ROOM
D3E7- D0 04            BNE .1       NOT ENOUGH, TRY GARBAGE COLLECTION
D3E9- C5 6F            CMP FRETOP   LOW BYTE
D3EB- 90 22            BCC .4       ENOUGH ROOM
                *--------------------------------
D3ED- 48        .1     PHA          SAVE (Y,A), TEMP1, AND TEMP2
D3EE- A2 09            LDX #FAC-TEMP1-1
D3F0- 98               TYA
D3F1- 48        .2     PHA
D3F2- B5 93            LDA TEMP1,X
D3F4- CA               DEX
D3F5- 10 FA            BPL .2
D3F7- 20 84 E4         JSR <a href="#GARBAG">GARBAG</a>   MAKE AS MUCH ROOM AS POSSIBLE
D3FA- A2 F7            LDX #TEMP1-FAC+1  RESTORE TEMP1 AND TEMP2
D3FC- 68        .3     PLA               AND (Y,A)
D3FD- 95 9D            STA FAC,X
D3FF- E8               INX
D400- 30 FA            BMI .3
D402- 68               PLA
D403- A8               TAY
D404- 68               PLA          DID WE FIND ENOUGH ROOM?
D405- C4 70            CPY FRETOP+1 HIGH BYTE
D407- 90 06            BCC .4       YES, AT LEAST A PAGE
D409- D0 05            BNE <a href="#MEMERR">MEMERR</a>   NO, MEM FULL ERR
D40B- C5 6F            CMP FRETOP   LOW BYTE
D40D- B0 01            BCS <a href="#MEMERR">MEMERR</a>   NO, MEM FULL ERR
D40F- 60        .4     RTS          YES, RETURN
                *--------------------------------
D410- A2 4D     <b><a name="MEMERR" id="MEMERR">MEMERR</a></b> LDX #ERR.MEMFULL
                *--------------------------------
                *      HANDLE AN ERROR
                *
                *      (X)=OFFSET IN ERROR MESSAGE TABLE
                *      (ERRFLG) &gt; 128 IF "ON ERR" TURNED ON
                *      (CURLIN+1) = $FF IF IN DIRECT MODE
                *--------------------------------
D412- 24 D8     <b><a name="ERROR" id="ERROR">ERROR</a></b>  BIT <a href="#ERRFLG">ERRFLG</a>   "ON ERR" TURNED ON?
D414- 10 03            BPL .1       NO
D416- 4C E9 F2         JMP <a href="#HANDLERR">HANDLERR</a> YES
D419- 20 FB DA  .1     JSR <a href="#CRDO">CRDO</a>     PRINT &lt;RETURN&gt;
D41C- 20 5A DB         JSR <a href="#OUTQUES">OUTQUES</a>  PRINT "?"
D41F- BD 60 D2  .2     LDA ERROR.MESSAGES,X
D422- 48               PHA          PRINT MESSAGE
D423- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>
D426- E8               INX
D427- 68               PLA
D428- 10 F5            BPL .2
D42A- 20 83 D6         JSR <a href="#STKINI">STKINI</a>   FIX STACK, ET AL
D42D- A9 50            LDA #QT.ERROR   PRINT " ERROR" AND BELL
D42F- A0 D3            LDY /QT.ERROR
                *--------------------------------
                *      PRINT STRING AT (Y,A)
                *      PRINT CURRENT LINE # UNLESS IN DIRECT MODE
                *      FALL INTO WARM RESTART
                *--------------------------------
                <b><a name="PRINT.ERROR.LINNUM" id="PRINT.ERROR.LINNUM">PRINT.ERROR.LINNUM</a></b>
D431- 20 3A DB         JSR <a href="#STROUT">STROUT</a>      PRINT STRING AT (Y,A)
D434- A4 76            LDY CURLIN+1      RUNNING, OR DIRECT?
D436- C8               INY
D437- F0 03            BEQ <a href="#RESTART">RESTART</a>       WAS $FF, SO DIRECT MODE
D439- 20 19 ED         JSR <a href="#INPRT">INPRT</a>         RUNNING, SO PRINT LINE NUMBER
                *--------------------------------
                *      WARM RESTART ENTRY
                *
                *      COME HERE FROM MONITOR BY CTL-C, 0G, 3D0G, OR E003G
                *--------------------------------
                <b><a name="RESTART" id="RESTART">RESTART</a></b>
D43C- 20 FB DA         JSR <a href="#CRDO">CRDO</a>          PRINT &lt;RETURN&gt;
D43F- A2 DD            LDX #']+$80       PROMPT CHARACTER
D441- 20 2E D5         JSR <a href="#INLIN2">INLIN2</a>        READ A LINE
D444- 86 B8            STX TXTPTR        SET UP CHRGET TO SCAN THE LINE
D446- 84 B9            STY TXTPTR+1
D448- 46 D8            LSR ERRFLG        CLEAR FLAG
D44A- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>
D44D- AA               TAX
D44E- F0 EC            BEQ <a href="#RESTART">RESTART</a>       EMPTY LINE
D450- A2 FF            LDX #$FF     $FF IN HI-BYTE OF CURLIN MEANS
D452- 86 76            STX CURLIN+1      WE ARE IN DIRECT MODE
D454- 90 06            BCC <a href="#NUMBERED.LINE">NUMBERED.LINE</a> CHRGET SAW DIGIT, NUMBERED LINE
D456- 20 59 D5         JSR <a href="#PARSE.INPUT.LINE">PARSE.INPUT.LINE</a>    NO NUMBER, SO PARSE IT
D459- 4C 05 D8         JMP <a href="#TRACE.">TRACE.</a>   AND TRY EXECUTING IT
                *--------------------------------
                *      HANDLE NUMBERED LINE
                *--------------------------------
                <b><a name="NUMBERED.LINE" id="NUMBERED.LINE">NUMBERED.LINE</a></b>
D45C- A6 AF            LDX PRGEND   SQUASH VARIABLE TABLE
D45E- 86 69            STX VARTAB
D460- A6 B0            LDX PRGEND+1
D462- 86 6A            STX VARTAB+1
D464- 20 0C DA         JSR <a href="#LINGET">LINGET</a>              GET LINE #
D467- 20 59 D5         JSR <a href="#PARSE.INPUT.LINE">PARSE.INPUT.LINE</a>    AND PARSE THE INPUT LINE
D46A- 84 0F            STY EOL.PNTR     SAVE INDEX TO INPUT BUFFER
D46C- 20 1A D6         JSR <a href="#FNDLIN">FNDLIN</a>       IS THIS LINE # ALREADY IN PROGRAM?
D46F- 90 44            BCC <a href="#PUT.NEW.LINE">PUT.NEW.LINE</a> NO
D471- A0 01            LDY #1           YES, SO DELETE IT
D473- B1 9B            LDA (LOWTR),Y    LOWTR POINTS AT LINE
D475- 85 5F            STA INDEX+1      GET HIGH BYTE OF FORWARD PNTR
D477- A5 69            LDA VARTAB
D479- 85 5E            STA INDEX
D47B- A5 9C            LDA LOWTR+1
D47D- 85 61            STA DEST+1
D47F- A5 9B            LDA LOWTR
D481- 88               DEY
D482- F1 9B            SBC (LOWTR),Y
D484- 18               CLC
D485- 65 69            ADC VARTAB
D487- 85 69            STA VARTAB
D489- 85 60            STA DEST
D48B- A5 6A            LDA VARTAB+1
D48D- 69 FF            ADC #$FF
D48F- 85 6A            STA VARTAB+1
D491- E5 9C            SBC LOWTR+1
D493- AA               TAX
D494- 38               SEC
D495- A5 9B            LDA LOWTR
D497- E5 69            SBC VARTAB
D499- A8               TAY
D49A- B0 03            BCS .1
D49C- E8               INX
D49D- C6 61            DEC DEST+1
D49F- 18        .1     CLC
D4A0- 65 5E            ADC INDEX
D4A2- 90 03            BCC .2
D4A4- C6 5F            DEC INDEX+1
D4A6- 18               CLC
                *--------------------------------
D4A7- B1 5E     .2     LDA (INDEX),Y     MOVE HIGHER LINES OF PROGRAM
D4A9- 91 60            STA (DEST),Y      DOWN OVER THE DELETED LINE.
D4AB- C8               INY
D4AC- D0 F9            BNE .2
D4AE- E6 5F            INC INDEX+1
D4B0- E6 61            INC DEST+1
D4B2- CA               DEX
D4B3- D0 F2            BNE .2
                *--------------------------------
                <b><a name="PUT.NEW.LINE" id="PUT.NEW.LINE">PUT.NEW.LINE</a></b>
D4B5- AD 00 02         LDA INPUT.BUFFER  ANY CHARACTERS AFTER LINE #?
D4B8- F0 38            BEQ <a href="#FIX.LINKS">FIX.LINKS</a>     NO, SO NOTHING TO INSERT.
D4BA- A5 73            LDA MEMSIZ       YES, SO MAKE ROOM AND INSERT LINE
D4BC- A4 74            LDY MEMSIZ+1     WIPE STRING AREA CLEAN
D4BE- 85 6F            STA FRETOP
D4C0- 84 70            STY FRETOP+1
D4C2- A5 69            LDA VARTAB        SET UP BLTU SUBROUTINE
D4C4- 85 96            STA HIGHTR        INSERT NEW LINE.
D4C6- 65 0F            ADC EOL.PNTR
D4C8- 85 94            STA HIGHDS
D4CA- A4 6A            LDY VARTAB+1
D4CC- 84 97            STY HIGHTR+1
D4CE- 90 01            BCC .1
D4D0- C8               INY
D4D1- 84 95     .1     STY HIGHDS+1
D4D3- 20 93 D3         JSR <a href="#BLTU">BLTU</a>     MAKE ROOM FOR THE LINE
D4D6- A5 50            LDA LINNUM   PUT LINE NUMBER IN LINE IMAGE
D4D8- A4 51            LDY LINNUM+1
D4DA- 8D FE 01         STA INPUT.BUFFER-2
D4DD- 8C FF 01         STY INPUT.BUFFER-1
D4E0- A5 6D            LDA STREND
D4E2- A4 6E            LDY STREND+1
D4E4- 85 69            STA VARTAB
D4E6- 84 6A            STY VARTAB+1
D4E8- A4 0F            LDY EOL.PNTR
                *---COPY LINE INTO PROGRAM-------
D4EA- B9 FB 01  .2     LDA INPUT.BUFFER-5,Y
D4ED- 88               DEY
D4EE- 91 9B            STA (LOWTR),Y
D4F0- D0 F8            BNE .2
                *--------------------------------
                *      CLEAR ALL VARIABLES
                *      RE-ESTABLISH ALL FORWARD LINKS
                *--------------------------------
                <b><a name="FIX.LINKS" id="FIX.LINKS">FIX.LINKS</a></b>
D4F2- 20 65 D6         JSR <a href="#SETPTRS">SETPTRS</a>  CLEAR ALL VARIABLES
D4F5- A5 67            LDA TXTTAB   POINT INDEX AT START OF PROGRAM
D4F7- A4 68            LDY TXTTAB+1
D4F9- 85 5E            STA INDEX
D4FB- 84 5F            STY INDEX+1
D4FD- 18               CLC
D4FE- A0 01     .1     LDY #1            HI-BYTE OF NEXT FORWARD PNTR
D500- B1 5E            LDA (INDEX),Y     END OF PROGRAM YET?
D502- D0 0B            BNE .2            NO, KEEP GOING
D504- A5 69            LDA VARTAB        YES
D506- 85 AF            STA PRGEND
D508- A5 6A            LDA VARTAB+1
D50A- 85 B0            STA PRGEND+1
D50C- 4C 3C D4         JMP <a href="#RESTART">RESTART</a>
D50F- A0 04     .2     LDY #4       FIND END OF THIS LINE
D511- C8        .3     INY          (NOTE MAXIMUM LENGTH &lt; 256)
D512- B1 5E            LDA (INDEX),Y
D514- D0 FB            BNE .3
D516- C8               INY          COMPUTE ADDRESS OF NEXT LINE
D517- 98               TYA
D518- 65 5E            ADC INDEX
D51A- AA               TAX
D51B- A0 00            LDY #0       STORE FORWARD PNTR IN THIS LINE
D51D- 91 5E            STA (INDEX),Y
D51F- A5 5F            LDA INDEX+1
D521- 69 00            ADC #0       (NOTE: THIS CLEARS CARRY)
D523- C8               INY
D524- 91 5E            STA (INDEX),Y
D526- 86 5E            STX INDEX
D528- 85 5F            STA INDEX+1
D52A- 90 D2            BCC .1       ...ALWAYS
                *--------------------------------
                *--------------------------------
                *      READ A LINE, AND STRIP OFF SIGN BITS
                *--------------------------------
D52C- A2 80     <b><a name="INLIN" id="INLIN">INLIN</a></b>  LDX #$80     NULL PROMPT
D52E- 86 33     <b><a name="INLIN2" id="INLIN2">INLIN2</a></b> STX MON.PROMPT
D530- 20 6A FD         JSR <a href="#MON.GETLN">MON.GETLN</a>
D533- E0 EF            CPX #239     MAXIMUM LINE LENGTH
D535- 90 02            BCC .1
D537- A2 EF            LDX #239     TRUNCATE AT 239 CHARS
D539- A9 00     .1     LDA #0       MARK END OF LINE WITH $00 BYTE
D53B- 9D 00 02         STA INPUT.BUFFER,X
D53E- 8A               TXA
D53F- F0 0B            BEQ .3       NULL INPUT LINE
D541- BD FF 01  .2     LDA INPUT.BUFFER-1,X   DROP SIGN BITS
D544- 29 7F            AND #$7F
D546- 9D FF 01         STA INPUT.BUFFER-1,X
D549- CA               DEX
D54A- D0 F5            BNE .2
D54C- A9 00     .3     LDA #0       (Y,X) POINTS AT BUFFER-1
D54E- A2 FF            LDX #INPUT.BUFFER-1
D550- A0 01            LDY /INPUT.BUFFER-1
D552- 60               RTS
                *--------------------------------
D553- 20 0C FD  <b><a name="INCHR" id="INCHR">INCHR</a></b>  JSR <a href="#MON.RDKEY">MON.RDKEY</a>    *** OUGHT TO BE "BIT $C010" ***
D556- 29 7F            AND #$7F
D558- 60               RTS
                *--------------------------------
                *      TOKENIZE THE INPUT LINE
                *--------------------------------
                <b><a name="PARSE.INPUT.LINE" id="PARSE.INPUT.LINE">PARSE.INPUT.LINE</a></b>
D559- A6 B8            LDX TXTPTR   INDEX INTO UNPARSED LINE
D55B- CA               DEX          PREPARE FOR INX AT "PARSE"
D55C- A0 04            LDY #4       INDEX TO PARSED OUTPUT LINE
D55E- 84 13            STY DATAFLG  CLEAR SIGN-BIT OF DATAFLG
D560- 24 D6            BIT <a href="#LOCK">LOCK</a>     IS THIS PROGRAM LOCKED?
D562- 10 08            BPL <a href="#PARSE">PARSE</a>    NO, GO AHEAD AND PARSE THE LINE
D564- 68               PLA          YES, IGNORE INPUT AND "RUN"
D565- 68               PLA             THE PROGRAM
D566- 20 65 D6         JSR <a href="#SETPTRS">SETPTRS</a>  CLEAR ALL VARIABLES
D569- 4C D2 D7         JMP <a href="#NEWSTT">NEWSTT</a>   START RUNNING
                *--------------------------------
D56C- E8        <b><a name="PARSE" id="PARSE">PARSE</a></b>  INX          NEXT INPUT CHARACTER
D56D- BD 00 02  .1     LDA INPUT.BUFFER,X
D570- 24 13            BIT <a href="#DATAFLG">DATAFLG</a>       IN A "DATA" STATEMENT?
D572- 70 04            BVS .2            YES (DATAFLG = $49)
D574- C9 20            CMP #' '     IGNORE BLANKS
D576- F0 F4            BEQ <a href="#PARSE">PARSE</a>
D578- 85 0E     .2     STA ENDCHR
D57A- C9 22            CMP #'"      START OF QUOTATION?
D57C- F0 74            BEQ .13
D57E- 70 4D            BVS .9       BRANCH IF IN "DATA" STATEMENT
D580- C9 3F            CMP #'?      SHORTHAND FOR "PRINT"?
D582- D0 04            BNE .3       NO
D584- A9 BA            LDA #TOKEN.PRINT  YES, REPLACE WITH "PRINT" TOKEN
D586- D0 45            BNE .9       ...ALWAYS
D588- C9 30     .3     CMP #'0      IS IT A DIGIT, COLON, OR SEMI-COLON?
D58A- 90 04            BCC .4       NO, PUNCTUATION !"#$%&amp;'()*+,-./
D58C- C9 3C            CMP #';'+1
D58E- 90 3D            BCC .9       YES, NOT A TOKEN
                *--------------------------------
                *      SEARCH TOKEN NAME TABLE FOR MATCH STARTING
                *      WITH CURRENT CHAR FROM INPUT LINE
                *--------------------------------
D590- 84 AD     .4     STY STRNG2   SAVE INDEX TO OUTPUT LINE
D592- A9 D0            LDA #TOKEN.NAME.TABLE-$100
D594- 85 9D            STA FAC      MAKE PNTR FOR SEARCH
D596- A9 CF            LDA /TOKEN.NAME.TABLE-$100
D598- 85 9E            STA FAC+1
D59A- A0 00            LDY #0       USE Y-REG WITH (FAC) TO ADDRESS TABLE
D59C- 84 0F            STY TKN.CNTR     HOLDS CURRENT TOKEN-$80
D59E- 88               DEY          PREPARE FOR "INY" A FEW LINES DOWN
D59F- 86 B8            STX TXTPTR   SAVE POSITION IN INPUT LINE
D5A1- CA               DEX          PREPARE FOR "INX" A FEW LINES DOWN
D5A2- C8        .5     INY          ADVANCE POINTER TO TOKEN TABLE
D5A3- D0 02            BNE .6       Y=Y+1 IS ENOUGH
D5A5- E6 9E            INC FAC+1    ALSO NEED TO BUMP THE PAGE
D5A7- E8        .6     INX          ADVANCE POINTER TO INPUT LINE
D5A8- BD 00 02  .7     LDA INPUT.BUFFER,X   NEXT CHAR FROM INPUT LINE
D5AB- C9 20            CMP #' '     THIS CHAR A BLANK?
D5AD- F0 F8            BEQ .6       YES, IGNORE ALL BLANKS
D5AF- 38               SEC          NO, COMPARE TO CHAR IN TABLE
D5B0- F1 9D            SBC (FAC),Y  SAME AS NEXT CHAR OF TOKEN NAME?
D5B2- F0 EE            BEQ .5       YES, CONTINUE MATCHING
D5B4- C9 80            CMP #$80     MAYBE; WAS IT SAME EXCEPT FOR BIT 7?
D5B6- D0 41            BNE .14      NO, SKIP TO NEXT TOKEN
D5B8- 05 0F            ORA TKN.CNTR     YES, END OF TOKEN; GET TOKEN #
D5BA- C9 C5            CMP #TOKEN.AT  DID WE MATCH "AT"?
D5BC- D0 0D            BNE .8       NO, SO NO AMBIGUITY
D5BE- BD 01 02         LDA INPUT.BUFFER+1,X  "AT" COULD BE "ATN" OR "A TO"
D5C1- C9 4E            CMP #'N      "ATN" HAS PRECEDENCE OVER "AT"
D5C3- F0 34            BEQ .14      IT IS "ATN", FIND IT THE HARD WAY
D5C5- C9 4F            CMP #'O      "TO" HAS PRECEDENCE OVER "AT"
D5C7- F0 30            BEQ .14      IT IS "A TO", FIN IT THE HARD WAY
D5C9- A9 C5            LDA #TOKEN.AT     NOT "ATN" OR "A TO", SO USE "AT"
                *--------------------------------
                *      STORE CHARACTER OR TOKEN IN OUTPUT LINE
                *--------------------------------
D5CB- A4 AD     .8     LDY STRNG2   GET INDEX TO OUTPUT LINE IN Y-REG
D5CD- E8        .9     INX          ADVANCE INPUT INDEX
D5CE- C8               INY          ADVANCE OUTPUT INDEX
D5CF- 99 FB 01         STA INPUT.BUFFER-5,Y   STORE CHAR OR TOKEN
D5D2- B9 FB 01         LDA INPUT.BUFFER-5,Y   TEST FOR EOL OR EOS
D5D5- F0 39            BEQ .17      END OF LINE
D5D7- 38               SEC
D5D8- E9 3A            SBC #':      END OF STATEMENT?
D5DA- F0 04            BEQ .10      YES, CLEAR DATAFLG
D5DC- C9 49            CMP #TOKEN.DATA-':'   "DATA" TOKEN?
D5DE- D0 02            BNE .11      NO, LEAVE DATAFLG ALONE
D5E0- 85 13     .10    STA DATAFLG  DATAFLG = 0 OR $83-$3A = $49
D5E2- 38        .11    SEC          IS IT A "REM" TOKEN?
D5E3- E9 78            SBC #TOKEN.REM-':'
D5E5- D0 86            BNE .1       NO, CONTINUE PARSING LINE
D5E7- 85 0E            STA ENDCHR   YES, CLEAR LITERAL FLAG
                *--------------------------------
                *      HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
                *      BY COPYING CHARS UP TO ENDCHR.
                *--------------------------------
D5E9- BD 00 02  .12    LDA INPUT.BUFFER,X
D5EC- F0 DF            BEQ .9       END OF LINE
D5EE- C5 0E            CMP ENDCHR
D5F0- F0 DB            BEQ .9       FOUND ENDCHR
D5F2- C8        .13    INY          NEXT OUTPUT CHAR
D5F3- 99 FB 01         STA INPUT.BUFFER-5,Y
D5F6- E8               INX          NEXT INPUT CHAR
D5F7- D0 F0            BNE .12      ...ALWAYS
                *--------------------------------
                *      ADVANCE POINTER TO NEXT TOKEN NAME
                *--------------------------------
D5F9- A6 B8     .14    LDX TXTPTR   GET POINTER TO INPUT LINE IN X-REG
D5FB- E6 0F            INC TKN.CNTR     BUMP (TOKEN # - $80)
D5FD- B1 9D     .15    LDA (FAC),Y  SCAN THROUGH TABLE FOR BIT7 = 1
D5FF- C8               INY          NEXT TOKEN ONE BEYOND THAT
D600- D0 02            BNE .16      ...USUALLY ENOUGH TO BUMP Y-REG
D602- E6 9E            INC FAC+1    NEXT SET OF 256 TOKEN CHARS
D604- 0A        .16    ASL          SEE IF SIGN BIT SET ON CHAR
D605- 90 F6            BCC .15      NO, MORE IN THIS NAME
D607- B1 9D            LDA (FAC),Y  YES, AT NEXT NAME.  END OF TABLE?
D609- D0 9D            BNE .7       NO, NOT END OF TABLE
D60B- BD 00 02         LDA INPUT.BUFFER,X   YES, SO NOT A KEYWORD
D60E- 10 BB            BPL .8       ...ALWAYS, COPY CHAR AS IS
                *---END OF LINE------------------
D610- 99 FD 01  .17    STA INPUT.BUFFER-3,Y   STORE ANOTHER 00 ON END
D613- C6 B9            DEC TXTPTR+1      SET TXTPTR = INPUT.BUFFER-1
D615- A9 FF            LDA #INPUT.BUFFER-1
D617- 85 B8            STA TXTPTR
D619- 60               RTS
                *--------------------------------
                *      SEARCH FOR LINE
                *
                *      (LINNUM) = LINE # TO FIND
                *      IF NOT FOUND:  CARRY = 0
                *                     LOWTR POINTS AT NEXT LINE
                *      IF FOUND:      CARRY = 1
                *                     LOWTR POINTS AT LINE
                *--------------------------------
D61A- A5 67     <b><a name="FNDLIN" id="FNDLIN">FNDLIN</a></b> LDA TXTTAB   SEARCH FROM BEGINNING OF PROGRAM
D61C- A6 68            LDX TXTTAB+1
D61E- A0 01     <b><a name="FL1" id="FL1">FL1</a></b>    LDY #1       SEARCH FROM (X,A)
D620- 85 9B            STA LOWTR
D622- 86 9C            STX LOWTR+1
D624- B1 9B            LDA (LOWTR),Y
D626- F0 1F            BEQ .3       END OF PROGRAM, AND NOT FOUND
D628- C8               INY
D629- C8               INY
D62A- A5 51            LDA LINNUM+1
D62C- D1 9B            CMP (LOWTR),Y
D62E- 90 18            BCC <a href="#RTS.1">RTS.1</a>    IF NOT FOUND
D630- F0 03            BEQ .1
D632- 88               DEY
D633- D0 09            BNE .2
D635- A5 50     .1     LDA LINNUM
D637- 88               DEY
D638- D1 9B            CMP (LOWTR),Y
D63A- 90 0C            BCC <a href="#RTS.1">RTS.1</a>    PAST LINE, NOT FOUND
D63C- F0 0A            BEQ <a href="#RTS.1">RTS.1</a>    IF FOUND
D63E- 88        .2     DEY
D63F- B1 9B            LDA (LOWTR),Y
D641- AA               TAX
D642- 88               DEY
D643- B1 9B            LDA (LOWTR),Y
D645- B0 D7            BCS <a href="#FL1">FL1</a>      ALWAYS
D647- 18        .3     CLC          RETURN CARRY = 0
D648- 60        <b><a name="RTS.1" id="RTS.1">RTS.1</a></b>  RTS
                *--------------------------------
                *      "NEW" STATEMENT
                *--------------------------------
D649- D0 FD     <b><a name="NEW" id="NEW">NEW</a></b>    BNE <a href="#RTS.1">RTS.1</a>    IGNORE IF MORE TO THE STATEMENT
D64B- A9 00     <b><a name="SCRTCH" id="SCRTCH">SCRTCH</a></b> LDA #0
D64D- 85 D6            STA LOCK
D64F- A8               TAY
D650- 91 67            STA (TXTTAB),Y
D652- C8               INY
D653- 91 67            STA (TXTTAB),Y
D655- A5 67            LDA TXTTAB
D657- 69 02            ADC #2      (CARRY WASN'T CLEARED, SO "NEW" USUALLY
D659- 85 69            STA VARTAB    ADDS 3, WHEREAS "FP" ADDS 2.)
D65B- 85 AF            STA PRGEND
D65D- A5 68            LDA TXTTAB+1
D65F- 69 00            ADC #0
D661- 85 6A            STA VARTAB+1
D663- 85 B0            STA PRGEND+1
                *--------------------------------
                <b><a name="SETPTRS" id="SETPTRS">SETPTRS</a></b>
D665- 20 97 D6         JSR <a href="#STXTPT">STXTPT</a>   SET TXTPTR TO TXTTAB - 1
D668- A9 00            LDA #0       (THIS COULD HAVE BEEN ".HS 2C")
                *--------------------------------
                *      "CLEAR" STATEMENT
                *--------------------------------
D66A- D0 2A     <b><a name="CLEAR" id="CLEAR">CLEAR</a></b>  BNE <a href="#RTS.2">RTS.2</a>    IGNORE IF NOT AT END OF STATEMENT
D66C- A5 73     <b><a name="CLEARC" id="CLEARC">CLEARC</a></b> LDA MEMSIZ   CLEAR STRING AREA
D66E- A4 74            LDY MEMSIZ+1
D670- 85 6F            STA FRETOP
D672- 84 70            STY FRETOP+1
D674- A5 69            LDA VARTAB   CLEAR ARRAY AREA
D676- A4 6A            LDY VARTAB+1
D678- 85 6B            STA ARYTAB
D67A- 84 6C            STY ARYTAB+1
D67C- 85 6D            STA STREND   LOW END OF FREE SPACE
D67E- 84 6E            STY STREND+1
D680- 20 49 D8         JSR <a href="#RESTORE">RESTORE</a>  SET "DATA" POINTER TO BEGINNING
                *--------------------------------
D683- A2 55     <b><a name="STKINI" id="STKINI">STKINI</a></b> LDX #TEMPST
D685- 86 52            STX TEMPPT
D687- 68               PLA          SAVE RETURN ADDRESS
D688- A8               TAY
D689- 68               PLA
D68A- A2 F8            LDX #$F8     START STACK AT $F8,
D68C- 9A               TXS            LEAVING ROOM FOR PARSING LINES
D68D- 48               PHA          RESTORE RETURN ADDRESS
D68E- 98               TYA
D68F- 48               PHA
D690- A9 00            LDA #0
D692- 85 7A            STA OLDTEXT+1
D694- 85 14            STA SUBFLG
D696- 60        <b><a name="RTS.2" id="RTS.2">RTS.2</a></b>  RTS
                *--------------------------------
                *      SET TXTPTR TO BEGINNING OF PROGRAM
                *--------------------------------
D697- 18        <b><a name="STXTPT" id="STXTPT">STXTPT</a></b> CLC          TXTPTR = TXTTAB - 1
D698- A5 67            LDA TXTTAB
D69A- 69 FF            ADC #$FF
D69C- 85 B8            STA TXTPTR
D69E- A5 68            LDA TXTTAB+1
D6A0- 69 FF            ADC #$FF
D6A2- 85 B9            STA TXTPTR+1
D6A4- 60               RTS
                *--------------------------------
                *      "LIST" STATEMENT
                *--------------------------------
D6A5- 90 0A     <b><a name="LIST" id="LIST">LIST</a></b>   BCC .1       NO  LINE # SPECIFIED
D6A7- F0 08            BEQ .1       ---DITTO---
D6A9- C9 C9            CMP #TOKEN.MINUS  IF DASH OR COMMA, START AT LINE 0
D6AB- F0 04            BEQ .1            IS IS A DASH
D6AD- C9 2C            CMP #',           COMMA?
D6AF- D0 E5            BNE <a href="#RTS.2">RTS.2</a>         NO, ERROR
D6B1- 20 0C DA  .1     JSR <a href="#LINGET">LINGET</a>   CONVERT LINE NUMBER IF ANY
D6B4- 20 1A D6         JSR <a href="#FNDLIN">FNDLIN</a>   POINT LOWTR TO 1ST LINE
D6B7- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   RANGE SPECIFIED?
D6BA- F0 10            BEQ .3       NO
D6BC- C9 C9            CMP #TOKEN.MINUS
D6BE- F0 04            BEQ .2
D6C0- C9 2C            CMP #',
D6C2- D0 84            BNE <a href="#RTS.1">RTS.1</a>
D6C4- 20 B1 00  .2     JSR <a href="#CHRGET">CHRGET</a>   GET NEXT CHAR
D6C7- 20 0C DA         JSR <a href="#LINGET">LINGET</a>   CONVERT SECOND LINE #
D6CA- D0 CA            BNE <a href="#RTS.2">RTS.2</a>    BRANCH IF SYNTAX ERR
D6CC- 68        .3     PLA          POP RETURN ADRESS
D6CD- 68               PLA          (GET BACK BY "JMP NEWSTT")
D6CE- A5 50            LDA LINNUM   IF NO SECOND NUMBER, USE $FFFF
D6D0- 05 51            ORA LINNUM+1
D6D2- D0 06            BNE <a href="#LIST.0">LIST.0</a>       THERE WAS A SECOND NUMBER
D6D4- A9 FF            LDA #$FF     MAX END RANGE
D6D6- 85 50            STA LINNUM
D6D8- 85 51            STA LINNUM+1
D6DA- A0 01     <b><a name="LIST.0" id="LIST.0">LIST.0</a></b> LDY #1
D6DC- B1 9B            LDA (LOWTR),Y  HIGH BYTE OF LINK
D6DE- F0 44            BEQ <a href="#LIST.3">LIST.3</a>   END OF PROGRAM
D6E0- 20 58 D8         JSR <a href="#ISCNTC">ISCNTC</a>   CHECK IF CONTROL-C HAS BEEN TYPED
D6E3- 20 FB DA         JSR <a href="#CRDO">CRDO</a>     NO, PRINT &lt;RETURN&gt;
D6E6- C8               INY
D6E7- B1 9B            LDA (LOWTR),Y  GET LINE #, COMPARE WITH END RANGE
D6E9- AA               TAX
D6EA- C8               INY
D6EB- B1 9B            LDA (LOWTR),Y
D6ED- C5 51            CMP LINNUM+1
D6EF- D0 04            BNE .5
D6F1- E4 50            CPX LINNUM
D6F3- F0 02            BEQ .6       ON LAST LINE OF RANGE
D6F5- B0 2D     .5     BCS <a href="#LIST.3">LIST.3</a>   FINISHED THE RANGE
                *---LIST ONE LINE----------------
D6F7- 84 85     .6     STY FORPNT
D6F9- 20 24 ED         JSR <a href="#LINPRT">LINPRT</a>   PRINT LINE # FROM X,A
D6FC- A9 20            LDA #' '     PRINT SPACE AFTER LINE #
D6FE- A4 85     <b><a name="LIST.1" id="LIST.1">LIST.1</a></b> LDY FORPNT
D700- 29 7F            AND #$7F
D702- 20 5C DB  <b><a name="LIST.2" id="LIST.2">LIST.2</a></b> JSR <a href="#OUTDO">OUTDO</a>
D705- A5 24            LDA MON.CH   IF PAST COLUMN 33, START A NEW LINE
D707- C9 21            CMP #33
D709- 90 07            BCC .1       &lt; 33
D70B- 20 FB DA         JSR <a href="#CRDO">CRDO</a>     PRINT &lt;RETURN&gt;
D70E- A9 05            LDA #5        AND TAB OVER 5
D710- 85 24            STA MON.CH
D712- C8        .1     INY
D713- B1 9B            LDA (LOWTR),Y
D715- D0 1D            BNE <a href="#LIST.4">LIST.4</a>   NOT END OF LINE YET
D717- A8               TAY          END OF LINE
D718- B1 9B            LDA (LOWTR),Y     GET LINK TO NEXT LINE
D71A- AA               TAX
D71B- C8               INY
D71C- B1 9B            LDA (LOWTR),Y
D71E- 86 9B            STX LOWTR    POINT TO NEXT LINE
D720- 85 9C            STA LOWTR+1
D722- D0 B6            BNE <a href="#LIST.0">LIST.0</a>       BRANCH IF NOT END OF PROGRAM
D724- A9 0D     <b><a name="LIST.3" id="LIST.3">LIST.3</a></b> LDA #$0D     PRINT &lt;RETURN&gt;
D726- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>
D729- 4C D2 D7         JMP <a href="#NEWSTT">NEWSTT</a>   TO NEXT STATEMENT
                *--------------------------------
D72C- C8        <b><a name="GETCHR" id="GETCHR">GETCHR</a></b> INY          PICK UP CHAR FROM TABLE
D72D- D0 02            BNE .1
D72F- E6 9E            INC FAC+1
D731- B1 9D     .1     LDA (FAC),Y
D733- 60               RTS
                *--------------------------------
D734- 10 CC     <b><a name="LIST.4" id="LIST.4">LIST.4</a></b> BPL <a href="#LIST.2">LIST.2</a>   BRANCH IF NOT A TOKEN
D736- 38               SEC
D737- E9 7F            SBC #$7F     CONVERT TOKEN TO INDEX
D739- AA               TAX
D73A- 84 85            STY FORPNT   SAVE LINE POINTER
D73C- A0 D0            LDY #TOKEN.NAME.TABLE-$100
D73E- 84 9D            STY FAC      POINT FAC TO TABLE
D740- A0 CF            LDY /TOKEN.NAME.TABLE-$100
D742- 84 9E            STY FAC+1
D744- A0 FF            LDY #-1
D746- CA        .1     DEX          SKIP KEYWORDS UNTIL REACH THIS ONE
D747- F0 07            BEQ .3
D749- 20 2C D7  .2     JSR <a href="#GETCHR">GETCHR</a>   BUMP Y, GET CHAR FROM TABLE
D74C- 10 FB            BPL .2       NOT AT END OF KEYWORD YET
D74E- 30 F6            BMI .1       END OF KEYWORD, ALWAYS BRANCHES
D750- A9 20     .3     LDA #' '     FOUND THE RIGHT KEYWORD
D752- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>    PRINT LEADING SPACE
D755- 20 2C D7  .4     JSR <a href="#GETCHR">GETCHR</a>   PRINT THE KEYWORD
D758- 30 05            BMI .5       LAST CHAR OF KEYWORD
D75A- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>
D75D- D0 F6            BNE .4       ...ALWAYS
D75F- 20 5C DB  .5     JSR <a href="#OUTDO">OUTDO</a>    PRINT LAST CHAR OF KEYWORD
D762- A9 20            LDA #' '     PRINT TRAILING SPACE
D764- D0 98            BNE <a href="#LIST.1">LIST.1</a>   ...ALWAYS, BACK TO ACTUAL LINE
            1010 *--------------------------------
                *      "FOR" STATEMENT
                *
                *    FOR PUSHES 18 BYTES ON THE STACK:
                *    2 -- TXTPTR
                *    2 -- LINE NUMBER
                *    5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
                *    1 -- STEP SIGN
                *    5 -- STEP VALUE
                *    2 -- ADDRESS OF FOR VARIABLE IN VARTAB
                *    1 -- FOR TOKEN ($81)
                *--------------------------------
D766- A9 80     <b><a name="FOR" id="FOR">FOR</a></b>    LDA #$80
D768- 85 14            STA SUBFLG   SUBSCRIPTS NOT ALLOWED
D76A- 20 46 DA         JSR <a href="#LET">LET</a>      DO &lt;VAR&gt; = &lt;EXP&gt;, STORE ADDR IN FORPNT
D76D- 20 65 D3         JSR <a href="#GTFORPNT">GTFORPNT</a>  IS THIS FOR VARIABLE ACTIVE?
D770- D0 05            BNE .1       NO
D772- 8A               TXA          YES, CANCEL IT AND ENCLOSED LOOPS
D773- 69 0F            ADC #15      CARRY=1, THIS ADDS 16
D775- AA               TAX          X WAS ALREADY S+2
D776- 9A               TXS
D777- 68        .1     PLA          POP RETURN ADDRESS TOO
D778- 68               PLA
D779- A9 09            LDA #9       BE CERTAIN ENOUGH ROOM IN STACK
D77B- 20 D6 D3         JSR <a href="#CHKMEM">CHKMEM</a>
D77E- 20 A3 D9         JSR <a href="#DATAN">DATAN</a>    SCAN AHEAD TO NEXT STATEMENT
D781- 18               CLC          PUSH STATEMENT ADDRESS ON STACK
D782- 98               TYA
D783- 65 B8            ADC TXTPTR
D785- 48               PHA
D786- A5 B9            LDA TXTPTR+1
D788- 69 00            ADC #0
D78A- 48               PHA
D78B- A5 76            LDA CURLIN+1 PUSH LINE NUMBER ON STACK
D78D- 48               PHA
D78E- A5 75            LDA CURLIN
D790- 48               PHA
D791- A9 C1            LDA #TOKEN.TO
D793- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>   REQUIRE "TO"
D796- 20 6A DD         JSR <a href="#CHKNUM">CHKNUM</a>   &lt;VAR&gt; = &lt;EXP&gt; MUST BE NUMERIC
D799- 20 67 DD         JSR <a href="#FRMNUM">FRMNUM</a>   GET FINAL VALUE, MUST BE NUMERIC
D79C- A5 A2            LDA FAC.SIGN   PUT SIGN INTO VALUE IN FAC
D79E- 09 7F            ORA #$7F
D7A0- 25 9E            AND FAC+1
D7A2- 85 9E            STA FAC+1
D7A4- A9 AF            LDA #STEP    SET UP FOR RETURN
D7A6- A0 D7            LDY /STEP     TO STEP
D7A8- 85 5E            STA INDEX
D7AA- 84 5F            STY INDEX+1
D7AC- 4C 20 DE         JMP <a href="#FRM.STACK.3">FRM.STACK.3</a>  RETURNS BY "JMP (INDEX)"
                *--------------------------------
                *      "STEP" PHRASE OF "FOR" STATEMENT
                *--------------------------------
D7AF- A9 13     <b><a name="STEP" id="STEP">STEP</a></b>   LDA #CON.ONE     STEP DEFAULT=1
D7B1- A0 E9            LDY /CON.ONE
D7B3- 20 F9 EA         JSR <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>
D7B6- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>
D7B9- C9 C7            CMP #TOKEN.STEP
D7BB- D0 06            BNE .1       USE DEFAULT VALUE OF 1.0
D7BD- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   STEP SPECIFIED, GET IT
D7C0- 20 67 DD         JSR <a href="#FRMNUM">FRMNUM</a>
D7C3- 20 82 EB  .1     JSR <a href="#SIGN">SIGN</a>
D7C6- 20 15 DE         JSR <a href="#FRM.STACK.2">FRM.STACK.2</a>
D7C9- A5 86            LDA FORPNT+1
D7CB- 48               PHA
D7CC- A5 85            LDA FORPNT
D7CE- 48               PHA
D7CF- A9 81            LDA #TOKEN.FOR
D7D1- 48               PHA
                *--------------------------------
                *      PERFORM NEXT STATEMENT
                *--------------------------------
D7D2- BA        <b><a name="NEWSTT" id="NEWSTT">NEWSTT</a></b> TSX          REMEMBER THE STACK POSITION
D7D3- 86 F8            STX REMSTK
D7D5- 20 58 D8         JSR <a href="#ISCNTC">ISCNTC</a>   SEE IF CONTROL-C HAS BEEN TYPED
D7D8- A5 B8            LDA TXTPTR   NO, KEEP EXECUTING
D7DA- A4 B9            LDY TXTPTR+1
D7DC- A6 76            LDX CURLIN+1     =$FF IF IN DIRECT MODE
D7DE- E8               INX               $FF TURNS INTO $00
D7DF- F0 04            BEQ .1            IN DIRECT MODE
D7E1- 85 79            STA OLDTEXT      IN RUNNING MODE
D7E3- 84 7A            STY OLDTEXT+1
D7E5- A0 00     .1     LDY #0
D7E7- B1 B8            LDA (TXTPTR),Y    END OF LINE YET?
D7E9- D0 57            BNE <a href="#COLON.">COLON.</a>        NO
D7EB- A0 02            LDY #2            YES, SEE IF END OF PROGRAM
D7ED- B1 B8            LDA (TXTPTR),Y
D7EF- 18               CLC
D7F0- F0 34            BEQ <a href="#GOEND">GOEND</a>         YES, END OF PROGRAM
D7F2- C8               INY
D7F3- B1 B8            LDA (TXTPTR),Y    GET LINE # OF NEXT LINE
D7F5- 85 75            STA CURLIN
D7F7- C8               INY
D7F8- B1 B8            LDA (TXTPTR),Y
D7FA- 85 76            STA CURLIN+1
D7FC- 98               TYA               ADJUST TXTPTR TO START
D7FD- 65 B8            ADC TXTPTR        OF NEW LINE
D7FF- 85 B8            STA TXTPTR
D801- 90 02            BCC .2
D803- E6 B9            INC TXTPTR+1
                .2
                *--------------------------------
D805- 24 F2     <b><a name="TRACE." id="TRACE.">TRACE.</a></b> BIT <a href="#TRCFLG">TRCFLG</a>   IS TRACE ON?
D807- 10 14            BPL .1       NO
D809- A6 76            LDX CURLIN+1 YES, ARE WE RUNNING?
D80B- E8               INX
D80C- F0 0F            BEQ .1       NOT RUNNING, SO DON'T TRACE
D80E- A9 23            LDA #'#'     PRINT "#"
D810- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>
D813- A6 75            LDX CURLIN
D815- A5 76            LDA CURLIN+1
D817- 20 24 ED         JSR <a href="#LINPRT">LINPRT</a>   PRINT LINE NUMBER
D81A- 20 57 DB         JSR <a href="#OUTSP">OUTSP</a>    PRINT TRAILING SPACE
D81D- 20 B1 00  .1     JSR <a href="#CHRGET">CHRGET</a>   GET FIRST CHR OF STATEMENT
D820- 20 28 D8         JSR <a href="#EXECUTE.STATEMENT">EXECUTE.STATEMENT</a>    AND START PROCESSING
D823- 4C D2 D7         JMP <a href="#NEWSTT">NEWSTT</a>   BACK FOR MORE
                *--------------------------------
D826- F0 62     <b><a name="GOEND" id="GOEND">GOEND</a></b>  BEQ <a href="#END4">END4</a>
                *--------------------------------
                *      EXECUTE A STATEMENT
                *
                *      (A) IS FIRST CHAR OF STATEMENT
                *      CARRY IS SET
                *--------------------------------
                <b><a name="EXECUTE.STATEMENT" id="EXECUTE.STATEMENT">EXECUTE.STATEMENT</a></b>
D828- F0 2D            BEQ <a href="#RTS.3">RTS.3</a>    END OF LINE, NULL STATEMENT
                <b><a name="EXECUTE.STATEMENT.1" id="EXECUTE.STATEMENT.1">EXECUTE.STATEMENT.1</a></b>
D82A- E9 80            SBC #$80     FIRST CHAR A TOKEN?
D82C- 90 11            BCC .1       NOT TOKEN, MUST BE "LET"
D82E- C9 40            CMP #$40     STATEMENT-TYPE TOKEN?
D830- B0 14            BCS <a href="#SYNERR.1">SYNERR.1</a> NO, SYNTAX ERROR
D832- 0A               ASL          DOUBLE TO GET INDEX
D833- A8               TAY          INTO ADDRESS TABLE
D834- B9 01 D0         LDA TOKEN.ADDRESS.TABLE+1,Y
D837- 48               PHA          PUT ADDRESS ON STACK
D838- B9 00 D0         LDA TOKEN.ADDRESS.TABLE,Y
D83B- 48               PHA
D83C- 4C B1 00         JMP <a href="#CHRGET">CHRGET</a>   GET NEXT CHR &amp; RTS TO ROUTINE
                *--------------------------------
D83F- 4C 46 DA  .1     JMP <a href="#LET">LET</a>      MUST BE &lt;VAR&gt; = &lt;EXP&gt;
                *--------------------------------
D842- C9 3A     <b><a name="COLON." id="COLON.">COLON.</a></b> CMP #':'
D844- F0 BF            BEQ <a href="#TRACE.">TRACE.</a>
D846- 4C C9 DE  <b><a name="SYNERR.1" id="SYNERR.1">SYNERR.1</a></b> JMP SYNERR
                *--------------------------------
                *      "RESTORE" STATEMENT
                *--------------------------------
                <b><a name="RESTORE" id="RESTORE">RESTORE</a></b>
D849- 38               SEC          SET DATPTR TO BEGINNING OF PROGRAM
D84A- A5 67            LDA TXTTAB
D84C- E9 01            SBC #1
D84E- A4 68            LDY TXTTAB+1
D850- B0 01            BCS <a href="#SETDA">SETDA</a>
D852- 88               DEY
                *---SET DATPTR TO Y,A------------
D853- 85 7D     <b><a name="SETDA" id="SETDA">SETDA</a></b>  STA DATPTR
D855- 84 7E            STY DATPTR+1
D857- 60        <b><a name="RTS.3" id="RTS.3">RTS.3</a></b>  RTS
                *--------------------------------
                *      SEE IF CONTROL-C TYPED
                *--------------------------------
D858- AD 00 C0  <b><a name="ISCNTC" id="ISCNTC">ISCNTC</a></b> LDA KEYBOARD
D85B- C9 83            CMP #$83
D85D- F0 01            BEQ .1
D85F- 60               RTS
D860- 20 53 D5  .1     JSR <a href="#INCHR">INCHR</a>    &lt;&lt;&lt; SHOULD BE "BIT $C010" &gt;&gt;&gt;
                <b><a name="CONTROL.C.TYPED" id="CONTROL.C.TYPED">CONTROL.C.TYPED</a></b>
D863- A2 FF            LDX #$FF     CONTROL C ATTEMPTED
D865- 24 D8            BIT <a href="#ERRFLG">ERRFLG</a>   "ON ERR" ENABLED?
D867- 10 03            BPL .2       NO
D869- 4C E9 F2         JMP <a href="#HANDLERR">HANDLERR</a> YES, RETURN ERR CODE = 255
D86C- C9 03     .2     CMP #3       SINCE IT IS CTRL-C, SET Z AND C BITS
                *--------------------------------
                *      "STOP" STATEMENT
                *--------------------------------
D86E- B0 01     <b><a name="STOP" id="STOP">STOP</a></b>   BCS <a href="#END2">END2</a>     CARRY=1 TO FORCE PRINTING "BREAK AT.."
                *--------------------------------
                *      "END" STATEMENT
                *--------------------------------
D870- 18        <b><a name="END" id="END">END</a></b>    CLC          CARRY=0 TO AVOID PRINTING MESSAGE
D871- D0 3C     <b><a name="END2" id="END2">END2</a></b>   BNE <a href="#RTS.4">RTS.4</a>    IF NOT END OF STATEMENT, DO NOTHING
D873- A5 B8            LDA TXTPTR
D875- A4 B9            LDY TXTPTR+1
D877- A6 76            LDX CURLIN+1
D879- E8               INX          RUNNING?
D87A- F0 0C            BEQ .1       NO, DIRECT MODE
D87C- 85 79            STA OLDTEXT
D87E- 84 7A            STY OLDTEXT+1
D880- A5 75            LDA CURLIN
D882- A4 76            LDY CURLIN+1
D884- 85 77            STA OLDLIN
D886- 84 78            STY OLDLIN+1
D888- 68        .1     PLA
D889- 68               PLA
D88A- A9 5D     <b><a name="END4" id="END4">END4</a></b>   LDA #QT.BREAK      " BREAK" AND BELL
D88C- A0 D3            LDY /QT.BREAK
D88E- 90 03            BCC .1
D890- 4C 31 D4         JMP <a href="#PRINT.ERROR.LINNUM">PRINT.ERROR.LINNUM</a>
D893- 4C 3C D4  .1     JMP <a href="#RESTART">RESTART</a>
                *--------------------------------
                *      "CONT" COMMAND
                *--------------------------------
D896- D0 17     <b><a name="CONT" id="CONT">CONT</a></b>   BNE <a href="#RTS.4">RTS.4</a>    IF NOT END OF STATEMENT, DO NOTHING
D898- A2 D2            LDX #ERR.CANTCONT
D89A- A4 7A            LDY OLDTEXT+1     MEANINGFUL RE-ENTRY?
D89C- D0 03            BNE .1            YES
D89E- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>         NO
D8A1- A5 79     .1     LDA OLDTEXT       RESTORE TXTPTR
D8A3- 85 B8            STA TXTPTR
D8A5- 84 B9            STY TXTPTR+1
D8A7- A5 77            LDA OLDLIN        RESTORE LINE NUMBER
D8A9- A4 78            LDY OLDLIN+1
D8AB- 85 75            STA CURLIN
D8AD- 84 76            STY CURLIN+1
D8AF- 60        <b><a name="RTS.4" id="RTS.4">RTS.4</a></b>  RTS
                *--------------------------------
                *      "SAVE" COMMAND
                *      WRITES PROGRAM ON CASSETTE TAPE
                *--------------------------------
D8B0- 38        <b><a name="SAVE" id="SAVE">SAVE</a></b>   SEC
D8B1- A5 AF            LDA PRGEND   COMPUTE PROGRAM LENGTH
D8B3- E5 67            SBC TXTTAB
D8B5- 85 50            STA LINNUM
D8B7- A5 B0            LDA PRGEND+1
D8B9- E5 68            SBC TXTTAB+1
D8BB- 85 51            STA LINNUM+1
D8BD- 20 F0 D8         JSR <a href="#VARTIO">VARTIO</a>   SET UP TO WRITE 3 BYTE HEADER
D8C0- 20 CD FE         JSR <a href="#MON.WRITE">MON.WRITE</a>     WRITE 'EM
D8C3- 20 01 D9         JSR <a href="#PROGIO">PROGIO</a>   SET UP TO WRITE THE PROGRAM
D8C6- 4C CD FE         JMP <a href="#MON.WRITE">MON.WRITE</a>     WRITE IT
                *--------------------------------
                *      "LOAD" COMMAND
                *      READS A PROGRAM FROM CASSETTE TAPE
                *--------------------------------
D8C9- 20 F0 D8  <b><a name="LOAD" id="LOAD">LOAD</a></b>   JSR <a href="#VARTIO">VARTIO</a>   SET UP TO READ 3 BYTE HEADER
D8CC- 20 FD FE         JSR <a href="#MON.READ">MON.READ</a>      READ LENGTH, LOCK BYTE
D8CF- 18               CLC
D8D0- A5 67            LDA TXTTAB   COMPUTE END ADDRESS
D8D2- 65 50            ADC LINNUM
D8D4- 85 69            STA VARTAB
D8D6- A5 68            LDA TXTTAB+1
D8D8- 65 51            ADC LINNUM+1
D8DA- 85 6A            STA VARTAB+1
D8DC- A5 52            LDA TEMPPT   LOCK BYTE
D8DE- 85 D6            STA LOCK
D8E0- 20 01 D9         JSR <a href="#PROGIO">PROGIO</a>   SET UP TO READ PROGRAM
D8E3- 20 FD FE         JSR <a href="#MON.READ">MON.READ</a> READ IT
D8E6- 24 D6            BIT <a href="#LOCK">LOCK</a>     IF LOCKED, START RUNNING NOW
D8E8- 10 03            BPL .1       NOT LOCKED
D8EA- 4C 65 D6         JMP <a href="#SETPTRS">SETPTRS</a>  LOCKED, START RUNNING
D8ED- 4C F2 D4  .1     JMP <a href="#FIX.LINKS">FIX.LINKS</a>  JUST FIX FORWARD POINTERS
                *--------------------------------
D8F0- A9 50     <b><a name="VARTIO" id="VARTIO">VARTIO</a></b> LDA #LINNUM  SET UP TO READ/WRITE 3 BYTE HEADER
D8F2- A0 00            LDY #0
D8F4- 85 3C            STA MON.A1L
D8F6- 84 3D            STY MON.A1H
D8F8- A9 52            LDA #TEMPPT
D8FA- 85 3E            STA MON.A2L
D8FC- 84 3F            STY MON.A2H
D8FE- 84 D6            STY LOCK
D900- 60               RTS
                *--------------------------------
D901- A5 67     <b><a name="PROGIO" id="PROGIO">PROGIO</a></b> LDA TXTTAB   SET UP TO READ/WRITE PROGRAM
D903- A4 68            LDY TXTTAB+1
D905- 85 3C            STA MON.A1L
D907- 84 3D            STY MON.A1H
D909- A5 69            LDA VARTAB
D90B- A4 6A            LDY VARTAB+1
D90D- 85 3E            STA MON.A2L
D90F- 84 3F            STY MON.A2H
D911- 60               RTS
                *--------------------------------
           1010 *--------------------------------
                *      "RUN" COMMAND
                *--------------------------------
D912- 08        <b><a name="RUN" id="RUN">RUN</a></b>    PHP          SAVE STATUS WHILE SUBTRACTING
D913- C6 76            DEC CURLIN+1 IF WAS $FF (MEANING DIRECT MODE)
                *                   MAKE IT "RUNNING MODE"
D915- 28               PLP          GET STATUS AGAIN (FROM CHRGET)
D916- D0 03            BNE .1       PROBABLY A LINE NUMBER
D918- 4C 65 D6         JMP <a href="#SETPTRS">SETPTRS</a>  START AT BEGINNING OF PROGRAM
D91B- 20 6C D6  .1     JSR <a href="#CLEARC">CLEARC</a>   CLEAR VARIABLES
D91E- 4C 35 D9         JMP <a href="#GO.TO.LINE">GO.TO.LINE</a>   JOIN GOSUB STATEMENT
                *--------------------------------
                *      "GOSUB" STATEMENT
                *
                *      LEAVES 7 BYTES ON STACK:
                *      2 -- RETURN ADDRESS (NEWSTT)
                *      2 -- TXTPTR
                *      2 -- LINE #
                *      1 -- GOSUB TOKEN ($B0)
                *--------------------------------
D921- A9 03     <b><a name="GOSUB" id="GOSUB">GOSUB</a></b>  LDA #3       BE SURE ENOUGH ROOM ON STACK
D923- 20 D6 D3         JSR <a href="#CHKMEM">CHKMEM</a>
D926- A5 B9            LDA TXTPTR+1
D928- 48               PHA
D929- A5 B8            LDA TXTPTR
D92B- 48               PHA
D92C- A5 76            LDA CURLIN+1
D92E- 48               PHA
D92F- A5 75            LDA CURLIN
D931- 48               PHA
D932- A9 B0            LDA #TOKEN.GOSUB
D934- 48               PHA
                <b><a name="GO.TO.LINE" id="GO.TO.LINE">GO.TO.LINE</a></b>
D935- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>
D938- 20 3E D9         JSR <a href="#GOTO">GOTO</a>
D93B- 4C D2 D7         JMP <a href="#NEWSTT">NEWSTT</a>
                *--------------------------------
                *      "GOTO" STATEMENT
                *      ALSO USED BY "RUN" AND "GOSUB"
                *--------------------------------
D93E- 20 0C DA  <b><a name="GOTO" id="GOTO">GOTO</a></b>   JSR <a href="#LINGET">LINGET</a>   GET GOTO LINE
D941- 20 A6 D9         JSR <a href="#REMN">REMN</a>     POINT Y TO EOL
D944- A5 76            LDA CURLIN+1  IS CURRENT PAGE &lt; GOTO PAGE?
D946- C5 51            CMP LINNUM+1
D948- B0 0B            BCS .1       SEARCH FROM PROG START IF NOT
D94A- 98               TYA          OTHERWISE SEARCH FROM NEXT LINE
D94B- 38               SEC
D94C- 65 B8            ADC TXTPTR
D94E- A6 B9            LDX TXTPTR+1
D950- 90 07            BCC .2
D952- E8               INX
D953- B0 04            BCS .2
D955- A5 67     .1     LDA TXTTAB   GET PROGRAM BEGINNING
D957- A6 68            LDX TXTTAB+1
D959- 20 1E D6  .2     JSR <a href="#FL1">FL1</a>      SEARCH FOR GOTO LINE
D95C- 90 1E            BCC <a href="#UNDERR">UNDERR</a>   ERROR IF NOT THERE
D95E- A5 9B            LDA LOWTR    TXTPTR = START OF THE DESTINATION LINE
D960- E9 01            SBC #1
D962- 85 B8            STA TXTPTR
D964- A5 9C            LDA LOWTR+1
D966- E9 00            SBC #0
D968- 85 B9            STA TXTPTR+1
D96A- 60        <b><a name="RTS.5" id="RTS.5">RTS.5</a></b>  RTS          RETURN TO NEWSTT OR GOSUB
                *--------------------------------
                *      "POP" AND "RETURN" STATEMENTS
                *--------------------------------
D96B- D0 FD     <b><a name="POP" id="POP">POP</a></b>    BNE <a href="#RTS.5">RTS.5</a>
D96D- A9 FF            LDA #$FF
D96F- 85 85            STA FORPNT   &lt;&lt;&lt; BUG: SHOULD BE FORPNT+1 &gt;&gt;&gt;
                *  &lt;&lt;&lt; SEE "ALL ABOUT APPLESOFT", PAGES 100,101 &gt;&gt;&gt;
D971- 20 65 D3         JSR <a href="#GTFORPNT">GTFORPNT</a>  TO CANCEL FOR/NEXT IN SUB
D974- 9A               TXS
D975- C9 B0            CMP #TOKEN.GOSUB  LAST GOSUB FOUND?
D977- F0 0B            BEQ <a href="#RETURN">RETURN</a>
D979- A2 16            LDX #ERR.NOGOSUB
D97B- 2C               .HS 2C       FAKE
D97C- A2 5A     <b><a name="UNDERR" id="UNDERR">UNDERR</a></b> LDX #ERR.UNDEFSTAT
D97E- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
D981- 4C C9 DE  <b><a name="SYNERR.2" id="SYNERR.2">SYNERR.2</a></b> JMP SYNERR
                *--------------------------------
D984- 68        <b><a name="RETURN" id="RETURN">RETURN</a></b> PLA          DISCARD GOSUB TOKEN
D985- 68               PLA          
D986- C0 42            CPY #TOKEN.POP*2
D988- F0 3B            BEQ <a href="#PULL3">PULL3</a>    BRANCH IF A POP
D98A- 85 75            STA CURLIN   PULL LINE #
D98C- 68               PLA
D98D- 85 76            STA CURLIN+1
D98F- 68               PLA
D990- 85 B8            STA TXTPTR   PULL TXTPTR
D992- 68               PLA
D993- 85 B9            STA TXTPTR+1
                *--------------------------------
                *      "DATA" STATEMENT
                *      EXECUTED BY SKIPPING TO NEXT COLON OR EOL
                *--------------------------------
D995- 20 A3 D9  <b><a name="DATA" id="DATA">DATA</a></b>   JSR <a href="#DATAN">DATAN</a>    MOVE TO NEXT STATEMENT
                *--------------------------------
                *      ADD (Y) TO TXTPTR
                *--------------------------------
D998- 98        <b><a name="ADDON" id="ADDON">ADDON</a></b>  TYA
D999- 18               CLC
D99A- 65 B8            ADC TXTPTR
D99C- 85 B8            STA TXTPTR
D99E- 90 02            BCC .1
D9A0- E6 B9            INC TXTPTR+1
                .1
D9A2- 60        <b><a name="RTS.6" id="RTS.6">RTS.6</a></b>  RTS
                *--------------------------------
                *      SCAN AHEAD TO NEXT ":" OR EOL
                *--------------------------------
D9A3- A2 3A     <b><a name="DATAN" id="DATAN">DATAN</a></b>  LDX #':'     GET OFFSET IN Y TO EOL OR ":"
D9A5- 2C               .HS 2C       FAKE
                *--------------------------------
D9A6- A2 00     <b><a name="REMN" id="REMN">REMN</a></b>   LDX #0       TO EOL ONLY
D9A8- 86 0D            STX CHARAC
D9AA- A0 00            LDY #0
D9AC- 84 0E            STY ENDCHR
D9AE- A5 0E     .1     LDA ENDCHR   TRICK TO COUNT QUOTE PARITY
D9B0- A6 0D            LDX CHARAC
D9B2- 85 0D            STA CHARAC
D9B4- 86 0E            STX ENDCHR
D9B6- B1 B8     .2     LDA (TXTPTR),Y
D9B8- F0 E8            BEQ <a href="#RTS.6">RTS.6</a>    END OF LINE
D9BA- C5 0E            CMP ENDCHR
D9BC- F0 E4            BEQ <a href="#RTS.6">RTS.6</a>    COLON IF LOOKING FOR COLONS
D9BE- C8               INY
D9BF- C9 22            CMP #'"'
D9C1- D0 F3            BNE .2
D9C3- F0 E9            BEQ .1       ...ALWAYS
                *--------------------------------
D9C5- 68        <b><a name="PULL3" id="PULL3">PULL3</a></b>  PLA
D9C6- 68               PLA
D9C7- 68               PLA
D9C8- 60               RTS
                *--------------------------------
                *      "IF" STATEMENT
                *--------------------------------
D9C9- 20 7B DD  <b><a name="IF" id="IF">IF</a></b>     JSR <a href="#FRMEVL">FRMEVL</a>
D9CC- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>
D9CF- C9 AB            CMP #TOKEN.GOTO
D9D1- F0 05            BEQ .1
D9D3- A9 C4            LDA #TOKEN.THEN
D9D5- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
D9D8- A5 9D     .1     LDA FAC      CONDITION TRUE OR FALSE?
D9DA- D0 05            BNE <a href="#IF.TRUE">IF.TRUE</a>  BRANCH IF TRUE
                *--------------------------------
                *      "REM" STATEMENT, OR FALSE "IF" STATEMENT
                *--------------------------------
D9DC- 20 A6 D9  <b><a name="REM" id="REM">REM</a></b>    JSR <a href="#REMN">REMN</a>     SKIP REST OF LINE
D9DF- F0 B7            BEQ <a href="#ADDON">ADDON</a>    ...ALWAYS
                *--------------------------------
                <b><a name="IF.TRUE" id="IF.TRUE">IF.TRUE</a></b>
D9E1- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   COMMAND OR NUMBER?
D9E4- B0 03            BCS .1       COMMAND
D9E6- 4C 3E D9         JMP <a href="#GOTO">GOTO</a>     NUMBER
D9E9- 4C 28 D8  .1     JMP <a href="#EXECUTE.STATEMENT">EXECUTE.STATEMENT</a>
                *--------------------------------
                *      "ON" STATEMENT
                *
                *      ON &lt;EXP&gt; GOTO &lt;LIST&gt;
                *      ON &lt;EXP&gt; GOSUB &lt;LIST&gt;
                *--------------------------------
D9EC- 20 F8 E6  <b><a name="ONGOTO" id="ONGOTO">ONGOTO</a></b> JSR <a href="#GETBYT">GETBYT</a>   EVALUATE &lt;EXP&gt;, AS BYTE IN FAC+4
D9EF- 48               PHA          SAVE NEXT CHAR ON STACK
D9F0- C9 B0            CMP #TOKEN.GOSUB
D9F2- F0 04            BEQ <a href="#ON.2">ON.2</a>
D9F4- C9 AB     <b><a name="ON.1" id="ON.1">ON.1</a></b>   CMP #TOKEN.GOTO
D9F6- D0 89            BNE <a href="#SYNERR.2">SYNERR.2</a>
D9F8- C6 A1     <b><a name="ON.2" id="ON.2">ON.2</a></b>   DEC FAC+4    COUNTED TO RIGHT ONE YET?
D9FA- D0 04            BNE .3       NO, KEEP LOOKING
D9FC- 68               PLA          YES, RETRIEVE CMD
D9FD- 4C 2A D8         JMP <a href="#EXECUTE.STATEMENT.1">EXECUTE.STATEMENT.1</a>   AND GO.
DA00- 20 B1 00  .3     JSR <a href="#CHRGET">CHRGET</a>   PRIME CONVERT SUBROUTINE
DA03- 20 0C DA         JSR <a href="#LINGET">LINGET</a>   CONVERT LINE #
DA06- C9 2C            CMP #','     TERMINATE WITH COMMA?
DA08- F0 EE            BEQ <a href="#ON.2">ON.2</a>     YES
DA0A- 68               PLA          NO, END OF LIST, SO IGNORE
DA0B- 60        <b><a name="RTS.7" id="RTS.7">RTS.7</a></b>  RTS
                *--------------------------------
                *      CONVERT LINE NUMBER
                *--------------------------------
DA0C- A2 00     <b><a name="LINGET" id="LINGET">LINGET</a></b> LDX #0       ASC # TO HEX ADDRESS
DA0E- 86 50            STX LINNUM   IN LINNUM.
DA10- 86 51            STX LINNUM+1
DA12- B0 F7     .1     BCS <a href="#RTS.7">RTS.7</a>    NOT A DIGIT
DA14- E9 2F            SBC #'0'-1   CONVERT DIGIT TO BINARY
DA16- 85 0D            STA CHARAC   SAVE THE DIGIT
DA18- A5 51            LDA LINNUM+1 CHECK RANGE
DA1A- 85 5E            STA INDEX
DA1C- C9 19            CMP /6400    LINE # TOO LARGE?
DA1E- B0 D4            BCS <a href="#ON.1">ON.1</a>     YES, &gt; 63999, GO INDIRECTLY TO 
                *                   "SYNTAX ERROR".
                *&lt;&lt;&lt;&lt;&lt;DANGEROUS CODE&gt;&gt;&gt;&gt;&gt;
                *      NOTE THAT IF (A) = $AB ON THE LINE ABOVE,
                *      ON.1 WILL COMPARE = AND CAUSE A CATASTROPHIC
                *      JUMP TO $22D9 (FOR GOTO), OR OTHER LOCATIONS
                *      FOR OTHER CALLS TO LINGET.
                *
                *      YOU CAN SEE THIS IS YOU FIRST PUT "BRK" IN $22D9,
                *      THEN TYPE "GO TO 437761".
                *
                *      ANY VALUE FROM 437760 THROUGH 440319 WILL CAUSE
                *      THE PROBLEM.  ($AB00 - $ABFF)
                *&lt;&lt;&lt;&lt;&lt;DANGEROUS CODE&gt;&gt;&gt;&gt;&gt;
DA20- A5 50            LDA LINNUM   MULTIPLY BY TEN
DA22- 0A               ASL
DA23- 26 5E            ROL INDEX
DA25- 0A               ASL
DA26- 26 5E            ROL INDEX
DA28- 65 50            ADC LINNUM
DA2A- 85 50            STA LINNUM
DA2C- A5 5E            LDA INDEX
DA2E- 65 51            ADC LINNUM+1
DA30- 85 51            STA LINNUM+1
DA32- 06 50            ASL LINNUM
DA34- 26 51            ROL LINNUM+1
DA36- A5 50            LDA LINNUM
DA38- 65 0D            ADC CHARAC   ADD DIGIT
DA3A- 85 50            STA LINNUM
DA3C- 90 02            BCC .2
DA3E- E6 51            INC LINNUM+1
DA40- 20 B1 00  .2     JSR <a href="#CHRGET">CHRGET</a>   GET NEXT CHAR
DA43- 4C 12 DA         JMP .1       MORE CONVERTING
                *--------------------------------
                *      "LET" STATEMENT
                *
                *      LET &lt;VAR&gt; = &lt;EXP&gt;
                *      &lt;VAR&gt; = &lt;EXP&gt;
                *--------------------------------
DA46- 20 E3 DF  <b><a name="LET" id="LET">LET</a></b>    JSR <a href="#PTRGET">PTRGET</a>   GET &lt;VAR&gt;
DA49- 85 85            STA FORPNT
DA4B- 84 86            STY FORPNT+1
DA4D- A9 D0            LDA #TOKEN.EQUAL
DA4F- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
DA52- A5 12            LDA VALTYP+1      SAVE VARIABLE TYPE
DA54- 48               PHA
DA55- A5 11            LDA VALTYP
DA57- 48               PHA
DA58- 20 7B DD         JSR <a href="#FRMEVL">FRMEVL</a>   EVALUATE &lt;EXP&gt;
DA5B- 68               PLA
DA5C- 2A               ROL
DA5D- 20 6D DD         JSR <a href="#CHKVAL">CHKVAL</a>
DA60- D0 18            BNE <a href="#LET.STRING">LET.STRING</a>
DA62- 68               PLA
                *--------------------------------
DA63- 10 12     <b><a name="LET2" id="LET2">LET2</a></b>   BPL .1       REAL VARIABLE
DA65- 20 72 EB         JSR <a href="#ROUND.FAC">ROUND.FAC</a>     INTEGER VAR: ROUND TO 32 BITS
DA68- 20 0C E1         JSR <a href="#AYINT">AYINT</a>         TRUNCATE TO 16-BITS
DA6B- A0 00            LDY #0
DA6D- A5 A0            LDA FAC+3
DA6F- 91 85            STA (FORPNT),Y
DA71- C8               INY
DA72- A5 A1            LDA FAC+4
DA74- 91 85            STA (FORPNT),Y
DA76- 60               RTS
                *--------------------------------
                *      REAL VARIABLE = EXPRESSION
                *--------------------------------
DA77- 4C 27 EB  .1     JMP <a href="#SETFOR">SETFOR</a>
                *--------------------------------
                <b><a name="LET.STRING" id="LET.STRING">LET.STRING</a></b>
DA7A- 68               PLA
                *--------------------------------
                *      INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
                *--------------------------------
DA7B- A0 02     <b><a name="PUTSTR" id="PUTSTR">PUTSTR</a></b> LDY #2       STRING DATA ALREADY IN STRING AREA?
DA7D- B1 A0            LDA (FAC+3),Y      (STRING AREA IS BTWN FRETOP
DA7F- C5 70            CMP FRETOP+1           HIMEM)
DA81- 90 17            BCC .2       YES, DATA ALREADY UP THERE
DA83- D0 07            BNE .1       NO
DA85- 88               DEY          MAYBE, TEST LOW BYTE OF POINTER
DA86- B1 A0            LDA (FAC+3),Y
DA88- C5 6F            CMP FRETOP
DA8A- 90 0E            BCC .2       YES, ALREADY THERE
DA8C- A4 A1     .1     LDY FAC+4   NO. DESCRIPTOR ALREADY AMONG VARIABLES?
DA8E- C4 6A            CPY VARTAB+1
DA90- 90 08            BCC .2       NO
DA92- D0 0D            BNE .3       YES
DA94- A5 A0            LDA FAC+3    MAYBE, COMPARE LO-BYTE
DA96- C5 69            CMP VARTAB
DA98- B0 07            BCS .3       YES, DESCRIPTOR IS AMONG VARIABLES
DA9A- A5 A0     .2     LDA FAC+3    EITHER STRING ALREADY ON TOP, OR
DA9C- A4 A1            LDY FAC+4    DESCRIPTOR IS NOT A VARIABLE
DA9E- 4C B7 DA         JMP .4       SO JUST STORE THE DESCRIPTOR
                *--------------------------------
                *      STRING NOT YET IN STRING AREA,
                *      AND DESCRIPTOR IS A VARIABLE
                *--------------------------------
DAA1- A0 00     .3     LDY #0       POINT AT LENGTH IN DESCRIPTOR
DAA3- B1 A0            LDA (FAC+3),Y GET LENGTH
DAA5- 20 D5 E3         JSR <a href="#STRINI">STRINI</a>   MAKE A STRING THAT LONG UP ABOVE
DAA8- A5 8C            LDA DSCPTR   SET UP SOURCE PNTR FOR MONINS
DAAA- A4 8D            LDY DSCPTR+1
DAAC- 85 AB            STA STRNG1
DAAE- 84 AC            STY STRNG1+1
DAB0- 20 D4 E5         JSR <a href="#MOVINS">MOVINS</a>   MOVE STRING DATA TO NEW AREA
DAB3- A9 9D            LDA #FAC     ADDRESS OF DESCRIPTOR IS IN FAC
DAB5- A0 00            LDY /FAC
DAB7- 85 8C     .4     STA DSCPTR
DAB9- 84 8D            STY DSCPTR+1
DABB- 20 35 E6         JSR <a href="#FRETMS">FRETMS</a>   DISCARD DESCRIPTOR IF 'TWAS TEMPORARY
DABE- A0 00            LDY #0       COPY STRING DESCRIPTOR
DAC0- B1 8C            LDA (DSCPTR),Y
DAC2- 91 85            STA (FORPNT),Y
DAC4- C8               INY
DAC5- B1 8C            LDA (DSCPTR),Y
DAC7- 91 85            STA (FORPNT),Y
DAC9- C8               INY
DACA- B1 8C            LDA (DSCPTR),Y
DACC- 91 85            STA (FORPNT),Y
DACE- 60               RTS
                *--------------------------------
                <b><a name="PR.STRING" id="PR.STRING">PR.STRING</a></b>
DACF- 20 3D DB         JSR <a href="#STRPRT">STRPRT</a>
DAD2- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>
                *--------------------------------
                *      "PRINT" STATEMENT
                *--------------------------------
DAD5- F0 24     <b><a name="PRINT" id="PRINT">PRINT</a></b>  BEQ <a href="#CRDO">CRDO</a>     NO MORE LIST, PRINT &lt;RETURN&gt;
                *--------------------------------
DAD7- F0 29     <b><a name="PRINT2" id="PRINT2">PRINT2</a></b> BEQ <a href="#RTS.8">RTS.8</a>    NO MORE LIST, DON'T PRINT &lt;RETURN&gt;
DAD9- C9 C0            CMP #TOKEN.TAB
DADB- F0 39            BEQ <a href="#PR.TAB.OR.SPC">PR.TAB.OR.SPC</a>     C=1 FOR TAB(
DADD- C9 C3            CMP #TOKEN.SPC
DADF- 18               CLC
DAE0- F0 34            BEQ <a href="#PR.TAB.OR.SPC">PR.TAB.OR.SPC</a>     C=0 FOR SPC(
DAE2- C9 2C            CMP #','
DAE4- 18               CLC               &lt;&lt;&lt; NO PURPOSE TO THIS &gt;&gt;&gt;
DAE5- F0 1C            BEQ <a href="#PR.COMMA">PR.COMMA</a>
DAE7- C9 3B            CMP #';'
DAE9- F0 44            BEQ <a href="#PR.NEXT.CHAR">PR.NEXT.CHAR</a>
DAEB- 20 7B DD         JSR <a href="#FRMEVL">FRMEVL</a>        EVALUATE EXPRESSION
DAEE- 24 11            BIT <a href="#VALTYP">VALTYP</a>        STRING OR FP VALUE?
DAF0- 30 DD            BMI <a href="#PR.STRING">PR.STRING</a>     STRING
DAF2- 20 34 ED         JSR <a href="#FOUT">FOUT</a>          FP: CONVERT INTO BUFFER
DAF5- 20 E7 E3         JSR <a href="#STRLIT">STRLIT</a>            MAKE BUFFER INTO STRING
DAF8- 4C CF DA         JMP <a href="#PR.STRING">PR.STRING</a>         PRINT THE STRING
                *--------------------------------
DAFB- A9 0D     <b><a name="CRDO" id="CRDO">CRDO</a></b>   LDA #$0D     PRINT &lt;RETURN&gt;
DAFD- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>
DB00- 49 FF     <b><a name="NEGATE" id="NEGATE">NEGATE</a></b> EOR #$FF     &lt;&lt;&lt; WHY??? &gt;&gt;&gt;
DB02- 60        <b><a name="RTS.8" id="RTS.8">RTS.8</a></b>  RTS
                *--------------------------------
                *      TAB TO NEXT COMMA COLUMN
                *      &lt;&lt;&lt; NOTE BUG IF WIDTH OF WINDOW LESS THAN 33 &gt;&gt;&gt;
                <b><a name="PR.COMMA" id="PR.COMMA">PR.COMMA</a></b>
DB03- A5 24            LDA MON.CH
DB05- C9 18            CMP #24      &lt;&lt;&lt; BUG:  IT SHOULD BE 32 &gt;&gt;&gt;
DB07- 90 05            BCC .1       NEXT COLUMN, SAME LINE
DB09- 20 FB DA         JSR <a href="#CRDO">CRDO</a>     FIRST COLUMN, NEXT LINT
DB0C- D0 21            BNE <a href="#PR.NEXT.CHAR">PR.NEXT.CHAR</a>  ...ALWAYS
DB0E- 69 10     .1     ADC #16
DB10- 29 F0            AND #$F0     ROUND TO 16 OR 32
DB12- 85 24            STA MON.CH
DB14- 90 19            BCC <a href="#PR.NEXT.CHAR">PR.NEXT.CHAR</a>  ...ALWAYS
                *--------------------------------
                <b><a name="PR.TAB.OR.SPC" id="PR.TAB.OR.SPC">PR.TAB.OR.SPC</a></b>
DB16- 08               PHP          C=0 FOR SPC(, C=1 FOR TAB(
DB17- 20 F5 E6         JSR <a href="#GTBYTC">GTBYTC</a>   GET VALUE
DB1A- C9 29            CMP #')'     TRAILING PARENTHESIS
DB1C- F0 03            BEQ .1       GOOD
DB1E- 4C C9 DE         JMP <a href="#SYNERR">SYNERR</a>   NO, SYNTAX ERROR
DB21- 28        .1     PLP          TAB( OR SPC(
DB22- 90 07            BCC .2       SPC(
DB24- CA               DEX          TAB(
DB25- 8A               TXA          CALCULATE SPACES NEEDED FOR TAB(
DB26- E5 24            SBC MON.CH
DB28- 90 05            BCC <a href="#PR.NEXT.CHAR">PR.NEXT.CHAR</a>  ALREADY PAST THAT COLUMN
DB2A- AA               TAX          NOW DO A SPC( TO THE SPECIFIED COLUMN
DB2B- E8        .2     INX
DB2C- CA        <b><a name="NXSPC" id="NXSPC">NXSPC</a></b>  DEX
DB2D- D0 06            BNE <a href="#DOSPC">DOSPC</a>    MORE SPACES TO PRINT
                *--------------------------------
                <b><a name="PR.NEXT.CHAR" id="PR.NEXT.CHAR">PR.NEXT.CHAR</a></b>
DB2F- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>
DB32- 4C D7 DA         JMP <a href="#PRINT2">PRINT2</a>   CONTINUE PARSING PRINT LIST
                *--------------------------------
DB35- 20 57 DB  <b><a name="DOSPC" id="DOSPC">DOSPC</a></b>  JSR <a href="#OUTSP">OUTSP</a>
DB38- D0 F2            BNE <a href="#NXSPC">NXSPC</a>    ...ALWAYS
                *--------------------------------
                *      PRINT STRING AT (Y,A)
DB3A- 20 E7 E3  <b><a name="STROUT" id="STROUT">STROUT</a></b> JSR <a href="#STRLIT">STRLIT</a>   MAKE (Y,A) PRINTABLE
                *--------------------------------
                *      PRINT STRING AT (FACMO,FACLO)
                *--------------------------------
DB3D- 20 00 E6  <b><a name="STRPRT" id="STRPRT">STRPRT</a></b> JSR <a href="#FREFAC">FREFAC</a>   GET ADDRESS INTO INDEX, (A)=LENGTH
DB40- AA               TAX          USE X-REG FOR COUNTER
DB41- A0 00            LDY #0       USE Y-REG FOR SCANNER
DB43- E8               INX
DB44- CA        .1     DEX
DB45- F0 BB            BEQ <a href="#RTS.8">RTS.8</a>    FINISHED
DB47- B1 5E            LDA (INDEX),Y     NEXT CHAR FROM STRING
DB49- 20 5C DB         JSR <a href="#OUTDO">OUTDO</a>    PRINT THE CHAR
DB4C- C8               INY
                *                   &lt;&lt;&lt; NEXT THREE LINES ARE USELESS &gt;&gt;&gt;
DB4D- C9 0D            CMP #$0D     WAS IT &lt;RETURN&gt;?
DB4F- D0 F3            BNE .1       NO
DB51- 20 00 DB         JSR <a href="#NEGATE">NEGATE</a>   EOR #$FF WOULD DO IT, BUT WHY?
                *                   &lt;&lt;&lt; ABOVE THREE LINES ARE USELESS &gt;&gt;&gt;
DB54- 4C 44 DB         JMP .1
                *--------------------------------
DB57- A9 20     <b><a name="OUTSP" id="OUTSP">OUTSP</a></b>  LDA #' '     PRINT A SPACE
DB59- 2C               .HS 2C       SKIP OVER NEXT LINE
DB5A- A9 3F     <b><a name="OUTQUES" id="OUTQUES">OUTQUES</a></b> LDA #'?'    PRINT QUESTION MARK
                *--------------------------------
                *      PRINT CHAR FROM (A)
                *
                *      NOTE: POKE 243,32 ($20 IN $F3) WILL CONVERT
                *      OUTPUT TO LOWER CASE.  THIS CAN BE CANCELLED
                *      BY NORMAL, INVERSE, OR FLASH OR POKE 243,0.
                *--------------------------------
DB5C- 09 80     <b><a name="OUTDO" id="OUTDO">OUTDO</a></b>  ORA #$80     PRINT (A)
DB5E- C9 A0            CMP #$A0     CONTROL CHR?
DB60- 90 02            BCC .1       SKIP IF SO
DB62- 05 F3            ORA FLASH.BIT   =$40 FOR FLASH, ELSE $00
DB64- 20 ED FD  .1     JSR <a href="#MON.COUT">MON.COUT</a> "AND"S WITH $3F (INVERSE), $7F (FLASH)
DB67- 29 7F            AND #$7F
DB69- 48               PHA
DB6A- A5 F1            LDA SPEEDZ   COMPLEMENT OF SPEED #
DB6C- 20 A8 FC         JSR <a href="#MON.WAIT">MON.WAIT</a>   SO SPEED=255 BECOMES (A)=1
DB6F- 68               PLA
DB70- 60               RTS
                *--------------------------------
                *      INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
                *      IN NUMERIC FIELD.  MUST DISTINGUISH
                *      BETWEEN INPUT, READ, AND GET
                *--------------------------------
                <b><a name="INPUTERR" id="INPUTERR">INPUTERR</a></b>
DB71- A5 15            LDA INPUTFLG
DB73- F0 12            BEQ <a href="#RESPERR">RESPERR</a>  TAKEN IF INPUT
DB75- 30 04            BMI <a href="#READERR">READERR</a>  TAKEN IF READ
DB77- A0 FF            LDY #$FF     FROM A GET
DB79- D0 04            BNE <a href="#ERLIN">ERLIN</a>    ...ALWAYS
                *--------------------------------
                <b><a name="READERR" id="READERR">READERR</a></b>
DB7B- A5 7B            LDA DATLIN   TELL WHERE THE "DATA" IS, RATHER
DB7D- A4 7C            LDY DATLIN+1    THAN THE "READ"
                *--------------------------------
DB7F- 85 75     <b><a name="ERLIN" id="ERLIN">ERLIN</a></b>  STA CURLIN
DB81- 84 76            STY CURLIN+1
DB83- 4C C9 DE         JMP <a href="#SYNERR">SYNERR</a>
                *--------------------------------
DB86- 68        <b><a name="INPERR" id="INPERR">INPERR</a></b> PLA
                *--------------------------------
                <b><a name="RESPERR" id="RESPERR">RESPERR</a></b>
DB87- 24 D8            BIT <a href="#ERRFLG">ERRFLG</a>   "ON ERR" TURNED ON?
DB89- 10 05            BPL .1       NO, GIVE REENTRY A TRY
DB8B- A2 FE            LDX #254     ERROR CODE = 254
DB8D- 4C E9 F2         JMP <a href="#HANDLERR">HANDLERR</a>
DB90- A9 EF     .1     LDA #ERR.REENTRY "?REENTER"
DB92- A0 DC            LDY /ERR.REENTRY
DB94- 20 3A DB         JSR <a href="#STROUT">STROUT</a>
DB97- A5 79            LDA OLDTEXT  RE-EXECUTE THE WHOLE INPUT STATEMENT
DB99- A4 7A            LDY OLDTEXT+1
DB9B- 85 B8            STA TXTPTR
DB9D- 84 B9            STY TXTPTR+1
DB9F- 60               RTS
                *--------------------------------
                *      "GET" STATEMENT
                *--------------------------------
DBA0- 20 06 E3  <b><a name="GET" id="GET">GET</a></b>    JSR <a href="#ERRDIR">ERRDIR</a>   ILLEGAL IF IN DIRECT MODE
DBA3- A2 01            LDX #INPUT.BUFFER+1    SIMULATE INPUT
DBA5- A0 02            LDY /INPUT.BUFFER+1
DBA7- A9 00            LDA #0
DBA9- 8D 01 02         STA INPUT.BUFFER+1
DBAC- A9 40            LDA #$40     SET UP INPUTFLG
DBAE- 20 EB DB         JSR <a href="#PROCESS.INPUT.LIST">PROCESS.INPUT.LIST</a>  &lt;&lt;&lt; CAN SAVE 1 BYTE HERE&gt;&gt;&gt;
DBB1- 60               RTS               &lt;&lt;&lt;BY "JMP PROCESS.INPUT.LIST"&gt;&gt;&gt;
                *--------------------------------
                *      "INPUT" STATEMENT
                *--------------------------------
DBB2- C9 22     <b><a name="INPUT" id="INPUT">INPUT</a></b>  CMP #'"'     CHECK FOR OPTIONAL PROMPT STRING
DBB4- D0 0E            BNE .1       NO, PRINT "?" PROMPT
DBB6- 20 81 DE         JSR <a href="#STRTXT">STRTXT</a>   MAKE A PRINTABLE STRING OUT OF IT
DBB9- A9 3B            LDA #';'     MUST HAVE ; NOW
DBBB- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
DBBE- 20 3D DB         JSR <a href="#STRPRT">STRPRT</a>   PRINT THE STRING
DBC1- 4C C7 DB         JMP .2
DBC4- 20 5A DB  .1     JSR <a href="#OUTQUES">OUTQUES</a>  NO STRING, PRINT "?"
DBC7- 20 06 E3  .2     JSR <a href="#ERRDIR">ERRDIR</a>   ILLEGAL IF IN DIRECT MODE
DBCA- A9 2C            LDA #','     PRIME THE BUFFER
DBCC- 8D FF 01         STA INPUT.BUFFER-1
DBCF- 20 2C D5         JSR <a href="#INLIN">INLIN</a>
DBD2- AD 00 02         LDA INPUT.BUFFER
DBD5- C9 03            CMP #$03     CONTROL C?
DBD7- D0 10            BNE <a href="#INPUT.FLAG.ZERO">INPUT.FLAG.ZERO</a>   NO
DBD9- 4C 63 D8         JMP <a href="#CONTROL.C.TYPED">CONTROL.C.TYPED</a>
                *--------------------------------
DBDC- 20 5A DB  <b><a name="NXIN" id="NXIN">NXIN</a></b>   JSR <a href="#OUTQUES">OUTQUES</a>  PRINT "?"
DBDF- 4C 2C D5         JMP <a href="#INLIN">INLIN</a>
                *--------------------------------
                *      "READ" STATEMENT
                *--------------------------------
DBE2- A6 7D     <b><a name="READ" id="READ">READ</a></b>   LDX DATPTR   Y,X POINTS AT NEXT DATA STATEMENT
DBE4- A4 7E            LDY DATPTR+1
DBE6- A9 98            LDA #$98     SET INPUTFLG = $98
DBE8- 2C               .HS 2C       TRICK TO PROCESS.INPUT.LIST
                *--------------------------------
                <b><a name="INPUT.FLAG.ZERO" id="INPUT.FLAG.ZERO">INPUT.FLAG.ZERO</a></b>
DBE9- A9 00            LDA #0       SET INPUTFLG = $00
                *--------------------------------
                *      PROCESS INPUT LIST
                *
                *      (Y,X) IS ADDRESS OF INPUT DATA STRING
                *      (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
                *                                 $40 FOR GET
                *                                 $98 FOR READ
                *--------------------------------
                <b><a name="PROCESS.INPUT.LIST" id="PROCESS.INPUT.LIST">PROCESS.INPUT.LIST</a></b>
DBEB- 85 15            STA INPUTFLG
DBED- 86 7F            STX INPTR    ADDRESS OF INPUT STRING
DBEF- 84 80            STY INPTR+1
                *--------------------------------
                <b><a name="PROCESS.INPUT.ITEM" id="PROCESS.INPUT.ITEM">PROCESS.INPUT.ITEM</a></b>
DBF1- 20 E3 DF         JSR <a href="#PTRGET">PTRGET</a>   GET ADDRESS OF VARIABLE
DBF4- 85 85            STA FORPNT
DBF6- 84 86            STY FORPNT+1
DBF8- A5 B8            LDA TXTPTR   SAVE CURRENT TXTPTR,
DBFA- A4 B9            LDY TXTPTR+1      WHICH POINTS INTO PROGRAM
DBFC- 85 87            STA TXPSV
DBFE- 84 88            STY TXPSV+1
DC00- A6 7F            LDX INPTR    SET TXTPTR TO POINT AT INPUT BUFFER
DC02- A4 80            LDY INPTR+1       OR "DATA" LINE
DC04- 86 B8            STX TXTPTR
DC06- 84 B9            STY TXTPTR+1
DC08- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   GET CHAR AT PNTR
DC0B- D0 1E            BNE <a href="#INSTART">INSTART</a>  NOT END OF LINE OR COLON
DC0D- 24 15            BIT <a href="#INPUTFLG">INPUTFLG</a>      DOING A "GET"?
DC0F- 50 0E            BVC .1            NO
DC11- 20 0C FD         JSR <a href="#MON.RDKEY">MON.RDKEY</a>     YES, GET CHAR
DC14- 29 7F            AND #$7F
DC16- 8D 00 02         STA INPUT.BUFFER
DC19- A2 FF            LDX #INPUT.BUFFER-1
DC1B- A0 01            LDY /INPUT.BUFFER-1
DC1D- D0 08            BNE .2       ...ALWAYS
                *--------------------------------
DC1F- 30 7F     .1     BMI <a href="#FINDATA">FINDATA</a>  DOING A "READ"
DC21- 20 5A DB         JSR <a href="#OUTQUES">OUTQUES</a>  DOING AN "INPUT", PRINT "?"
DC24- 20 DC DB         JSR <a href="#NXIN">NXIN</a>     PRINT ANOTHER "?", AND INPUT A LINE
DC27- 86 B8     .2     STX TXTPTR
DC29- 84 B9            STY TXTPTR+1
                *--------------------------------
                <b><a name="INSTART" id="INSTART">INSTART</a></b>
DC2B- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   GET NEXT INPUT CHAR
DC2E- 24 11            BIT <a href="#VALTYP">VALTYP</a>   STRING OR NUMERIC?
DC30- 10 31            BPL .5       NUMERIC
DC32- 24 15            BIT <a href="#INPUTFLG">INPUTFLG</a> STRING -- NOW WHAT INPUT TYPE?
DC34- 50 09            BVC .1       NOT A "GET"
DC36- E8               INX          "GET"
DC37- 86 B8            STX TXTPTR
DC39- A9 00            LDA #0
DC3B- 85 0D            STA CHARAC   NO OTHER TERMINATORS THAN $00
DC3D- F0 0C            BEQ .2       ...ALWAYS
                *--------------------------------
DC3F- 85 0D     .1     STA CHARAC
DC41- C9 22            CMP #'"'     TERMINATE ON $00 OR QUOTE
DC43- F0 07            BEQ .3
DC45- A9 3A            LDA #':'     TERMINATE ON $00, COLON, OR COMMA
DC47- 85 0D            STA CHARAC
DC49- A9 2C            LDA #','
DC4B- 18        .2     CLC
DC4C- 85 0E     .3     STA ENDCHR
DC4E- A5 B8            LDA TXTPTR
DC50- A4 B9            LDY TXTPTR+1
DC52- 69 00            ADC #0       SKIP OVER QUOTATION MARK, IF
DC54- 90 01            BCC .4           THERE WAS ONE
DC56- C8               INY
DC57- 20 ED E3  .4     JSR <a href="#STRLT2">STRLT2</a>   BUILD STRING STARTING AT (Y,A)
                *                TERMINATED BY $00, (CHARAC), OR (ENDCHR)
DC5A- 20 3D E7         JSR <a href="#POINT">POINT</a>    SET TXTPTR TO POINT AT STRING
DC5D- 20 7B DA         JSR <a href="#PUTSTR">PUTSTR</a>   STORE STRING IN VARIABLE
DC60- 4C 72 DC         JMP <a href="#INPUT.MORE">INPUT.MORE</a>
                *--------------------------------
DC63- 48        .5     PHA
DC64- AD 00 02         LDA INPUT.BUFFER  ANYTHING IN BUFFER?
DC67- F0 30            BEQ <a href="#INPFIN">INPFIN</a>        NO, SEE IF READ OR INPUT
                *--------------------------------
                <b><a name="INPUT.DATA" id="INPUT.DATA">INPUT.DATA</a></b>
DC69- 68               PLA               "READ"
DC6A- 20 4A EC         JSR <a href="#FIN">FIN</a>      GET FP NUMBER AT TXTPTR
DC6D- A5 12            LDA VALTYP+1
DC6F- 20 63 DA         JSR <a href="#LET2">LET2</a>     STORE RESULT IN VARIABLE
                *--------------------------------
                <b><a name="INPUT.MORE" id="INPUT.MORE">INPUT.MORE</a></b>
DC72- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>
DC75- F0 07            BEQ .1       END OF LINE OR COLON
DC77- C9 2C            CMP #','     COMMA IN INPUT?
DC79- F0 03            BEQ .1       YES
DC7B- 4C 71 DB         JMP <a href="#INPUTERR">INPUTERR</a>  NOTHING ELSE WILL DO
DC7E- A5 B8     .1     LDA TXTPTR   SAVE POSITION IN INPUT BUFFER
DC80- A4 B9            LDY TXTPTR+1
DC82- 85 7F            STA INPTR
DC84- 84 80            STY INPTR+1
DC86- A5 87            LDA TXPSV    RESTORE PROGRAM POINTER
DC88- A4 88            LDY TXPSV+1
DC8A- 85 B8            STA TXTPTR
DC8C- 84 B9            STY TXTPTR+1
DC8E- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   NEXT CHAR FROM PROGRAM
DC91- F0 33            BEQ <a href="#INPDONE">INPDONE</a>  END OF STATEMENT
DC93- 20 BE DE         JSR <a href="#CHKCOM">CHKCOM</a>   BETTER BE A COMMA THEN
DC96- 4C F1 DB         JMP <a href="#PROCESS.INPUT.ITEM">PROCESS.INPUT.ITEM</a>
                *--------------------------------
DC99- A5 15     <b><a name="INPFIN" id="INPFIN">INPFIN</a></b> LDA INPUTFLG      "INPUT" OR "READ"
DC9B- D0 CC            BNE <a href="#INPUT.DATA">INPUT.DATA</a>    "READ"
DC9D- 4C 86 DB         JMP <a href="#INPERR">INPERR</a>
                *--------------------------------
                <b><a name="FINDATA" id="FINDATA">FINDATA</a></b>
DCA0- 20 A3 D9         JSR <a href="#DATAN">DATAN</a>    GET OFFSET TO NEXT COLON OR EOL
DCA3- C8               INY          TO FIRST CHAR OF NEXT LINE
DCA4- AA               TAX          WHICH:  EOL OR COLON?
DCA5- D0 12            BNE .1       COLON
DCA7- A2 2A            LDX #ERR.NODATA   EOL: MIGHT BE OUT OF DATA
DCA9- C8               INY          CHECK HI-BYTE OF FORWARD PNTR
DCAA- B1 B8            LDA (TXTPTR),Y  END OF PROGRAM?
DCAC- F0 5F            BEQ <a href="#GERR">GERR</a>     YES, WE ARE OUT OF DATA
DCAE- C8               INY          PICK UP THE LINE #
DCAF- B1 B8            LDA (TXTPTR),Y
DCB1- 85 7B            STA DATLIN
DCB3- C8               INY
DCB4- B1 B8            LDA (TXTPTR),Y
DCB6- C8               INY          POINT AT FIRST TEXT CHAR IN LINE
DCB7- 85 7C            STA DATLIN+1
DCB9- B1 B8     .1     LDA (TXTPTR),Y  GET 1ST TOKEN OF STATEMENT
DCBB- AA               TAX          SAVE TOKEN IN X-REG
DCBC- 20 98 D9         JSR <a href="#ADDON">ADDON</a>    ADD (Y) TO TXTPTR
DCBF- E0 83            CPX #TOKEN.DATA   DID WE FIND A "DATA" STATEMENT?
DCC1- D0 DD            BNE <a href="#FINDATA">FINDATA</a>       NOT YET
DCC3- 4C 2B DC         JMP <a href="#INSTART">INSTART</a>       YES, READ IT
                *---NO MORE INPUT REQUESTED------
                <b><a name="INPDONE" id="INPDONE">INPDONE</a></b>
DCC6- A5 7F            LDA INPTR    GET POINTER IN CASE IT WAS "READ"
DCC8- A4 80            LDY INPTR+1
DCCA- A6 15            LDX INPUTFLG      "READ" OR "INPUT"?
DCCC- 10 03            BPL .1            "INPUT"
DCCE- 4C 53 D8         JMP <a href="#SETDA">SETDA</a>         "DATA", SO STORE (Y,X) AT DATPTR
DCD1- A0 00     .1     LDY #0       "INPUT":  ANY MORE CHARS ON LINE?
DCD3- B1 7F            LDA (INPTR),Y
DCD5- F0 07            BEQ .2           NO, ALL IS WELL
DCD7- A9 DF            LDA #ERR.EXTRA   YES, ERROR
DCD9- A0 DC            LDY /ERR.EXTRA   "EXTRA IGNORED"
DCDB- 4C 3A DB         JMP <a href="#STROUT">STROUT</a>
DCDE- 60        .2     RTS
                *--------------------------------
                <b><a name="ERR.EXTRA" id="ERR.EXTRA">ERR.EXTRA</a></b>
DCDF- 3F 45 58
DCE2- 54 52 41
DCE5- 20 49 47
DCE8- 4E 4F 52
DCEB- 45 44            .AS '?EXTRA IGNORED'
DCED- 0D 00            .HS 0D00
                <b><a name="ERR.REENTRY" id="ERR.REENTRY">ERR.REENTRY</a></b>
DCEF- 3F 52 45
DCF2- 45 4E 54
DCF5- 45 52            .AS '?REENTER'
DCF7- 0D 00            .HS 0D00
                *--------------------------------
              1010 *--------------------------------
                *      "NEXT" STATEMENT
                *--------------------------------
DCF9- D0 04     <b><a name="NEXT" id="NEXT">NEXT</a></b>   BNE <a href="#NEXT.1">NEXT.1</a>   VARIABLE AFTER "NEXT"
DCFB- A0 00            LDY #0       FLAG BY SETTING FORPNT+1 = 0
DCFD- F0 03            BEQ <a href="#NEXT.2">NEXT.2</a>  ...ALWAYS
                *--------------------------------
DCFF- 20 E3 DF  <b><a name="NEXT.1" id="NEXT.1">NEXT.1</a></b> JSR <a href="#PTRGET">PTRGET</a>   GET PNTR TO VARIABLE IN (Y,A)
DD02- 85 85     <b><a name="NEXT.2" id="NEXT.2">NEXT.2</a></b> STA FORPNT   
DD04- 84 86            STY FORPNT+1
DD06- 20 65 D3         JSR <a href="#GTFORPNT">GTFORPNT</a>  FIND FOR-FRAME FOR THIS VARIABLE
DD09- F0 04            BEQ <a href="#NEXT.3">NEXT.3</a>    FOUND IT
DD0B- A2 00            LDX #ERR.NOFOR    NOT THERE, ABORT
DD0D- F0 69     <b><a name="GERR" id="GERR">GERR</a></b>   BEQ <a href="#JERROR">JERROR</a>    ...ALWAYS
DD0F- 9A        <b><a name="NEXT.3" id="NEXT.3">NEXT.3</a></b> TXS          SET STACK PTR TO POINT TO THIS FRAME,
DD10- E8               INX              WHICH TRIMS OFF ANY INNER LOOPS
DD11- E8               INX
DD12- E8               INX
DD13- E8               INX
DD14- 8A               TXA          LOW BYTE OF ADRS OF STEP VALUE
DD15- E8               INX
DD16- E8               INX
DD17- E8               INX
DD18- E8               INX
DD19- E8               INX
DD1A- E8               INX
DD1B- 86 60            STX DEST     LOW BYTE ADRS OF FOR VAR VALUE
DD1D- A0 01            LDY /STACK   (Y,A) IS ADDRESS OF STEP VALUE
DD1F- 20 F9 EA         JSR <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>   STEP TO FAC
DD22- BA               TSX
DD23- BD 09 01         LDA STACK+9,X
DD26- 85 A2            STA FAC.SIGN
DD28- A5 85            LDA FORPNT
DD2A- A4 86            LDY FORPNT+1
DD2C- 20 BE E7         JSR <a href="#FADD">FADD</a>     ADD TO FOR VALUE
DD2F- 20 27 EB         JSR <a href="#SETFOR">SETFOR</a>   PUT NEW VALUE BACK
DD32- A0 01            LDY /STACK   (Y,A) IS ADDRESS OF END VALUE
DD34- 20 B4 EB         JSR <a href="#FCOMP2">FCOMP2</a>   COMPARE TO END VALUE
DD37- BA               TSX
DD38- 38               SEC
DD39- FD 09 01         SBC STACK+9,X   SIGN OF STEP
DD3C- F0 17            BEQ .2       BRANCH IF FOR COMPLETE
DD3E- BD 0F 01         LDA STACK+15,X  OTHERWISE SET UP
DD41- 85 75            STA CURLIN    FOR LINE #
DD43- BD 10 01         LDA STACK+16,X
DD46- 85 76            STA CURLIN+1
DD48- BD 12 01         LDA STACK+18,X   AND SET TXTPTR TO JUST
DD4B- 85 B8            STA TXTPTR       AFTER FOR STATEMENT
DD4D- BD 11 01         LDA STACK+17,X
DD50- 85 B9            STA TXTPTR+1
DD52- 4C D2 D7  .1     JMP <a href="#NEWSTT">NEWSTT</a>
DD55- 8A        .2     TXA          POP OFF FOR-FRAME, LOOP IS DONE
DD56- 69 11            ADC #17      CARRY IS SET, SO ADDS 18
DD58- AA               TAX
DD59- 9A               TXS
DD5A- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   CHAR AFTER VARIABLE
DD5D- C9 2C            CMP #','     ANOTHER VARIABLE IN NEXT?
DD5F- D0 F1            BNE .1       NO, GO TO NEXT STATEMENT
DD61- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   YES, PRIME FOR NEXT VARIABLE
DD64- 20 FF DC         JSR <a href="#NEXT.1">NEXT.1</a>   (DOES NOT RETURN)
                *--------------------------------
                *      EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
                *--------------------------------
DD67- 20 7B DD  <b><a name="FRMNUM" id="FRMNUM">FRMNUM</a></b> JSR <a href="#FRMEVL">FRMEVL</a>
                *--------------------------------
                *      MAKE SURE (FAC) IS NUMERIC
                *--------------------------------
DD6A- 18        <b><a name="CHKNUM" id="CHKNUM">CHKNUM</a></b> CLC
DD6B- 24               .HS 24       DUMMY FOR SKIP
                *--------------------------------
                *      MAKE SURE (FAC) IS STRING
                *--------------------------------
DD6C- 38        <b><a name="CHKSTR" id="CHKSTR">CHKSTR</a></b> SEC
                *--------------------------------
                *      MAKE SURE (FAC) IS CORRECT TYPE
                *      IF C=0, TYPE MUST BE NUMERIC
                *      IF C=1, TYPE MUST BE STRING
                *--------------------------------
DD6D- 24 11     <b><a name="CHKVAL" id="CHKVAL">CHKVAL</a></b> BIT <a href="#VALTYP">VALTYP</a>   $00 IF NUMERIC, $FF IF STRING
DD6F- 30 03            BMI .2       TYPE IS STRING
DD71- B0 03            BCS .3       NOT STRING, BUT WE NEED STRING
DD73- 60        .1     RTS          TYPE IS CORRECT
DD74- B0 FD     .2     BCS .1       IS STRING AND WE WANTED STRING
DD76- A2 A3     .3     LDX #ERR.BADTYPE  TYPE MISMATCH
DD78- 4C 12 D4  <b><a name="JERROR" id="JERROR">JERROR</a></b> JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
                *      EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
                *      RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
                *      EXPRESSIONS.
                *--------------------------------
DD7B- A6 B8     <b><a name="FRMEVL" id="FRMEVL">FRMEVL</a></b> LDX TXTPTR   DECREMENT TXTPTR
DD7D- D0 02            BNE .1
DD7F- C6 B9            DEC TXTPTR+1
DD81- C6 B8     .1     DEC TXTPTR
DD83- A2 00            LDX #0       START WITH PRECEDENCE = 0
DD85- 24               .HS 24       TRICK TO SKIP FOLLOWING "PHA"
                *--------------------------------
                <b><a name="FRMEVL.1" id="FRMEVL.1">FRMEVL.1</a></b>
DD86- 48               PHA          PUSH RELOPS FLAGS
DD87- 8A               TXA
DD88- 48               PHA          SAVE LAST PRECEDENCE
DD89- A9 01            LDA #1
DD8B- 20 D6 D3         JSR <a href="#CHKMEM">CHKMEM</a>   CHECK IF ENOUGH ROOM ON STACK
DD8E- 20 60 DE         JSR <a href="#FRM.ELEMENT">FRM.ELEMENT</a>   GET AN ELEMENT
DD91- A9 00            LDA #0
DD93- 85 89            STA CPRTYP   CLEAR COMPARISON OPERATOR FLAGS
                *--------------------------------
                <b><a name="FRMEVL.2" id="FRMEVL.2">FRMEVL.2</a></b>
DD95- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   CHECK FOR RELATIONAL OPERATORS
DD98- 38        .1     SEC          &gt; IS $CF, = IS $D0, &lt; IS $D1
DD99- E9 CF            SBC #TOKEN.GREATER   &gt; IS 0, = IS 1, &lt; IS 2
DD9B- 90 17            BCC .2       NOT RELATIONAL OPERATOR
DD9D- C9 03            CMP #3
DD9F- B0 13            BCS .2       NOT RELATIONAL OPERATOR
DDA1- C9 01            CMP #1       SET CARRY IF "=" OR "&lt;"
DDA3- 2A               ROL          NOW &gt; IS 0, = IS 3, &lt; IS 5
DDA4- 49 01            EOR #1       NOW &gt; IS 1, = IS 2, &lt; IS 4
DDA6- 45 89            EOR CPRTYP   SET BITS OF CPRTYP:  00000&lt;=&gt;
DDA8- C5 89            CMP CPRTYP   CHECK FOR ILLEGAL COMBINATIONS
DDAA- 90 61            BCC <a href="#SNTXERR">SNTXERR</a>  IF LESS THAN, A RELOP WAS REPEATED
DDAC- 85 89            STA CPRTYP
DDAE- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   ANOTHER OPERATOR?
DDB1- 4C 98 DD         JMP .1       CHECK FOR &lt;,=,&gt; AGAIN
                *--------------------------------
DDB4- A6 89     .2     LDX CPRTYP   DID WE FIND A RELATIONAL OPERATOR?
DDB6- D0 2C            BNE <a href="#FRM.RELATIONAL">FRM.RELATIONAL</a>  YES
DDB8- B0 7B            BCS <a href="#NOTMATH">NOTMATH</a>  NO, AND NEXT TOKEN IS &gt; $D1
DDBA- 69 07            ADC #$CF-TOKEN.PLUS  NO, AND NEXT TOKEN &lt; $CF
DDBC- 90 77            BCC <a href="#NOTMATH">NOTMATH</a>  IF NEXT TOKEN &lt; "+"
DDBE- 65 11            ADC VALTYP   + AND LAST RESULT A STRING?
DDC0- D0 03            BNE .3       BRANCH IF NOT
DDC2- 4C 97 E5         JMP <a href="#CAT">CAT</a>      CONCATENATE IF SO.
                *--------------------------------
DDC5- 69 FF     .3     ADC #$FF     +-*/ IS 0123
DDC7- 85 5E            STA INDEX
DDC9- 0A               ASL          MULTIPLY BY 3
DDCA- 65 5E            ADC INDEX    +-*/ IS 0,3,6,9
DDCC- A8               TAY
                *--------------------------------
                <b><a name="FRM.PRECEDENCE.TEST" id="FRM.PRECEDENCE.TEST">FRM.PRECEDENCE.TEST</a></b>
DDCD- 68               PLA          GET LAST PRECEDENCE
DDCE- D9 B2 D0         CMP MATHTBL,Y
DDD1- B0 67            BCS <a href="#FRM.PERFORM.1">FRM.PERFORM.1</a>    DO NOW IF HIGHER PRECEDENCE
DDD3- 20 6A DD         JSR <a href="#CHKNUM">CHKNUM</a>   WAS LAST RESULT A #?
DDD6- 48        <b><a name="NXOP" id="NXOP">NXOP</a></b>   PHA          YES, SAVE PRECEDENCE ON STACK
DDD7- 20 FD DD  <b><a name="SAVOP" id="SAVOP">SAVOP</a></b>  JSR <a href="#FRM.RECURSE">FRM.RECURSE</a>  SAVE REST, CALL FRMEVL RECURSIVELY
DDDA- 68               PLA
DDDB- A4 87            LDY LASTOP
DDDD- 10 17            BPL <a href="#PREFNC">PREFNC</a>
DDDF- AA               TAX
DDE0- F0 56            BEQ <a href="#GOEX">GOEX</a>     EXIT IF NO MATH IN EXPRESSION
DDE2- D0 5F            BNE <a href="#FRM.PERFORM.2">FRM.PERFORM.2</a>  ...ALWAYS
                *--------------------------------
                *      FOUND ONE OR MORE RELATIONAL OPERATORS &lt;,=,&gt;
                *--------------------------------
                <b><a name="FRM.RELATIONAL" id="FRM.RELATIONAL">FRM.RELATIONAL</a></b>
DDE4- 46 11            LSR VALTYP   (VALTYP) = 0 (NUMERIC), = $FF (STRING)
DDE6- 8A               TXA          SET CPRTYP TO 0000&lt;=&gt;C
DDE7- 2A               ROL          WHERE C=0 IF #, C=1 IF STRING
DDE8- A6 B8            LDX TXTPTR   BACK UP TXTPTR
DDEA- D0 02            BNE .1
DDEC- C6 B9            DEC TXTPTR+1
DDEE- C6 B8     .1     DEC TXTPTR
DDF0- A0 1B            LDY #M.REL-MATHTBL   POINT AT RELOPS ENTRY
DDF2- 85 89            STA CPRTYP
DDF4- D0 D7            BNE <a href="#FRM.PRECEDENCE.TEST">FRM.PRECEDENCE.TEST</a>   ...ALWAYS
                *--------------------------------
DDF6- D9 B2 D0  <b><a name="PREFNC" id="PREFNC">PREFNC</a></b> CMP MATHTBL,Y
DDF9- B0 48            BCS <a href="#FRM.PERFORM.2">FRM.PERFORM.2</a>  DO NOW IF HIGHER PRECEDENCE
DDFB- 90 D9            BCC <a href="#NXOP">NXOP</a>     ...ALWAYS
                *--------------------------------
                *      STACK THIS OPERATION AND CALL FRMEVL FOR
                *      ANOTHER ONE
                *--------------------------------
                <b><a name="FRM.RECURSE" id="FRM.RECURSE">FRM.RECURSE</a></b>
DDFD- B9 B4 D0         LDA MATHTBL+2,Y
DE00- 48               PHA          PUSH ADDRESS OF OPERATION PERFORMER
DE01- B9 B3 D0         LDA MATHTBL+1,Y
DE04- 48               PHA
DE05- 20 10 DE         JSR <a href="#FRM.STACK.1">FRM.STACK.1</a>   STACK FAC.SIGN AND FAC
DE08- A5 89            LDA CPRTYP   A=RELOP FLAGS, X=PRECEDENCE BYTE
DE0A- 4C 86 DD         JMP <a href="#FRMEVL.1">FRMEVL.1</a>      RECURSIVELY CALL FRMEVL
                *--------------------------------
DE0D- 4C C9 DE  <b><a name="SNTXERR" id="SNTXERR">SNTXERR</a></b> JMP SYNERR
                *--------------------------------
                *      STACK (FAC)
                *
                *      THREE ENTRY POINTS:
                *          .1, FROM FRMEVL
                *          .2, FROM "STEP"
                *          .3, FROM "FOR"
                *--------------------------------
                <b><a name="FRM.STACK.1" id="FRM.STACK.1">FRM.STACK.1</a></b>
DE10- A5 A2            LDA FAC.SIGN        GET FAC.SIGN TO PUSH IT
DE12- BE B2 D0         LDX MATHTBL,Y     PRECEDENCE BYTE FROM MATHTBL
                *--------------------------------
                *      ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
                *--------------------------------
                <b><a name="FRM.STACK.2" id="FRM.STACK.2">FRM.STACK.2</a></b>
DE15- A8               TAY          FAC.SIGN OR SGN(STEP VALUE)
DE16- 68               PLA          PULL RETURN ADDRESS AND ADD 1
DE17- 85 5E            STA INDEX    &lt;&lt;&lt; ASSUMES NOT ON PAGE BOUNDARY! &gt;&gt;&gt;
DE19- E6 5E            INC INDEX    PLACE BUMPED RETURN ADDRESS IN
DE1B- 68               PLA              INDEX,INDEX+1
DE1C- 85 5F            STA INDEX+1
DE1E- 98               TYA          FAC.SIGN OR SGN(STEP VALUE)
DE1F- 48               PHA          PUSH FAC.SIGN OR SGN(STEP VALUE)
                *--------------------------------
                *      ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
                *      TO PUSH INITIAL VALUE OF "FOR" VARIABLE
                *--------------------------------
                <b><a name="FRM.STACK.3" id="FRM.STACK.3">FRM.STACK.3</a></b>
DE20- 20 72 EB         JSR <a href="#ROUND.FAC">ROUND.FAC</a>     ROUND TO 32 BITS
DE23- A5 A1            LDA FAC+4         PUSH (FAC)
DE25- 48               PHA
DE26- A5 A0            LDA FAC+3
DE28- 48               PHA
DE29- A5 9F            LDA FAC+2
DE2B- 48               PHA
DE2C- A5 9E            LDA FAC+1
DE2E- 48               PHA
DE2F- A5 9D            LDA FAC
DE31- 48               PHA
DE32- 6C 5E 00         JMP (INDEX)       DO RTS FUNNY WAY
                *--------------------------------
                *
                *--------------------------------
DE35- A0 FF     <b><a name="NOTMATH" id="NOTMATH">NOTMATH</a></b> LDY #$FF    SET UP TO EXIT ROUTINE
DE37- 68               PLA
DE38- F0 23     <b><a name="GOEX" id="GOEX">GOEX</a></b>   BEQ <a href="#EXIT">EXIT</a>       EXIT IF NO MATH TO DO
                *--------------------------------
                *      PERFORM STACKED OPERATION
                *
                *      (A) = PRECEDENCE BYTE
                *      STACK:  1 -- CPRMASK
                *              5 -- (ARG)
                *              2 -- ADDR OF PERFORMER
                *--------------------------------
                <b><a name="FRM.PERFORM.1" id="FRM.PERFORM.1">FRM.PERFORM.1</a></b>
DE3A- C9 64            CMP #P.REL   WAS IT RELATIONAL OPERATOR?
DE3C- F0 03            BEQ .1       YES, ALLOW STRING COMPARE
DE3E- 20 6A DD         JSR <a href="#CHKNUM">CHKNUM</a>   MUST BE NUMERIC VALUE
DE41- 84 87     .1     STY LASTOP
                *--------------------------------
                <b><a name="FRM.PERFORM.2" id="FRM.PERFORM.2">FRM.PERFORM.2</a></b>
DE43- 68               PLA          GET 0000&lt;=&gt;C FROM STACK
DE44- 4A               LSR          SHIFT TO 00000&lt;=&gt; FORM
DE45- 85 16            STA CPRMASK   00000&lt;=&gt;
DE47- 68               PLA
DE48- 85 A5            STA ARG      GET FLOATING POINT VALUE OFF STACK,
DE4A- 68               PLA          AND PUT IT IN ARG
DE4B- 85 A6            STA ARG+1
DE4D- 68               PLA
DE4E- 85 A7            STA ARG+2
DE50- 68               PLA
DE51- 85 A8            STA ARG+3
DE53- 68               PLA
DE54- 85 A9            STA ARG+4
DE56- 68               PLA
DE57- 85 AA            STA ARG+5
DE59- 45 A2            EOR FAC.SIGN   SAVE EOR OF SIGNS OF THE OPERANDS,
DE5B- 85 AB            STA SGNCPR   IN CASE OF MULTIPLY OR DIVIDE
DE5D- A5 9D     <b><a name="EXIT" id="EXIT">EXIT</a></b>   LDA FAC      FAC EXPONENT IN A-REG
DE5F- 60               RTS          STATUS .EQ. IF (FAC)=0
                *                   RTS GOES TO PERFORM OPERATION
                *--------------------------------
                *      GET ELEMENT IN EXPRESSION
                *
                *      GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
                *      TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
                *--------------------------------
                <b><a name="FRM.ELEMENT" id="FRM.ELEMENT">FRM.ELEMENT</a></b>
DE60- A9 00            LDA #0       ASSUME NUMERIC
DE62- 85 11            STA VALTYP
DE64- 20 B1 00  .1     JSR <a href="#CHRGET">CHRGET</a>
DE67- B0 03            BCS .3       NOT A DIGIT
DE69- 4C 4A EC  .2     JMP <a href="#FIN">FIN</a>      NUMERIC CONSTANT
DE6C- 20 7D E0  .3     JSR <a href="#ISLETC">ISLETC</a>   VARIABLE NAME?
DE6F- B0 64            BCS <a href="#FRM.VARIABLE">FRM.VARIABLE</a> YES
DE71- C9 2E            CMP #'.'     DECIMAL POINT
DE73- F0 F4            BEQ .2       YES, NUMERIC CONSTANT
DE75- C9 C9            CMP #TOKEN.MINUS  UNARY MINUS?
DE77- F0 55            BEQ <a href="#MIN">MIN</a>           YES
DE79- C9 C8            CMP #TOKEN.PLUS   UNARY PLUS
DE7B- F0 E7            BEQ .1            YES
DE7D- C9 22            CMP #'"'     STRING CONSTANT?
DE7F- D0 0F            BNE <a href="#NOT.">NOT.</a>     NO
                *--------------------------------
                *      STRING CONSTANT ELEMENT
                *
                *      SET Y,A = (TXTPTR)+CARRY
                *--------------------------------
DE81- A5 B8     <b><a name="STRTXT" id="STRTXT">STRTXT</a></b> LDA TXTPTR   ADD (CARRY) TO GET ADDRESS OF 1ST CHAR
DE83- A4 B9            LDY TXTPTR+1      OF STRING IN Y,A
DE85- 69 00            ADC #0
DE87- 90 01            BCC .1
DE89- C8               INY
DE8A- 20 E7 E3  .1     JSR <a href="#STRLIT">STRLIT</a>   BUILD DESCRIPTOR TO STRING
                *                   GET ADDRESS OF DESCRIPTOR IN FAC
DE8D- 4C 3D E7         JMP <a href="#POINT">POINT</a>    POINT TXTPTR AFTER TRAILING QUOTE
                *--------------------------------
                *      "NOT" FUNCTION
                *      IF FAC=0, RETURN FAC=1
                *      IF FAC&lt;&gt;0, RETURN FAC=0
                *--------------------------------
DE90- C9 C6     <b><a name="NOT." id="NOT.">NOT.</a></b>   CMP #TOKEN.NOT
DE92- D0 10            BNE <a href="#FN.">FN.</a>      NOT "NOT", TRY "FN"
DE94- A0 18            LDY #M.EQU-MATHTBL  POINT AT = COMPARISON
DE96- D0 38            BNE <a href="#EQUL">EQUL</a>     ...ALWAYS
                *--------------------------------
                *      COMPARISON FOR EQUALITY (= OPERATOR)
                *      ALSO USED TO EVALUATE "NOT" FUNCTION
                *--------------------------------
DE98- A5 9D     <b><a name="EQUOP" id="EQUOP">EQUOP</a></b>  LDA FAC      SET "TRUE" IF (FAC) = ZERO
DE9A- D0 03            BNE .1       FALSE
DE9C- A0 01            LDY #1       TRUE
DE9E- 2C               .HS 2C       TRICK TO SKIP NEXT 2 BYTES
DE9F- A0 00     .1     LDY #0       FALSE
DEA1- 4C 01 E3         JMP <a href="#SNGFLT">SNGFLT</a>
                *--------------------------------
DEA4- C9 C2     <b><a name="FN." id="FN.">FN.</a></b>    CMP #TOKEN.FN
DEA6- D0 03            BNE <a href="#SGN.">SGN.</a>
DEA8- 4C 54 E3         JMP <a href="#FUNCT">FUNCT</a>
                *--------------------------------
DEAB- C9 D2     <b><a name="SGN." id="SGN.">SGN.</a></b>   CMP #TOKEN.SGN
DEAD- 90 03            BCC <a href="#PARCHK">PARCHK</a>
DEAF- 4C 0C DF         JMP <a href="#UNARY">UNARY</a>
                *--------------------------------
                *      EVALUATE "(EXPRESSION)"
                *--------------------------------
DEB2- 20 BB DE  <b><a name="PARCHK" id="PARCHK">PARCHK</a></b> JSR <a href="#CHKOPN">CHKOPN</a>   IS THERE A '(' AT TXTPTR?
DEB5- 20 7B DD         JSR <a href="#FRMEVL">FRMEVL</a>   YES, EVALUATE EXPRESSION
                *--------------------------------
DEB8- A9 29     <b><a name="CHKCLS" id="CHKCLS">CHKCLS</a></b> LDA #')'     CHECK FOR ')'
DEBA- 2C               .HS 2C       TRICK
                *--------------------------------
DEBB- A9 28     <b><a name="CHKOPN" id="CHKOPN">CHKOPN</a></b> LDA #'('
DEBD- 2C               .HS 2C       TRICK
                *--------------------------------
DEBE- A9 2C     <b><a name="CHKCOM" id="CHKCOM">CHKCOM</a></b> LDA #','     COMMA AT TXTPTR?
                *--------------------------------
                *      UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
                *--------------------------------
DEC0- A0 00     <b><a name="SYNCHR" id="SYNCHR">SYNCHR</a></b> LDY #0
DEC2- D1 B8            CMP (TXTPTR),Y
DEC4- D0 03            BNE <a href="#SYNERR">SYNERR</a>
DEC6- 4C B1 00         JMP <a href="#CHRGET">CHRGET</a>   MATCH, GET NEXT CHAR &amp; RETURN
                *--------------------------------
DEC9- A2 10     <b><a name="SYNERR" id="SYNERR">SYNERR</a></b> LDX #ERR.SYNTAX
DECB- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
DECE- A0 15     <b><a name="MIN" id="MIN">MIN</a></b>    LDY #M.NEG-MATHTBL  POINT AT UNARY MINUS
DED0- 68        <b><a name="EQUL" id="EQUL">EQUL</a></b>   PLA
DED1- 68               PLA
DED2- 4C D7 DD         JMP <a href="#SAVOP">SAVOP</a>
                *--------------------------------
                <b><a name="FRM.VARIABLE" id="FRM.VARIABLE">FRM.VARIABLE</a></b>
DED5- 20 E3 DF         JSR <a href="#PTRGET">PTRGET</a>
DED7-           FRM.VARIABLE.CALL .EQ *-1   SO PTRGET CAN TELL WE CALLED
DED8- 85 A0            STA VPNT     ADDRESS OF VARIABLE
DEDA- 84 A1            STY VPNT+1
DEDC- A6 11            LDX VALTYP   NUMERIC OR STRING?
DEDE- F0 05            BEQ .1       NUMERIC
DEE0- A2 00            LDX #0       STRING
DEE2- 86 AC            STX STRNG1+1
DEE4- 60               RTS
DEE5- A6 12     .1     LDX VALTYP+1 NUMERIC, WHICH TYPE?
DEE7- 10 0D            BPL .2       FLOATING POINT
DEE9- A0 00            LDY #0       INTEGER
DEEB- B1 A0            LDA (VPNT),Y
DEED- AA               TAX          GET VALUE IN A,Y
DEEE- C8               INY
DEEF- B1 A0            LDA (VPNT),Y
DEF1- A8               TAY
DEF2- 8A               TXA
DEF3- 4C F2 E2         JMP <a href="#GIVAYF">GIVAYF</a>   CONVERT A,Y TO FLOATING POINT
DEF6- 4C F9 EA  .2     JMP <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>
             1010 *--------------------------------
                *      "SCRN(" FUNCTION
                *--------------------------------
DEF9- 20 B1 00  <b><a name="SCREEN" id="SCREEN">SCREEN</a></b> JSR <a href="#CHRGET">CHRGET</a>
DEFC- 20 EC F1         JSR <a href="#PLOTFNS">PLOTFNS</a>  GET COLUMN AND ROW
DEFF- 8A               TXA          ROW
DF00- A4 F0            LDY FIRST    COLUMN
DF02- 20 71 F8         JSR <a href="#MON.SCRN">MON.SCRN</a> GET 4-BIT COLOR THERE
DF05- A8               TAY
DF06- 20 01 E3         JSR <a href="#SNGFLT">SNGFLT</a>   CONVERT (Y) TO REAL IN FAC
DF09- 4C B8 DE         JMP <a href="#CHKCLS">CHKCLS</a>   REQUIRE ")"
                *--------------------------------
                *      PROCESS UNARY OPERATORS (FUNCTIONS)
                *--------------------------------
DF0C- C9 D7     <b><a name="UNARY" id="UNARY">UNARY</a></b>  CMP #TOKEN.SCRN     NOT UNARY, DO SPECIAL
DF0E- F0 E9            BEQ <a href="#SCREEN">SCREEN</a>
DF10- 0A               ASL          DOUBLE TOKEN TO GET INDEX
DF11- 48               PHA
DF12- AA               TAX
DF13- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>
DF16- E0 CF            CPX #TOKEN.LEFTSTR*2-1   LEFT$, RIGHT$, AND MID$
DF18- 90 20            BCC .1       NOT ONE OF THE STRING FUNCTIONS
DF1A- 20 BB DE         JSR <a href="#CHKOPN">CHKOPN</a>   STRING FUNCTION, NEED "("
DF1D- 20 7B DD         JSR <a href="#FRMEVL">FRMEVL</a>   EVALUATE EXPRESSION FOR STRING
DF20- 20 BE DE         JSR <a href="#CHKCOM">CHKCOM</a>   REQUIRE A COMMA
DF23- 20 6C DD         JSR <a href="#CHKSTR">CHKSTR</a>   MAKE SURE EXPRESSION IS A STRING
DF26- 68               PLA
DF27- AA               TAX          RETRIEVE ROUTINE POINTER
DF28- A5 A1            LDA VPNT+1   STACK ADDRESS OF STRING
DF2A- 48               PHA
DF2B- A5 A0            LDA VPNT
DF2D- 48               PHA
DF2E- 8A               TXA
DF2F- 48               PHA          STACK DOUBLED TOKEN
DF30- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   CONVERT NEXT EXPRESSION TO BYTE IN X-REG
DF33- 68               PLA          GET DOUBLED TOKEN OFF STACK
DF34- A8               TAY          USE AS INDEX TO BRANCH 
DF35- 8A               TXA          VALUE OF SECOND PARAMETER
DF36- 48               PHA          PUSH 2ND PARAM
DF37- 4C 3F DF         JMP .2       JOIN UNARY FUNCTIONS
DF3A- 20 B2 DE  .1     JSR <a href="#PARCHK">PARCHK</a>   REQUIRE "(EXPRESSION)"
DF3D- 68               PLA
DF3E- A8               TAY          INDEX INTO FUNCTION ADDRESS TABLE
DF3F- B9 DC CF  .2     LDA UNFNC-TOKEN.SGN-TOKEN.SGN+$100,Y
DF42- 85 91            STA JMPADRS+1  PREPARE TO JSR TO ADDRESS
DF44- B9 DD CF         LDA UNFNC-TOKEN.SGN-TOKEN.SGN+$101,Y
DF47- 85 92            STA JMPADRS+2
DF49- 20 90 00         JSR <a href="#JMPADRS">JMPADRS</a>  DOES NOT RETURN FOR
                *                   CHR$, LEFT$, RIGHT$, OR MID$
DF4C- 4C 6A DD         JMP <a href="#CHKNUM">CHKNUM</a>   REQUIRE NUMERIC RESULT
                *--------------------------------
DF4F- A5 A5     <b><a name="OR" id="OR">OR</a></b>     LDA ARG      "OR" OPERATOR
DF51- 05 9D            ORA FAC      IF RESULT NONZERO, IT IS TRUE
DF53- D0 0B            BNE <a href="#TRUE">TRUE</a>
                *--------------------------------
DF55- A5 A5     <b><a name="AND" id="AND">AND</a></b>    LDA ARG      "AND" OPERATOR
DF57- F0 04            BEQ <a href="#FALSE">FALSE</a>    IF EITHER IS ZERO, RESULT IS FALSE
DF59- A5 9D            LDA FAC
DF5B- D0 03            BNE <a href="#TRUE">TRUE</a>
                *--------------------------------
DF5D- A0 00     <b><a name="FALSE" id="FALSE">FALSE</a></b>  LDY #0       RETURN FAC=0
DF5F- 2C               .HS 2C       TRICK
                *--------------------------------
DF60- A0 01     <b><a name="TRUE" id="TRUE">TRUE</a></b>   LDY #1       RETURN FAC=1
DF62- 4C 01 E3         JMP <a href="#SNGFLT">SNGFLT</a>
                *--------------------------------
                *      PERFORM RELATIONAL OPERATIONS
                *--------------------------------
DF65- 20 6D DD  <b><a name="RELOPS" id="RELOPS">RELOPS</a></b> JSR <a href="#CHKVAL">CHKVAL</a>   MAKE SURE FAC IS CORRECT TYPE
DF68- B0 13            BCS <a href="#STRCMP">STRCMP</a>   TYPE MATCHES, BRANCH IF STRINGS
DF6A- A5 AA            LDA ARG.SIGN   NUMERIC COMPARISON
DF6C- 09 7F            ORA #$7F     RE-PACK VALUE IN ARG FOR FCOMP
DF6E- 25 A6            AND ARG+1
DF70- 85 A6            STA ARG+1
DF72- A9 A5            LDA #ARG
DF74- A0 00            LDY /ARG
DF76- 20 B2 EB         JSR <a href="#FCOMP">FCOMP</a>    RETURN A-REG = -1,0,1
DF79- AA               TAX           AS ARG &lt;,=,&gt; FAC
DF7A- 4C B0 DF         JMP <a href="#NUMCMP">NUMCMP</a>
                *--------------------------------
                *      STRING COMPARISON
                *--------------------------------
DF7D- A9 00     <b><a name="STRCMP" id="STRCMP">STRCMP</a></b> LDA #0       SET RESULT TYPE TO NUMERIC
DF7F- 85 11            STA VALTYP
DF81- C6 89            DEC CPRTYP   MAKE CPRTYP 0000&lt;=&gt;0
DF83- 20 00 E6         JSR <a href="#FREFAC">FREFAC</a>
DF86- 85 9D            STA FAC      STRING LENGTH
DF88- 86 9E            STX FAC+1
DF8A- 84 9F            STY FAC+2
DF8C- A5 A8            LDA ARG+3
DF8E- A4 A9            LDY ARG+4
DF90- 20 04 E6         JSR <a href="#FRETMP">FRETMP</a>
DF93- 86 A8            STX ARG+3
DF95- 84 A9            STY ARG+4
DF97- AA               TAX          LEN (ARG) STRING
DF98- 38               SEC
DF99- E5 9D            SBC FAC      SET X TO SMALLER LEN
DF9B- F0 08            BEQ .1
DF9D- A9 01            LDA #1
DF9F- 90 04            BCC .1
DFA1- A6 9D            LDX FAC
DFA3- A9 FF            LDA #$FF
DFA5- 85 A2     .1     STA FAC.SIGN      FLAG WHICH SHORTER
DFA7- A0 FF            LDY #$FF
DFA9- E8               INX
                <b><a name="STRCMP.1" id="STRCMP.1">STRCMP.1</a></b>
DFAA- C8               INY
DFAB- CA               DEX
DFAC- D0 07            BNE <a href="#STRCMP.2">STRCMP.2</a>      MORE CHARS IN BOTH STRINGS
DFAE- A6 A2            LDX FAC.SIGN   IF = SO FAR, DECIDE BY LENGTH
                *--------------------------------
DFB0- 30 0F     <b><a name="NUMCMP" id="NUMCMP">NUMCMP</a></b> BMI <a href="#CMPDONE">CMPDONE</a>
DFB2- 18               CLC
DFB3- 90 0C            BCC <a href="#CMPDONE">CMPDONE</a>  ...ALWAYS
                *--------------------------------
                <b><a name="STRCMP.2" id="STRCMP.2">STRCMP.2</a></b>
DFB5- B1 A8            LDA (ARG+3),Y
DFB7- D1 9E            CMP (FAC+1),Y
DFB9- F0 EF            BEQ <a href="#STRCMP.1">STRCMP.1</a>      SAME, KEEP COMPARING
DFBB- A2 FF            LDX #$FF          IN CASE ARG GREATER
DFBD- B0 02            BCS <a href="#CMPDONE">CMPDONE</a>       IT IS
DFBF- A2 01            LDX #1            FAC GREATER
                *--------------------------------
                <b><a name="CMPDONE" id="CMPDONE">CMPDONE</a></b>
DFC1- E8               INX          CONVERT FF,0,1 TO 0,1,2
DFC2- 8A               TXA
DFC3- 2A               ROL          AND TO 0,2,4 IF C=0, ELSE 1,2,5
DFC4- 25 16            AND CPRMASK  00000&lt;=&gt;
DFC6- F0 02            BEQ .1       IF NO MATCH: FALSE
DFC8- A9 01            LDA #1       AT LEAST ONE MATCH: TRUE
DFCA- 4C 93 EB  .1     JMP <a href="#FLOAT">FLOAT</a>
                *--------------------------------
                *      "PDL" FUNCTION
                *      &lt;&lt;&lt; NOTE: ARG&lt;4 IS NOT CHECKED &gt;&gt;&gt;
                *--------------------------------
DFCD- 20 FB E6  <b><a name="PDL" id="PDL">PDL</a></b>    JSR <a href="#CONINT">CONINT</a>       GET # IN X
DFD0- 20 1E FB         JSR <a href="#MON.PREAD">MON.PREAD</a>    READ PADDLE
DFD3- 4C 01 E3         JMP <a href="#SNGFLT">SNGFLT</a>       FLOAT RESULT
                *--------------------------------
                *      "DIM" STATEMENT
                *--------------------------------
DFD6- 20 BE DE  <b><a name="NXDIM" id="NXDIM">NXDIM</a></b>  JSR <a href="#CHKCOM">CHKCOM</a>   SEPARATED BY COMMAS
DFD9- AA        <b><a name="DIM" id="DIM">DIM</a></b>    TAX          NON-ZERO, FLAGS PTRGET DIM CALLED
DFDA- 20 E8 DF         JSR <a href="#PTRGET2">PTRGET2</a>  ALLOCATE THE ARRAY
DFDD- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   NEXT CHAR
DFE0- D0 F4            BNE <a href="#NXDIM">NXDIM</a>    NOT END OF STATEMENT
DFE2- 60               RTS
                *--------------------------------
                *      PTRGET -- GENERAL VARIABLE SCAN
                *
                *      SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
                *      VARTAB AND ARYTAB FOR THE NAME.
                *      IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
                *      RETURN WITH ADDRESS IN VARPNT AND Y,A
                *
                *      ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
                *          DIMFLG -- NONZERO IF CALLED FROM "DIM"
                *                    ELSE = 0
                *
                *          SUBFLG -- = $00
                *                    = $40 IF CALLED FROM "GETARYPT"
                *                    = $80 IF CALLED FROM "DEF FN"
                *                    = $C1-DA IF CALLED FROM "FN"
                *--------------------------------
DFE3- A2 00     <b><a name="PTRGET" id="PTRGET">PTRGET</a></b> LDX #0
DFE5- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   GET FIRST CHAR OF VARIABLE NAME
                *--------------------------------
                <b><a name="PTRGET2" id="PTRGET2">PTRGET2</a></b>
DFE8- 86 10            STX DIMFLG   X IS NONZERO IF FROM DIM
                *--------------------------------
                <b><a name="PTRGET3" id="PTRGET3">PTRGET3</a></b>
DFEA- 85 81            STA VARNAM
DFEC- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>
DFEF- 20 7D E0         JSR <a href="#ISLETC">ISLETC</a>   IS IT A LETTER?
DFF2- B0 03            BCS <a href="#NAMOK">NAMOK</a>    YES, OKAY SO FAR
DFF4- 4C C9 DE  <b><a name="BADNAM" id="BADNAM">BADNAM</a></b> JMP <a href="#SYNERR">SYNERR</a>   NO, SYNTAX ERROR
DFF7- A2 00     <b><a name="NAMOK" id="NAMOK">NAMOK</a></b>  LDX #0
DFF9- 86 11            STX VALTYP
DFFB- 86 12            STX VALTYP+1
DFFD- 4C 07 E0         JMP <a href="#PTRGET4">PTRGET4</a>  TO BRANCH ACROSS $E000 VECTORS
                *--------------------------------
                *      DOS AND MONITOR CALL BASIC AT $E000 AND $E003
                *--------------------------------
E000- 4C 28 F1         JMP <a href="#COLD.START">COLD.START</a>
E003- 4C 3C D4         JMP <a href="#RESTART">RESTART</a>
E006- 00               BRK          &lt;&lt;&lt; WASTED BYTE &gt;&gt;&gt;
                *--------------------------------
                <b><a name="PTRGET4" id="PTRGET4">PTRGET4</a></b>
E007- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   SECOND CHAR OF VARIABLE NAME
E00A- 90 05            BCC .1       NUMERIC
E00C- 20 7D E0         JSR <a href="#ISLETC">ISLETC</a>   LETTER?
E00F- 90 0B            BCC .3       NO, END OF NAME
E011- AA        .1     TAX          SAVE SECOND CHAR OF NAME IN X
E012- 20 B1 00  .2     JSR <a href="#CHRGET">CHRGET</a>   SCAN TO END OF VARIABLE NAME
E015- 90 FB            BCC .2       NUMERIC
E017- 20 7D E0         JSR <a href="#ISLETC">ISLETC</a>
E01A- B0 F6            BCS .2       ALPHA
E01C- C9 24     .3     CMP #'$'     STRING?
E01E- D0 06            BNE .4       NO
E020- A9 FF            LDA #$FF
E022- 85 11            STA VALTYP
E024- D0 10            BNE .5       ...ALWAYS
E026- C9 25     .4     CMP #'%'     INTEGER?
E028- D0 13            BNE .6       NO
E02A- A5 14            LDA SUBFLG   YES; INTEGER VARIABLE ALLOWED?
E02C- 30 C6            BMI <a href="#BADNAM">BADNAM</a>   NO, SYNTAX ERROR
E02E- A9 80            LDA #$80     YES
E030- 85 12            STA VALTYP+1 FLAG INTEGER MODE
E032- 05 81            ORA VARNAM
E034- 85 81            STA VARNAM   SET SIGN BIT ON VARNAME
E036- 8A        .5     TXA          SECOND CHAR OF NAME
E037- 09 80            ORA #$80     SET SIGN
E039- AA               TAX
E03A- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   GET TERMINATING CHAR
E03D- 86 82     .6     STX VARNAM+1 STORE SECOND CHAR OF NAME
E03F- 38               SEC
E040- 05 14            ORA SUBFLG   $00 OR $40 IF SUBSCRIPTS OK, ELSE $80
E042- E9 28            SBC #'('     IF SUBFLG=$00 AND CHAR="("...
E044- D0 03            BNE .8       NOPE
E046- 4C 1E E1  .7     JMP <a href="#ARRAY">ARRAY</a>    YES
E049- 24 14     .8     BIT <a href="#SUBFLG">SUBFLG</a>   CHECK TOP TWO BITS OF SUBFLG
E04B- 30 02            BMI .9       $80
E04D- 70 F7            BVS .7       $40, CALLED FROM GETARYPT
E04F- A9 00     .9     LDA #0       CLEAR SUBFLG
E051- 85 14            STA SUBFLG
E053- A5 69            LDA VARTAB   START LOWTR AT SIMPLE VARIABLE TABLE
E055- A6 6A            LDX VARTAB+1
E057- A0 00            LDY #0
E059- 86 9C     .10    STX LOWTR+1
E05B- 85 9B     .11    STA LOWTR
E05D- E4 6C            CPX ARYTAB+1  END OF SIMPLE VARIABLES?
E05F- D0 04            BNE .12       NO, GO ON
E061- C5 6B            CMP ARYTAB    YES; END OF ARRAYS?
E063- F0 22            BEQ <a href="#NAME.NOT.FOUND">NAME.NOT.FOUND</a>    YES, MAKE ONE
E065- A5 81     .12    LDA VARNAM    SAME FIRST LETTER?
E067- D1 9B            CMP (LOWTR),Y
E069- D0 08            BNE .13       NOT SAME FIRST LETTER
E06B- A5 82            LDA VARNAM+1  SAME SECOND LETTER?
E06D- C8               INY
E06E- D1 9B            CMP (LOWTR),Y
E070- F0 6C            BEQ <a href="#SET.VARPNT.AND.YA">SET.VARPNT.AND.YA</a>   YES, SAME VARIABLE NAME
E072- 88               DEY           NO, BUMP TO NEXT NAME
E073- 18        .13    CLC
E074- A5 9B            LDA LOWTR
E076- 69 07            ADC #7
E078- 90 E1            BCC .11
E07A- E8               INX
E07B- D0 DC            BNE .10      ...ALWAYS
                *--------------------------------
                *      CHECK IF (A) IS ASCII LETTER A-Z
                *
                *      RETURN CARRY = 1 IF A-Z
                *                   = 0 IF NOT
                *
                *      &lt;&lt;&lt;NOTE FASTER AND SHORTER CODE:    &gt;&gt;&gt;
                *      &lt;&lt;&lt;    CMP #'Z'+1  COMPARE HI END
                *      &lt;&lt;&lt;    BCS .1      ABOVE A-Z
                *      &lt;&lt;&lt;    CMP #'A'    COMPARE LO END
                *      &lt;&lt;&lt;    RTS         C=0 IF LO, C=1 IF A-Z
                *      &lt;&lt;&lt;.1  CLC         C=0 IF HI
                *      &lt;&lt;&lt;    RTS
                *--------------------------------
E07D- C9 41     <b><a name="ISLETC" id="ISLETC">ISLETC</a></b> CMP #'A'     COMPARE LO END
E07F- 90 05            BCC .1       C=0 IF LOW
E081- E9 5B            SBC #'Z'+1   PREPARE HI END TEST
E083- 38               SEC          TEST HI END, RESTORING (A)
E084- E9 A5            SBC #-1-'Z'  C=0 IF LO, C=1 IF A-Z
E086- 60        .1     RTS
                *--------------------------------
                *      VARIABLE NOT FOUND, SO MAKE ONE
                *--------------------------------
                <b><a name="NAME.NOT.FOUND" id="NAME.NOT.FOUND">NAME.NOT.FOUND</a></b>
E087- 68               PLA          LOOK AT RETURN ADDRESS ON STACK TO
E088- 48               PHA          SEE IF CALLED FROM FRM.VARIABLE
E089- C9 D7            CMP #FRM.VARIABLE.CALL
E08B- D0 0F            BNE <a href="#MAKE.NEW.VARIABLE">MAKE.NEW.VARIABLE</a>   NO
E08D- BA               TSX
E08E- BD 02 01         LDA STACK+2,X
E091- C9 DE            CMP /FRM.VARIABLE.CALL
E093- D0 07            BNE <a href="#MAKE.NEW.VARIABLE">MAKE.NEW.VARIABLE</a>   NO
E095- A9 9A            LDA #C.ZERO  YES, CALLED FROM FRM.VARIABLE
E097- A0 E0            LDY /C.ZERO  POINT TO A CONSTANT ZERO
E099- 60               RTS          NEW VARIABLE USED IN EXPRESSION = 0
                *--------------------------------
E09A- 00 00     <b><a name="C.ZERO" id="C.ZERO">C.ZERO</a></b> .HS 0000     INTEGER OR REAL ZERO, OR NULL STRING
                *--------------------------------
                *      MAKE A NEW SIMPLE VARIABLE
                *
                *      MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
                *      ENTER 7-BYTE VARIABLE DATA IN THE HOLE
                *--------------------------------
                <b><a name="MAKE.NEW.VARIABLE" id="MAKE.NEW.VARIABLE">MAKE.NEW.VARIABLE</a></b>
E09C- A5 6B            LDA ARYTAB   SET UP CALL TO BLTU TO
E09E- A4 6C            LDY ARYTAB+1    TO MOVE FROM ARYTAB THRU STREND-1
E0A0- 85 9B            STA LOWTR       7 BYTES HIGHER
E0A2- 84 9C            STY LOWTR+1
E0A4- A5 6D            LDA STREND
E0A6- A4 6E            LDY STREND+1
E0A8- 85 96            STA HIGHTR
E0AA- 84 97            STY HIGHTR+1
E0AC- 18               CLC
E0AD- 69 07            ADC #7
E0AF- 90 01            BCC .1
E0B1- C8               INY
E0B2- 85 94     .1     STA ARYPNT
E0B4- 84 95            STY ARYPNT+1
E0B6- 20 93 D3         JSR <a href="#BLTU">BLTU</a>     MOVE ARRAY BLOCK UP
E0B9- A5 94            LDA ARYPNT   STORE NEW START OF ARRAYS
E0BB- A4 95            LDY ARYPNT+1
E0BD- C8               INY
E0BE- 85 6B            STA ARYTAB
E0C0- 84 6C            STY ARYTAB+1
E0C2- A0 00            LDY #0
E0C4- A5 81            LDA VARNAM   FIRST CHAR OF NAME
E0C6- 91 9B            STA (LOWTR),Y
E0C8- C8               INY
E0C9- A5 82            LDA VARNAM+1 SECOND CHAR OF NAME
E0CB- 91 9B            STA (LOWTR),Y
E0CD- A9 00            LDA #0       SET FIVE-BYTE VALUE TO 0
E0CF- C8               INY
E0D0- 91 9B            STA (LOWTR),Y
E0D2- C8               INY
E0D3- 91 9B            STA (LOWTR),Y
E0D5- C8               INY
E0D6- 91 9B            STA (LOWTR),Y
E0D8- C8               INY
E0D9- 91 9B            STA (LOWTR),Y
E0DB- C8               INY
E0DC- 91 9B            STA (LOWTR),Y
                *--------------------------------
                *      PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
                *--------------------------------
                <b><a name="SET.VARPNT.AND.YA" id="SET.VARPNT.AND.YA">SET.VARPNT.AND.YA</a></b>
E0DE- A5 9B            LDA LOWTR    LOWTR POINTS AT NAME OF VARIABLE,
E0E0- 18               CLC          SO ADD 2 TO GET TO VALUE
E0E1- 69 02            ADC #2
E0E3- A4 9C            LDY LOWTR+1
E0E5- 90 01            BCC .1
E0E7- C8               INY
E0E8- 85 83     .1     STA VARPNT   ADDRESS IN VARPNT AND Y,A
E0EA- 84 84            STY VARPNT+1
E0EC- 60               RTS
                *--------------------------------
                *      COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
                *      ARYPNT = (LOWTR) + #DIMS*2 + 5
                *--------------------------------
E0ED- A5 0F     <b><a name="GETARY" id="GETARY">GETARY</a></b> LDA NUMDIM   GET # OF DIMENSIONS
                *--------------------------------
                <b><a name="GETARY2" id="GETARY2">GETARY2</a></b>
E0EF- 0A               ASL          #DIMS*2 (SIZE OF EACH DIM IN 2 BYTES)
E0F0- 69 05            ADC #5       + 5 (2 FOR NAME, 2 FOR OFFSET TO NEXT
                *                   ARRAY, AND 1 FOR #DIMS
E0F2- 65 9B            ADC LOWTR    ADDRESS OF TH IS ARRAY IN ARYTAB
E0F4- A4 9C            LDY LOWTR+1
E0F6- 90 01            BCC .1
E0F8- C8               INY
E0F9- 85 94     .1     STA ARYPNT   ADDRESS OF FIRST VALUE IN ARRAY
E0FB- 84 95            STY ARYPNT+1
E0FD- 60               RTS
                *--------------------------------
E0FE- 90 80 00
E101- 00        <b><a name="NEG32768" id="NEG32768">NEG32768</a></b> .HS 90800000 -32768.00049 IN FLOATING POINT
                * &lt;&lt;&lt;  MEANT TO BE -32768, WHICH WOULD BE 9080000000 &gt;&gt;&gt;
                * &lt;&lt;&lt;  1 BYTE SHORT, SO PICKS UP $20 FROM NEXT INSTRUCTION
                *--------------------------------
                *      EVALUATE NUMERIC FORMULA AT TXTPTR
                *      CONVERTING RESULT TO INTEGER 0 &lt;= X &lt;= 32767
                *      IN FAC+3,4
                *--------------------------------
E102- 20 B1 00  <b><a name="MAKINT" id="MAKINT">MAKINT</a></b> JSR <a href="#CHRGET">CHRGET</a>
E105- 20 67 DD         JSR <a href="#FRMNUM">FRMNUM</a>
                *--------------------------------
                *      CONVERT FAC TO INTEGER
                *      MUST BE POSITIVE AND LESS THAN 32768
                *--------------------------------
E108- A5 A2     <b><a name="MKINT" id="MKINT">MKINT</a></b>  LDA FAC.SIGN   ERROR IF -
E10A- 30 0D            BMI <a href="#MI1">MI1</a>
                *--------------------------------
                *      CONVERT FAC TO INTEGER
                *      MUST BE -32767 &lt;= FAC &lt;= 32767
                *--------------------------------
E10C- A5 9D     <b><a name="AYINT" id="AYINT">AYINT</a></b>  LDA FAC      EXPONENT OF VALUE IN FAC
E10E- C9 90            CMP #$90     ABS(VALUE) &lt; 32768?
E110- 90 09            BCC <a href="#MI2">MI2</a>      YES, OK FOR INTEGER
E112- A9 FE            LDA #NEG32768  NO; NEXT FEW LINES ARE SUPPOSED TO
E114- A0 E0            LDY /NEG32768  ALLOW -32768 ($8000), BUT DO NOT!
E116- 20 B2 EB         JSR <a href="#FCOMP">FCOMP</a>    BECAUSE COMPARED TO -32768.00049
                *      &lt;&lt;&lt; BUG:  A=-32768.00049:A%=A IS ACCEPTED &gt;&gt;&gt;
                *      &lt;&lt;&lt;       BUT PRINT A,A% SHOWS THAT       &gt;&gt;&gt;
                *      &lt;&lt;&lt;       A=-32768.0005 (OK), A%=32767    &gt;&gt;&gt;
                *      &lt;&lt;&lt;       WRONG! WRONG! WRONG!            &gt;&gt;&gt;
                *--------------------------------
E119- D0 7E     <b><a name="MI1" id="MI1">MI1</a></b>    BNE <a href="#IQERR">IQERR</a>    ILLEGAL QUANTITY
E11B- 4C F2 EB  <b><a name="MI2" id="MI2">MI2</a></b>    JMP <a href="#QINT">QINT</a>     CONVERT TO INTEGER
                *--------------------------------
                *      LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
                *--------------------------------
E11E- A5 14     <b><a name="ARRAY" id="ARRAY">ARRAY</a></b>  LDA SUBFLG   SUBSCRIPTS GIVEN?
E120- D0 47            BNE .2       NO
                *--------------------------------
                *      PARSE THE SUBSCRIPT LIST
                *--------------------------------
E122- A5 10            LDA DIMFLG   YES
E124- 05 12            ORA VALTYP+1  SET HIGH BIT IF %
E126- 48               PHA          SAVE VALTYP AND DIMFLG ON STACK
E127- A5 11            LDA VALTYP
E129- 48               PHA
E12A- A0 00            LDY #0       COUNT # DIMENSIONS IN Y-REG
E12C- 98        .1     TYA          SAVE #DIMS ON STACK
E12D- 48               PHA
E12E- A5 82            LDA VARNAM+1 SAVE VARIABLE NAME ON STACK
E130- 48               PHA
E131- A5 81            LDA VARNAM
E133- 48               PHA
E134- 20 02 E1         JSR <a href="#MAKINT">MAKINT</a>   EVALUATE SUBSCRIPT AS INTEGER
E137- 68               PLA          RESTORE VARIABLE NAME
E138- 85 81            STA VARNAM
E13A- 68               PLA
E13B- 85 82            STA VARNAM+1
E13D- 68               PLA          RESTORE # DIMS TO Y-REG
E13E- A8               TAY
E13F- BA               TSX          COPY VALTYP AND DIMFLG ON STACK
E140- BD 02 01         LDA STACK+2,X  TO LEAVE ROOM FOR THE SUBSCRIPT
E143- 48               PHA
E144- BD 01 01         LDA STACK+1,X
E147- 48               PHA
E148- A5 A0            LDA FAC+3    GET SUBSCRIPT VALUE AND PLACE IN THE
E14A- 9D 02 01         STA STACK+2,X   STACK WHERE VALTYP &amp; DIMFLG WERE
E14D- A5 A1            LDA FAC+4
E14F- 9D 01 01         STA STACK+1,X
E152- C8               INY          COUNT THE SUBSCRIPT
E153- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   NEXT CHAR
E156- C9 2C            CMP #','
E158- F0 D2            BEQ .1       COMMA, PARSE ANOTHER SUBSCRIPT
E15A- 84 0F            STY NUMDIM   NO MORE SUBSCRIPTS, SAVE #
E15C- 20 B8 DE         JSR <a href="#CHKCLS">CHKCLS</a>   NOW NEED ")"
E15F- 68               PLA          RESTORE VALTYPE AND DIMFLG
E160- 85 11            STA VALTYP
E162- 68               PLA
E163- 85 12            STA VALTYP+1
E165- 29 7F            AND #$7F         ISOLATE DIMFLG
E167- 85 10            STA DIMFLG
                *--------------------------------
                *      SEARCH ARRAY TABLE FOR THIS ARRAY NAME
                *--------------------------------
E169- A6 6B     .2     LDX ARYTAB   (A,X) = START OF ARRAY TABLE
E16B- A5 6C            LDA ARYTAB+1
E16D- 86 9B     .3     STX LOWTR    USE LOWTR FOR RUNNING POINTER
E16F- 85 9C            STA LOWTR+1
E171- C5 6E            CMP STREND+1 DID WE REACH THE END OF ARRAYS YET?
E173- D0 04            BNE .4       NO, KEEP SEARCHING
E175- E4 6D            CPX STREND
E177- F0 3F            BEQ <a href="#MAKE.NEW.ARRAY">MAKE.NEW.ARRAY</a>  YES, THIS IS A NEW ARRAY NAME
E179- A0 00     .4     LDY #0       POINT AT 1ST CHAR OF ARRAY NAME
E17B- B1 9B            LDA (LOWTR),Y     GET 1ST CHAR OF NAME
E17D- C8               INY          POINT AT 2ND CHAR
E17E- C5 81            CMP VARNAM   1ST CHAR SAME?
E180- D0 06            BNE .5       NO, MOVE TO NEXT ARRAY
E182- A5 82            LDA VARNAM+1 YES, TRY 2ND CHAR
E184- D1 9B            CMP (LOWTR),Y     SAME?
E186- F0 16            BEQ <a href="#USE.OLD.ARRAY">USE.OLD.ARRAY</a> YES, ARRAY FOUND
E188- C8        .5     INY          POINT AT OFFSET TO NEXT ARRAY
E189- B1 9B            LDA (LOWTR),Y     ADD OFFSET TO RUNNING POINTER
E18B- 18               CLC
E18C- 65 9B            ADC LOWTR
E18E- AA               TAX
E18F- C8               INY
E190- B1 9B            LDA (LOWTR),Y
E192- 65 9C            ADC LOWTR+1
E194- 90 D7            BCC .3       ...ALWAYS
                *--------------------------------
                *      ERROR:  BAD SUBSCRIPTS
                *--------------------------------
E196- A2 6B     <b><a name="SUBERR" id="SUBERR">SUBERR</a></b> LDX #ERR.BADSUBS
E198- 2C               .HS 2C       TRICK TO SKIP NEXT LINE
                *--------------------------------
                *      ERROR:  ILLEGAL QUANTITY
                *--------------------------------
E199- A2 35     <b><a name="IQERR" id="IQERR">IQERR</a></b>  LDX #ERR.ILLQTY
E19B- 4C 12 D4  <b><a name="JER" id="JER">JER</a></b>    JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
                *      FOUND THE ARRAY
                *--------------------------------
                <b><a name="USE.OLD.ARRAY" id="USE.OLD.ARRAY">USE.OLD.ARRAY</a></b>
E19E- A2 78            LDX #ERR.REDIMD   SET UP FOR REDIM'D ARRAY ERROR
E1A0- A5 10            LDA DIMFLG        CALLED FROM "DIM" STATEMENT?
E1A2- D0 F7            BNE <a href="#JER">JER</a>           YES, ERROR
E1A4- A5 14            LDA SUBFLG        NO, CHECK IF ANY SUBSCRIPTS
E1A6- F0 02            BEQ .1            YES, NEED TO CHECK THE NUMBER
E1A8- 38               SEC               NO, SIGNAL ARRAY FOUND
E1A9- 60               RTS
                *--------------------------------
E1AA- 20 ED E0  .1     JSR <a href="#GETARY">GETARY</a>     SET (ARYPNT) = ADDR OF FIRST ELEMENT
E1AD- A5 0F            LDA NUMDIM        COMPARE NUMBER OF DIMENSIONS
E1AF- A0 04            LDY #4
E1B1- D1 9B            CMP (LOWTR),Y
E1B3- D0 E1            BNE <a href="#SUBERR">SUBERR</a>        NOT SAME, SUBSCRIPT ERROR
E1B5- 4C 4B E2         JMP <a href="#FIND.ARRAY.ELEMENT">FIND.ARRAY.ELEMENT</a>
                *--------------------------------
                *--------------------------------
                *      CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
                *--------------------------------
                <b><a name="MAKE.NEW.ARRAY" id="MAKE.NEW.ARRAY">MAKE.NEW.ARRAY</a></b>
E1B8- A5 14            LDA SUBFLG   CALLED FROM GETARYPT?
E1BA- F0 05            BEQ .1       NO
E1BC- A2 2A            LDX #ERR.NODATA   YES, GIVE "OUT OF DATA" ERROR
E1BE- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
E1C1- 20 ED E0  .1     JSR <a href="#GETARY">GETARY</a>   PUT ADDR OF 1ST ELEMENT IN ARYPNT
E1C4- 20 E3 D3         JSR <a href="#REASON">REASON</a>   MAKE SURE ENOUGH MEMORY LEFT
                *--------------------------------
                *      &lt;&lt;&lt; NEXT 3 LINES COULD BE WRITTEN:   &gt;&gt;&gt;
                *      LDY #0
                *      STY STRNG2+1
                *--------------------------------
E1C7- A9 00            LDA #0       POINT Y-REG AT VARIABLE NAME SLOT
E1C9- A8               TAY
E1CA- 85 AE            STA STRNG2+1 START SIZE COMPUTATION
E1CC- A2 05            LDX #5       ASSUME 5-BYTES PER ELEMENT
E1CE- A5 81            LDA VARNAM   STUFF VARIABLE NAME IN ARRAY
E1D0- 91 9B            STA (LOWTR),Y
E1D2- 10 01            BPL .2       NOT INTEGER ARRAY
E1D4- CA               DEX          INTEGER ARRAY, DECR. SIZE TO 4-BYTES
E1D5- C8        .2     INY          POINT Y-REG AT NEXT CHAR OF NAME
E1D6- A5 82            LDA VARNAM+1 REST OF ARRAY NAME
E1D8- 91 9B            STA (LOWTR),Y
E1DA- 10 02            BPL .3       REAL ARRAY, STICK WITH SIZE = 5 BYTES
E1DC- CA               DEX          INTEGER OR STRING ARRAY, ADJUST SIZE
E1DD- CA               DEX          TO INTEGER=3, STRING=2 BYTES
E1DE- 86 AD     .3     STX STRNG2   STORE LOW-BYTE OF ARRAY ELEMENT SIZE
E1E0- A5 0F            LDA NUMDIM   STORE NUMBER OF DIMENSIONS 
E1E2- C8               INY          IN 5TH BYTE OF ARRAY
E1E3- C8               INY
E1E4- C8               INY
E1E5- 91 9B            STA (LOWTR),Y
E1E7- A2 0B     .4     LDX #11      DEFAULT DIMENSION = 11 ELEMENTS
E1E9- A9 00            LDA #0       FOR HI-BYTE OF DIMENSION IF DEFAULT
E1EB- 24 10            BIT <a href="#DIMFLG">DIMFLG</a>   DIMENSIONED ARRAY?
E1ED- 50 08            BVC .5       NO, USE DEFAULT VALUE
E1EF- 68               PLA          GET SPECIFIED DIM IN A,X
E1F0- 18               CLC          # ELEMENTS IS 1 LARGER THAN
E1F1- 69 01            ADC #1       DIMENSION VALUE
E1F3- AA               TAX
E1F4- 68               PLA
E1F5- 69 00            ADC #0
E1F7- C8        .5     INY          ADD THIS DIMENSION TO ARRAY DESCRIPTOR
E1F8- 91 9B            STA (LOWTR),Y
E1FA- C8               INY
E1FB- 8A               TXA
E1FC- 91 9B            STA (LOWTR),Y
E1FE- 20 AD E2         JSR <a href="#MULTIPLY.SUBSCRIPT">MULTIPLY.SUBSCRIPT</a>     MULTIPLY THIS
                *                   DIMENSION BY RUNNING SIZE
                *                   ((LOWTR)) * (STRNG2) --&gt; A,X
E201- 86 AD            STX STRNG2   STORE RUNNING SIZE IN STRNG2
E203- 85 AE            STA STRNG2+1
E205- A4 5E            LDY INDEX    RETRIEVE Y SAVED BY MULTIPLY.SUBSCRIPT
E207- C6 0F            DEC NUMDIM   COUNT DOWN # DIMS
E209- D0 DC            BNE .4       LOOP TILL DONE
                *--------------------------------
                *      NOW A,X HAS TOTAL # BYTES OF ARRAY ELEMENTS
                *--------------------------------
E20B- 65 95            ADC ARYPNT+1 COMPUTE ADDRESS OF END OF THIS ARRAY
E20D- B0 5D            BCS <a href="#GME">GME</a>      ...TOO LARGE, ERROR
E20F- 85 95            STA ARYPNT+1
E211- A8               TAY
E212- 8A               TXA
E213- 65 94            ADC ARYPNT
E215- 90 03            BCC .6
E217- C8               INY
E218- F0 52            BEQ <a href="#GME">GME</a>      ...TOO LARGE, ERROR
E21A- 20 E3 D3  .6     JSR <a href="#REASON">REASON</a>   MAKE SURE THERE IS ROOM UP TO Y,A
E21D- 85 6D            STA STREND   THERE IS ROOM SO SAVE NEW END OF TABLE
E21F- 84 6E            STY STREND+1      AND ZERO THE ARRAY
E221- A9 00            LDA #0
E223- E6 AE            INC STRNG2+1 PREPARE FOR FAST ZEROING LOOP
E225- A4 AD            LDY STRNG2   # BYTES MOD 256
E227- F0 05            BEQ .8       FULL PAGE
E229- 88        .7     DEY          CLEAR PAGE FULL
E22A- 91 94            STA (ARYPNT),Y
E22C- D0 FB            BNE .7
E22E- C6 95     .8     DEC ARYPNT+1 POINT TO NEXT PAGE
E230- C6 AE            DEC STRNG2+1 COUNT THE PAGES
E232- D0 F5            BNE .7       STILL MORE TO CLEAR
E234- E6 95            INC ARYPNT+1 RECOVER LAST DEC, POINT AT 1ST ELEMENT
E236- 38               SEC
E237- A5 6D            LDA STREND   COMPUTE OFFSET TO END OF ARRAYS
E239- E5 9B            SBC LOWTR    AND STORE IN ARRAY DESCRIPTOR
E23B- A0 02            LDY #2
E23D- 91 9B            STA (LOWTR),Y
E23F- A5 6E            LDA STREND+1
E241- C8               INY
E242- E5 9C            SBC LOWTR+1
E244- 91 9B            STA (LOWTR),Y
E246- A5 10            LDA DIMFLG   WAS THIS CALLED FROM "DIM" STATEMENT?
E248- D0 62            BNE <a href="#RTS.9">RTS.9</a>    YES, WE ARE FINISHED
E24A- C8               INY          NO, NOW NEED TO FIND THE ELEMENT
                *--------------------------------
                *      FIND SPECIFIED ARRAY ELEMENT
                *
                *      (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
                *      THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
                *--------------------------------
                <b><a name="FIND.ARRAY.ELEMENT" id="FIND.ARRAY.ELEMENT">FIND.ARRAY.ELEMENT</a></b>
E24B- B1 9B            LDA (LOWTR),Y     GET # OF DIMENSIONS
E24D- 85 0F            STA NUMDIM
E24F- A9 00            LDA #0       ZERO SUBSCRIPT ACCUMULATOR
E251- 85 AD            STA STRNG2
E253- 85 AE     <b><a name="FAE.1" id="FAE.1">FAE.1</a></b>  STA STRNG2+1
E255- C8               INY
E256- 68               PLA          PULL NEXT SUBSCRIPT FROM STACK
E257- AA               TAX          SAVE IN FAC+3,4
E258- 85 A0            STA FAC+3    AND COMPARE WITH DIMENSIONED SIZE
E25A- 68               PLA
E25B- 85 A1            STA FAC+4
E25D- D1 9B            CMP (LOWTR),Y
E25F- 90 0E            BCC <a href="#FAE.2">FAE.2</a>    SUBSCRIPT NOT TOO LARGE
E261- D0 06            BNE <a href="#GSE">GSE</a>      SUBSCRIPT IS TOO LARGE
E263- C8               INY          CHECK LOW-BYTE OF SUBSCRIPT
E264- 8A               TXA
E265- D1 9B            CMP (LOWTR),Y
E267- 90 07            BCC <a href="#FAE.3">FAE.3</a>    NOT TOO LARGE
                *--------------------------------
E269- 4C 96 E1  <b><a name="GSE" id="GSE">GSE</a></b>    JMP <a href="#SUBERR">SUBERR</a>   BAD SUBSCRIPTS ERROR
E26C- 4C 10 D4  <b><a name="GME" id="GME">GME</a></b>    JMP <a href="#MEMERR">MEMERR</a>   MEM FULL ERROR
                *--------------------------------
E26F- C8        <b><a name="FAE.2" id="FAE.2">FAE.2</a></b>  INY          BUMP POINTER INTO DESCRIPTOR
E270- A5 AE     <b><a name="FAE.3" id="FAE.3">FAE.3</a></b>  LDA STRNG2+1 BYPASS MULTIPLICATION IF VALUE SO
E272- 05 AD            ORA STRNG2   FAR = 0
E274- 18               CLC
E275- F0 0A            BEQ .1       IT IS ZERO SO FAR
E277- 20 AD E2         JSR <a href="#MULTIPLY.SUBSCRIPT">MULTIPLY.SUBSCRIPT</a>     NOT ZERO, SO MULTIPLY
E27A- 8A               TXA          ADD CURRENT SUBSCRIPT
E27B- 65 A0            ADC FAC+3
E27D- AA               TAX
E27E- 98               TYA
E27F- A4 5E            LDY INDEX    RETRIEVE Y SAVED BY MULTIPLY.SUBSCRIPT
E281- 65 A1     .1     ADC FAC+4    FINISH ADDING CURRENT SUBSCRIPT
E283- 86 AD            STX STRNG2   STORE ACCUMULATED OFFSET
E285- C6 0F            DEC NUMDIM   LAST SUBSCRIPT YET?
E287- D0 CA            BNE <a href="#FAE.1">FAE.1</a>    NO, LOOP TILL DONE
E289- 85 AE            STA STRNG2+1 YES, NOW MULTIPLY BE ELEMENT SIZE
E28B- A2 05            LDX #5       START WITH SIZE = 5
E28D- A5 81            LDA VARNAM   DETERMINE VARIABLE TYPE
E28F- 10 01            BPL .2       NOT INTEGER
E291- CA               DEX          INTEGER, BACK DOWN SIZE TO 4 BYTES
E292- A5 82     .2     LDA VARNAM+1 DISCRIMINATE BETWEEN REAL AND STR
E294- 10 02            BPL .3       IT IS REAL
E296- CA               DEX          SIZE = 3 IF STRING, =2 IF INTEGER
E297- CA               DEX
E298- 86 64     .3     STX RESULT+2 SET UP MULTIPLIER
E29A- A9 00            LDA #0       HI-BYTE OF MULTIPLIER
E29C- 20 B6 E2         JSR <a href="#MULTIPLY.SUBS.1">MULTIPLY.SUBS.1</a>   (STRNG2) BY ELEMENT SIZE
E29F- 8A               TXA          ADD ACCUMULATED OFFSET
E2A0- 65 94            ADC ARYPNT   TO ADDRESS OF 1ST ELEMENT
E2A2- 85 83            STA VARPNT   TO GET ADDRESS OF SPECIFIED ELEMENT
E2A4- 98               TYA
E2A5- 65 95            ADC ARYPNT+1
E2A7- 85 84            STA VARPNT+1
E2A9- A8               TAY          RETURN WITH ADDR IN VARPNT
E2AA- A5 83            LDA VARPNT        AND IN Y,A
E2AC- 60        <b><a name="RTS.9" id="RTS.9">RTS.9</a></b>  RTS
                *--------------------------------
                *      MULTIPLY (STRNG2) BY ((LOWTR),Y)
                *      LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
                *      USED ONLY BY ARRAY SUBSCRIPT ROUTINES
                *--------------------------------
E2AD- 84 5E     <b><a name="MULTIPLY.SUBSCRIPT" id="MULTIPLY.SUBSCRIPT">MULTIPLY.SUBSCRIPT</a></b>   STY INDEX    SAVE Y-REG
E2AF- B1 9B            LDA (LOWTR),Y     GET MULTIPLIER
E2B1- 85 64            STA RESULT+2      SAVE IN RESULT+2,3
E2B3- 88               DEY
E2B4- B1 9B            LDA (LOWTR),Y
                *--------------------------------
                <b><a name="MULTIPLY.SUBS.1" id="MULTIPLY.SUBS.1">MULTIPLY.SUBS.1</a></b>
E2B6- 85 65            STA RESULT+3      LOW BYTE OF MULTIPLIER
E2B8- A9 10            LDA #16      MULTIPLY 16 BITS
E2BA- 85 99            STA INDX
E2BC- A2 00            LDX #0       PRODUCT = 0 INITIALLY
E2BE- A0 00            LDY #0
E2C0- 8A        .1     TXA          DOUBLE PRODUCT
E2C1- 0A               ASL          LOW BYTE
E2C2- AA               TAX
E2C3- 98               TYA          HIGH BYTE
E2C4- 2A               ROL          IF TOO LARGE, SET CARRY
E2C5- A8               TAY
E2C6- B0 A4            BCS <a href="#GME">GME</a>      TOO LARGE, "MEM FULL ERROR"
E2C8- 06 AD            ASL STRNG2   NEXT BIT OF MUTLPLICAND
E2CA- 26 AE            ROL STRNG2+1      INTO CARRY
E2CC- 90 0B            BCC .2       BIT=0, DON'T NEED TO ADD
E2CE- 18               CLC          BIT=1, ADD INTO PARTIAL PRODUCT
E2CF- 8A               TXA
E2D0- 65 64            ADC RESULT+2
E2D2- AA               TAX
E2D3- 98               TYA
E2D4- 65 65            ADC RESULT+3
E2D6- A8               TAY
E2D7- B0 93            BCS <a href="#GME">GME</a>      TOO LARGE, "MEM FULL ERROR"
E2D9- C6 99     .2     DEC INDX     16-BITS YET?
E2DB- D0 E3            BNE .1       NO, KEEP SHUFFLING
E2DD- 60               RTS          YES, PRODUCT IN Y,X AND A,X
                *--------------------------------
                *      "FRE" FUNCTION
                *
                *      COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
                *--------------------------------
E2DE- A5 11     <b><a name="FRE" id="FRE">FRE</a></b>    LDA VALTYP   LOOK AT VALUE OF ARGUMENT
E2E0- F0 03            BEQ .1       =0 MEANS REAL, =$FF MEANS STRING
E2E2- 20 00 E6         JSR <a href="#FREFAC">FREFAC</a>   STRING, SO SET IT FREE IS TEMP
E2E5- 20 84 E4  .1     JSR <a href="#GARBAG">GARBAG</a>   COLLECT ALL THE GARBAGE IN SIGHT
E2E8- 38               SEC          COMPUTE SPACE BETWEEN ARRAYS AND
E2E9- A5 6F            LDA FRETOP   STRING TEMP AREA
E2EB- E5 6D            SBC STREND
E2ED- A8               TAY
E2EE- A5 70            LDA FRETOP+1
E2F0- E5 6E            SBC STREND+1 FREE SPACE IN Y,A
                *      FALL INTO GIVAYF TO FLOAT THE VALUE
                *      NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
                *--------------------------------
                *      FLOAT THE SIGNED INTEGER IN A,Y
                *--------------------------------
E2F2- A2 00     <b><a name="GIVAYF" id="GIVAYF">GIVAYF</a></b> LDX #0       MARK FAC VALUE TYPE REAL
E2F4- 86 11            STX VALTYP
E2F6- 85 9E            STA FAC+1    SAVE VALUE FROM A,Y IN MANTISSA
E2F8- 84 9F            STY FAC+2
E2FA- A2 90            LDX #$90     SET EXPONENT TO 2^16
E2FC- 4C 9B EB         JMP <a href="#FLOAT.1">FLOAT.1</a>  CONVERT TO SIGNED FP
                *--------------------------------
                *      "POS" FUNCTION
                *
                *      RETURNS CURRENT LINE POSITION FROM MON.CH
                *--------------------------------
E2FF- A4 24     <b><a name="POS" id="POS">POS</a></b>    LDY MON.CH   GET A,Y = (MON.CH, GO TO GIVAYF
                *--------------------------------
                *      FLOAT (Y) INTO FAC, GIVING VALUE 0-255
                *--------------------------------
E301- A9 00     <b><a name="SNGFLT" id="SNGFLT">SNGFLT</a></b> LDA #0       MSB = 0
E303- 38               SEC          &lt;&lt;&lt; NO PURPOSE WHATSOEVER &gt;&gt;&gt;
E304- F0 EC            BEQ <a href="#GIVAYF">GIVAYF</a>   ...ALWAYS
                *--------------------------------
                *      CHECK FOR DIRECT OR RUNNING MODE
                *      GIVING ERROR IF DIRECT MODE
                *--------------------------------
E306- A6 76     <b><a name="ERRDIR" id="ERRDIR">ERRDIR</a></b> LDX CURLIN+1 =$FF IF DIRECT MODE
E308- E8               INX          MAKES $FF INTO ZERO
E309- D0 A1            BNE <a href="#RTS.9">RTS.9</a>    RETURN IF RUNNING MODE
E30B- A2 95            LDX #ERR.ILLDIR   DIRECT MODE, GIVE ERROR
E30D- 2C               .HS 2C       TRICK TO SKIP NEXT 2 BYTES
                *--------------------------------
E30E- A2 E0     <b><a name="UNDFNC" id="UNDFNC">UNDFNC</a></b> LDX #ERR.UNDEFFUNC  UNDEFINDED FUNCTION ERROR
E310- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
                *      "DEF" STATEMENT
                *--------------------------------
E313- 20 41 E3  <b><a name="DEF" id="DEF">DEF</a></b>    JSR <a href="#FNC.">FNC.</a>     PARSE "FN", FUNCTION NAME
E316- 20 06 E3         JSR <a href="#ERRDIR">ERRDIR</a>   ERROR IF IN DIRECT MODE
E319- 20 BB DE         JSR <a href="#CHKOPN">CHKOPN</a>   NEED "("
E31C- A9 80            LDA #$80     FLAG PTRGET THAT CALLED FROM "DEF FN"
E31E- 85 14            STA SUBFLG   ALLOW ONLY SIMPLE FP VARIABLE FOR ARG
E320- 20 E3 DF         JSR <a href="#PTRGET">PTRGET</a>   GET PNTR TO ARGUMENT
E323- 20 6A DD         JSR <a href="#CHKNUM">CHKNUM</a>   MUST BE NUMERIC
E326- 20 B8 DE         JSR <a href="#CHKCLS">CHKCLS</a>   MUST HAVE ")" NOW
E329- A9 D0            LDA #TOKEN.EQUAL  NOW NEED "="
E32B- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>   OR ELSE SYNTAX ERROR
E32E- 48               PHA          SAVE CHAR AFTER "="
E32F- A5 84            LDA VARPNT+1 SAVE PNTR TO ARGUMENT
E331- 48               PHA
E332- A5 83            LDA VARPNT
E334- 48               PHA
E335- A5 B9            LDA TXTPTR+1 SAVE TXTPTR
E337- 48               PHA
E338- A5 B8            LDA TXTPTR
E33A- 48               PHA
E33B- 20 95 D9         JSR <a href="#DATA">DATA</a>     SCAN TO NEXT STATEMENT
E33E- 4C AF E3         JMP <a href="#FNCDATA">FNCDATA</a>  STORE ABOVE 5 BYTES IN "VALUE"
                *--------------------------------
                *      COMMON ROUTINE FOR "DEFFN" AND "FN", TO
                *      PARSE "FN" AND THE FUNCTION NAME
                *--------------------------------
E341- A9 C2     <b><a name="FNC." id="FNC.">FNC.</a></b>   LDA #TOKEN.FN     MUST NOW SEE "FN" TOKEN
E343- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>        OR ELSE SYNTAX ERROR
E346- 09 80            ORA #$80     SET SIGN BIT ON 1ST CHAR OF NAME,
E348- 85 14            STA SUBFLG   MAKING $C0 &lt; SUBFLG &lt; $DB
E34A- 20 EA DF         JSR <a href="#PTRGET3">PTRGET3</a>  WHICH TELLS PTRGET WHO CALLED
E34D- 85 8A            STA FNCNAM   FOUND VALID FUNCTION NAME, SO
E34F- 84 8B            STY FNCNAM+1      SAVE ADDRESS
E351- 4C 6A DD         JMP <a href="#CHKNUM">CHKNUM</a>   MUST BE NUMERIC
                *--------------------------------
                *      "FN" FUNCTION CALL
                *--------------------------------
E354- 20 41 E3  <b><a name="FUNCT" id="FUNCT">FUNCT</a></b>  JSR <a href="#FNC.">FNC.</a>     PARSE "FN", FUNCTION NAME
E357- A5 8B            LDA FNCNAM+1 STACK FUNCTION ADDRESS
E359- 48               PHA               IN CASE OF A NESTED FN CALL
E35A- A5 8A            LDA FNCNAM
E35C- 48               PHA
E35D- 20 B2 DE         JSR <a href="#PARCHK">PARCHK</a>   MUST NOW HAVE "(EXPRESSION)"
E360- 20 6A DD         JSR <a href="#CHKNUM">CHKNUM</a>   MUST BE NUMERIC EXPRESSION
E363- 68               PLA          GET FUNCTION ADDRESS BACK
E364- 85 8A            STA FNCNAM
E366- 68               PLA
E367- 85 8B            STA FNCNAM+1
E369- A0 02            LDY #2       POINT AT ADD OF ARGUMENT VARIABLE
E36B- B1 8A            LDA (FNCNAM),Y
E36D- 85 83            STA VARPNT
E36F- AA               TAX
E370- C8               INY
E371- B1 8A            LDA (FNCNAM),Y
E373- F0 99            BEQ <a href="#UNDFNC">UNDFNC</a>   UNDEFINED FUNCTION
E375- 85 84            STA VARPNT+1
E377- C8               INY          Y=4 NOW
E378- B1 83     .1     LDA (VARPNT),Y  SAVE OLD VALUE OF ARGUMENT VARIABLE
E37A- 48               PHA             ON STACK, IN CASE ALSO USED AS
E37B- 88               DEY             A NORMAL VARIABLE!
E37C- 10 FA            BPL .1
E37E- A4 84            LDY VARPNT+1 (Y,X)= ADDRESS, STORE FAC IN VARIABLE
E380- 20 2B EB         JSR <a href="#STORE.FAC.AT.YX.ROUNDED">STORE.FAC.AT.YX.ROUNDED</a>
E383- A5 B9            LDA TXTPTR+1 REMEMBER TXTPTR AFTER FN CALL
E385- 48               PHA
E386- A5 B8            LDA TXTPTR
E388- 48               PHA
E389- B1 8A            LDA (FNCNAM),Y  Y=0 FROM MOVMF
E38B- 85 B8            STA TXTPTR      POINT TO FUNCTION DEF'N
E38D- C8               INY
E38E- B1 8A            LDA (FNCNAM),Y
E390- 85 B9            STA TXTPTR+1
E392- A5 84            LDA VARPNT+1 SAVE ADDRESS OF ARGUMENT VARIABLE
E394- 48               PHA
E395- A5 83            LDA VARPNT
E397- 48               PHA
E398- 20 67 DD         JSR <a href="#FRMNUM">FRMNUM</a>   EVALUATE THE FUNCTION EXPRESSION
E39B- 68               PLA          GET ADDRESS OF ARGUMENT VARIABLE
E39C- 85 8A            STA FNCNAM        AND SAVE IT
E39E- 68               PLA
E39F- 85 8B            STA FNCNAM+1
E3A1- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   MUST BE AT ":" OR EOL
E3A4- F0 03            BEQ .2       WE ARE
E3A6- 4C C9 DE         JMP <a href="#SYNERR">SYNERR</a>   WE ARE NOT, SLYNTAX ERROR
E3A9- 68        .2     PLA          RETRIEVE TXTPTR AFTER "FN" CALL
E3AA- 85 B8            STA TXTPTR
E3AC- 68               PLA
E3AD- 85 B9            STA TXTPTR+1
                *                   STACK NOW HAS 5-BYTE VALUE
                *                   OF THE ARGUMENT VARIABLE,
                *                   AND FNCNAM POINTS AT THE VARIABLE
                *--------------------------------
                *      STORE FIVE BYTES FROM STACK AT (FNCNAM)
                *--------------------------------
                <b><a name="FNCDATA" id="FNCDATA">FNCDATA</a></b>
E3AF- A0 00            LDY #0
E3B1- 68               PLA
E3B2- 91 8A            STA (FNCNAM),Y
E3B4- 68               PLA
E3B5- C8               INY
E3B6- 91 8A            STA (FNCNAM),Y
E3B8- 68               PLA
E3B9- C8               INY
E3BA- 91 8A            STA (FNCNAM),Y
E3BC- 68               PLA
E3BD- C8               INY
E3BE- 91 8A            STA (FNCNAM),Y
E3C0- 68               PLA
E3C1- C8               INY
E3C2- 91 8A            STA (FNCNAM),Y
E3C4- 60               RTS
                *--------------------------------
                *      "STR$" FUNCTION
                *--------------------------------
E3C5- 20 6A DD  <b><a name="STR" id="STR">STR</a></b>    JSR <a href="#CHKNUM">CHKNUM</a>   EXPRESSION MUST BE NUMERIC
E3C8- A0 00            LDY #0       START STRING AT STACK-1 ($00FF)
                *                   SO STRLIT CAN DIFFRENTIATE STR$ CALLS
E3CA- 20 36 ED         JSR <a href="#FOUT.1">FOUT.1</a>   CONVERT FAC TO STRING
E3CD- 68               PLA          POP RETURN OFF STACK
E3CE- 68               PLA
E3CF- A9 FF            LDA #STACK-1 POINT TO STACK-1
E3D1- A0 00            LDY /STACK-1 (WHICH=0)
E3D3- F0 12            BEQ <a href="#STRLIT">STRLIT</a>   ...ALWAYS, CREATE DESC &amp; MOVE STRING
                *--------------------------------
                *      GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
                *      ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
                *--------------------------------
E3D5- A6 A0     <b><a name="STRINI" id="STRINI">STRINI</a></b> LDX FAC+3    Y,X = STRING ADDRESS
E3D7- A4 A1            LDY FAC+4
E3D9- 86 8C            STX DSCPTR
E3DB- 84 8D            STY DSCPTR+1
                *--------------------------------
                *      GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
                *      ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
                *--------------------------------
E3DD- 20 52 E4  <b><a name="STRSPA" id="STRSPA">STRSPA</a></b> JSR <a href="#GETSPA">GETSPA</a>   A HOLDS LENGTH
E3E0- 86 9E            STX FAC+1    SAVE DESCRIPTOR IN FAC
E3E2- 84 9F            STY FAC+2    ---FAC--- --FAC+1-- --FAC+2--
E3E4- 85 9D            STA FAC      &lt;LENGTH&gt;  &lt;ADDR-LO&gt; &lt;ADDR-HI&gt;
E3E6- 60               RTS
                *--------------------------------
                *      BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
                *      AND TERMINATED BY $00 OR QUOTATION MARK
                *      RETURN WITH DESCRIPTOR IN A TEMPORARY
                *      AND ADDRESS OF DESCRIPTOR IN FAC+3,4
                *--------------------------------
E3E7- A2 22     <b><a name="STRLIT" id="STRLIT">STRLIT</a></b> LDX #'"'     SET UP LITERAL SCAN TO STOP ON
E3E9- 86 0D            STX CHARAC   QUOTATION MARK OR $00
E3EB- 86 0E            STX ENDCHR
                *--------------------------------
                *      BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
                *      AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
                *
                *      RETURN WITH DESCRIPTOR IN A TEMPORARY
                *      AND ADDRESS OF DESCRIPTOR IN FAC+3,4
                *--------------------------------
E3ED- 85 AB     <b><a name="STRLT2" id="STRLT2">STRLT2</a></b> STA STRNG1   SAVE ADDRESS OF STRING
E3EF- 84 AC            STY STRNG1+1
E3F1- 85 9E            STA FAC+1       ...AGAIN
E3F3- 84 9F            STY FAC+2
E3F5- A0 FF            LDY #$FF
E3F7- C8        .1     INY          FIND END OF STRING
E3F8- B1 AB            LDA (STRNG1),Y    NEXT STRING CHAR
E3FA- F0 0C            BEQ .3            END OF STRING
E3FC- C5 0D            CMP CHARAC        ALTERNATE TERMINATOR # 1?
E3FE- F0 04            BEQ .2            YES
E400- C5 0E            CMP ENDCHR        ALTERNATE TERMINATOR # 2?
E402- D0 F3            BNE .1            NO, KEEP SCANNING
E404- C9 22     .2     CMP #'"'     IS STRING ENDED WITH QUOTE MARK?
E406- F0 01            BEQ .4       YES, C=1 TO INCLUDE " IN STRING
E408- 18        .3     CLC
E409- 84 9D     .4     STY FAC      SAVE LENGTH
E40B- 98               TYA
E40C- 65 AB            ADC STRNG1   COMPUTE ADDRESS OF END OF STRING
E40E- 85 AD            STA STRNG2        (OF 00 BYTE, OR JUST AFTER ")
E410- A6 AC            LDX STRNG1+1
E412- 90 01            BCC .5
E414- E8               INX
E415- 86 AE     .5     STX STRNG2+1
E417- A5 AC            LDA STRNG1+1 WHERE DOES THE STRING START?
E419- F0 04            BEQ .6       PAGE 0, MUST BE FROM STR$ FUNCTION
E41B- C9 02            CMP #2       PAGE 2?
E41D- D0 0B            BNE <a href="#PUTNEW">PUTNEW</a>   NO, NOT PAGE 0 OR 2
E41F- 98        .6     TYA          LENGTH OF STRING 
E420- 20 D5 E3         JSR <a href="#STRINI">STRINI</a>   MAKE SPACE FOR STRING
E423- A6 AB            LDX STRNG1
E425- A4 AC            LDY STRNG1+1
E427- 20 E2 E5         JSR <a href="#MOVSTR">MOVSTR</a>   MOVE IT IN
                *--------------------------------
                *      STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
                *
                *      THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
                *      PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
                *--------------------------------
E42A- A6 52     <b><a name="PUTNEW" id="PUTNEW">PUTNEW</a></b> LDX TEMPPT   POINTER TO NEXT TEMP STRING SLOT
E42C- E0 5E            CPX #TEMPST+9     MAX OF 3 TEMP STRINGS
E42E- D0 05            BNE <a href="#PUTEMP">PUTEMP</a>        ROOM FOR ANOTHER ONE
E430- A2 BF            LDX #ERR.FRMCPX   TOO MANY, FORMULA TOO COMPLEX
E432- 4C 12 D4  <b><a name="JERR" id="JERR">JERR</a></b>   JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
E435- A5 9D     <b><a name="PUTEMP" id="PUTEMP">PUTEMP</a></b> LDA FAC      COPY TEMP DESCRIPTOR INTO TEMP STACK
E437- 95 00            STA 0,X
E439- A5 9E            LDA FAC+1
E43B- 95 01            STA 1,X
E43D- A5 9F            LDA FAC+2
E43F- 95 02            STA 2,X
E441- A0 00            LDY #0
E443- 86 A0            STX FAC+3    ADDRESS OF TEMP DESCRIPTOR
E445- 84 A1            STY FAC+4    IN Y,X AND FAC+3,4
E447- 88               DEY          Y=$FF
E448- 84 11            STY VALTYP   FLAG (FAC ) AS STRING
E44A- 86 53            STX LASTPT   INDEX OF LAST POINTER
E44C- E8               INX          UPDATE FOR NEXT TEMP ENTRY
E44D- E8               INX
E44E- E8               INX
E44F- 86 52            STX TEMPPT
E451- 60               RTS
                *--------------------------------
                *      MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
                *      (A)=# BYTES SPACE TO MAKE
                *
                *      RETURN WITH (A) SAME,
                *             AND Y,X = ADDRESS OF SPACE ALLOCATED
                *--------------------------------
E452- 46 13     <b><a name="GETSPA" id="GETSPA">GETSPA</a></b> LSR GARFLG   CLEAR SIGNBIT OF FLAG
E454- 48        .1     PHA          A HOLDS LENGTH
E455- 49 FF            EOR #$FF     GET -LENGTH
E457- 38               SEC
E458- 65 6F            ADC FRETOP   COMPUTE STARTING ADDRESS OF SPACE
E45A- A4 70            LDY FRETOP+1      FOR THE STRING
E45C- B0 01            BCS .2
E45E- 88               DEY
E45F- C4 6E     .2     CPY STREND+1      SEE IF FITS IN REMAINING MEMORY
E461- 90 11            BCC .4            NO, TRY GARBAGE
E463- D0 04            BNE .3            YES, IT FITS
E465- C5 6D            CMP STREND        HAVE TO CHECK LOWER BYTES
E467- 90 0B            BCC .4            NOT ENUF ROOM YET
E469- 85 6F     .3     STA FRETOP   THERE IS ROOM SO SAVE NEW FRETOP
E46B- 84 70            STY FRETOP+1
E46D- 85 71            STA FRESPC
E46F- 84 72            STY FRESPC+1
E471- AA               TAX          ADDR IN Y,X
E472- 68               PLA          LENGTH IN A
E473- 60               RTS
E474- A2 4D     .4     LDX #ERR.MEMFULL
E476- A5 13            LDA GARFLG   GARBAGE DONE YET?
E478- 30 B8            BMI <a href="#JERR">JERR</a>     YES, MEMORY IS REALLY FULL
E47A- 20 84 E4         JSR <a href="#GARBAG">GARBAG</a>   NO, TRY COLLECTING NOW
E47D- A9 80            LDA #$80     FLAG THAT COLLECTED GARBAGE ALREADY
E47F- 85 13            STA GARFLG
E481- 68               PLA          GET STRING LENGTH AGAIN
E482- D0 D0            BNE .1       ...ALWAYS
                *--------------------------------
                *      SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
                *      IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
                *      BELOW STRING AREA DOWN TO STREND.
                *--------------------------------
E484- A6 73     <b><a name="GARBAG" id="GARBAG">GARBAG</a></b> LDX MEMSIZ   COLLECT FROM TOP DOWN
E486- A5 74            LDA MEMSIZ+1
                <b><a name="FIND.HIGHEST.STRING" id="FIND.HIGHEST.STRING">FIND.HIGHEST.STRING</a></b>
E488- 86 6F            STX FRETOP   ONE PASS THROUGH ALL VARS
E48A- 85 70            STA FRETOP+1   FOR EACH ACTIVE STRING!
E48C- A0 00            LDY #0
E48E- 84 8B            STY FNCNAM+1 FLAG IN CASE NO STRINGS TO COLLECT
E490- A5 6D            LDA STREND
E492- A6 6E            LDX STREND+1
E494- 85 9B            STA LOWTR
E496- 86 9C            STX LOWTR+1
                *--------------------------------
                *      START BY COLLECTING TEMPORARIES
                *--------------------------------
E498- A9 55            LDA #TEMPST
E49A- A2 00            LDX /TEMPST
E49C- 85 5E            STA INDEX
E49E- 86 5F            STX INDEX+1
E4A0- C5 52     .1     CMP TEMPPT   FINISHED WITH TEMPS YET?
E4A2- F0 05            BEQ .2       YES, NOW DO SIMPLE VARIABLES
E4A4- 20 23 E5         JSR <a href="#CHECK.VARIABLE">CHECK.VARIABLE</a>     DO A TEMP
E4A7- F0 F7            BEQ .1       ...ALWAYS
                *--------------------------------
                *      NOW COLLECT SIMPLE VARIABLES
                *--------------------------------
E4A9- A9 07     .2     LDA #7       LENGTH OF EACH VARIABLE IS 7 BYTES
E4AB- 85 8F            STA DSCLEN
E4AD- A5 69            LDA VARTAB   START AT BEGINNING OF VARTAB
E4AF- A6 6A            LDX VARTAB+1
E4B1- 85 5E            STA INDEX
E4B3- 86 5F            STX INDEX+1
E4B5- E4 6C     .3     CPX ARYTAB+1   FINISHED WITH SIMPLE VARIABLES?
E4B7- D0 04            BNE .4         NO
E4B9- C5 6B            CMP ARYTAB     MAYBE, CHECK LO-BYTE
E4BB- F0 05            BEQ .5         YES, NOW DO ARRAYS
E4BD- 20 19 E5  .4     JSR <a href="#CHECK.SIMPLE.VARIABLE">CHECK.SIMPLE.VARIABLE</a>
E4C0- F0 F3            BEQ .3       ...ALWAYS
                *--------------------------------
                *      NOW COLLECT ARRAY VARIABLES
                *--------------------------------
E4C2- 85 94     .5     STA ARYPNT
E4C4- 86 95            STX ARYPNT+1
E4C6- A9 03            LDA #3       DESCRIPTORS IN ARRAYS ARE 3-BYTES EACH
E4C8- 85 8F            STA DSCLEN
E4CA- A5 94     .6     LDA ARYPNT   COMPARE TO END OF ARRAYS
E4CC- A6 95            LDX ARYPNT+1
E4CE- E4 6E     .7     CPX STREND+1 FINISHED WITH ARRAYS YET?
E4D0- D0 07            BNE .8       NOT YET
E4D2- C5 6D            CMP STREND   MAYBE, CHECK LO-BYTE
E4D4- D0 03            BNE .8       NOT FINISHED YET
E4D6- 4C 62 E5         JMP <a href="#MOVE.HIGHEST.STRING.TO.TOP">MOVE.HIGHEST.STRING.TO.TOP</a>   FINISHED
E4D9- 85 5E     .8     STA INDEX    SET UP PNTR TO START OF ARRAY
E4DB- 86 5F            STX INDEX+1
E4DD- A0 00            LDY #0       POINT AT NAME OF ARRAY
E4DF- B1 5E            LDA (INDEX),Y
E4E1- AA               TAX          1ST LETTER OF NAME IN X-REG
E4E2- C8               INY
E4E3- B1 5E            LDA (INDEX),Y
E4E5- 08               PHP          STATUS FROM SECOND LETTER OF NAME
E4E6- C8               INY
E4E7- B1 5E            LDA (INDEX),Y     OFFSET TO NEXT ARRAY
E4E9- 65 94            ADC ARYPNT        (CARRY ALWAYS CLEAR)
E4EB- 85 94            STA ARYPNT        CALCULATE START OF NEXT ARRAY
E4ED- C8               INY
E4EE- B1 5E            LDA (INDEX),Y     HI-BYTE OF OFFSET
E4F0- 65 95            ADC ARYPNT+1
E4F2- 85 95            STA ARYPNT+1
E4F4- 28               PLP               GET STATUS FROM 2ND CHAR OF NAME
E4F5- 10 D3            BPL .6            NOT A STRING ARRAY
E4F7- 8A               TXA               SET STATUS WITH 1ST CHAR OF NAME
E4F8- 30 D0            BMI .6            NOT A STRING ARRAY
E4FA- C8               INY
E4FB- B1 5E            LDA (INDEX),Y     # OF DIMENSIONS FOR THIS ARRAY
E4FD- A0 00            LDY #0
E4FF- 0A               ASL          PREAMBLE SIZE = 2*#DIMS + 5
E500- 69 05            ADC #5
E502- 65 5E            ADC INDEX    MAKE INDEX POINT AT FIRST ELEMENT
E504- 85 5E            STA INDEX         IN THE ARRAY
E506- 90 02            BCC .9
E508- E6 5F            INC INDEX+1
                .9
E50A- A6 5F            LDX INDEX+1   STEP THRU EACH STRING IN THIS ARRAY
E50C- E4 95     .10    CPX ARYPNT+1  ARRAY DONE?
E50E- D0 04            BNE .11       NO, PROCESS NEXT ELEMENT
E510- C5 94            CMP ARYPNT    MAYBE, CHECK LO-BYTE
E512- F0 BA            BEQ .7        YES, MOVE TO NEXT ARRAY
E514- 20 23 E5  .11    JSR <a href="#CHECK.VARIABLE">CHECK.VARIABLE</a>     PROCESS THE ARRAY
E517- F0 F3            BEQ .10      ...ALWAYS
                *--------------------------------
                *      PROCESS A SIMPLE VARIABLE
                *--------------------------------
                <b><a name="CHECK.SIMPLE.VARIABLE" id="CHECK.SIMPLE.VARIABLE">CHECK.SIMPLE.VARIABLE</a></b>
E519- B1 5E            LDA (INDEX),Y     LOOK AT 1ST CHAR OF NAME
E51B- 30 35            BMI <a href="#CHECK.BUMP">CHECK.BUMP</a>    NOT A STRING VARIABLE
E51D- C8               INY
E51E- B1 5E            LDA (INDEX),Y     LOOK AT 2ND CHAR OF NAME
E520- 10 30            BPL <a href="#CHECK.BUMP">CHECK.BUMP</a>    NOT A STRING VARIABLE
E522- C8               INY
                *--------------------------------
                *      IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
                *--------------------------------
                <b><a name="CHECK.VARIABLE" id="CHECK.VARIABLE">CHECK.VARIABLE</a></b>
E523- B1 5E            LDA (INDEX),Y     GET LENGTH OF STRING
E525- F0 2B            BEQ <a href="#CHECK.BUMP">CHECK.BUMP</a>    IGNORE STRING IF LENGTH IS ZERO
E527- C8               INY
E528- B1 5E            LDA (INDEX),Y     GET ADDRESS OF STRING
E52A- AA               TAX
E52B- C8               INY
E52C- B1 5E            LDA (INDEX),Y
E52E- C5 70            CMP FRETOP+1      CHECK IF ALREADY COLLECTED
E530- 90 06            BCC .1            NO, BELOW FRETOP
E532- D0 1E            BNE <a href="#CHECK.BUMP">CHECK.BUMP</a>    YES, ABOVE FRETOP
E534- E4 6F            CPX FRETOP        MAYBE, CHECK LO-BYTE
E536- B0 1A            BCS <a href="#CHECK.BUMP">CHECK.BUMP</a>    YES, ABOVE FRETOP
E538- C5 9C     .1     CMP LOWTR+1       ABOVE HIGHEST STRING FOUND?
E53A- 90 16            BCC <a href="#CHECK.BUMP">CHECK.BUMP</a>    NO, IGNORE FOR NOW
E53C- D0 04            BNE .2            YES, THIS IS THE NEW HIGHEST
E53E- E4 9B            CPX LOWTR         MAYBE, TRY LO-BYTE
E540- 90 10            BCC <a href="#CHECK.BUMP">CHECK.BUMP</a>    NO, IGNORE FOR NOW
E542- 86 9B     .2     STX LOWTR    MAKE THIS THE HIGHEST STRING
E544- 85 9C            STA LOWTR+1
E546- A5 5E            LDA INDEX    SAVE ADDRESS OF DESCRIPTOR TOO
E548- A6 5F            LDX INDEX+1
E54A- 85 8A            STA FNCNAM
E54C- 86 8B            STX FNCNAM+1
E54E- A5 8F            LDA DSCLEN
E550- 85 91            STA LENGTH
                *--------------------------------
                *      ADD (DSCLEN) TO PNTR IN INDEX
                *      RETURN WITH Y=0, PNTR ALSO IN X,A
                *--------------------------------
                <b><a name="CHECK.BUMP" id="CHECK.BUMP">CHECK.BUMP</a></b>
E552- A5 8F            LDA DSCLEN   BUMP TO NEXT VARIABLE
E554- 18               CLC
E555- 65 5E            ADC INDEX
E557- 85 5E            STA INDEX
E559- 90 02            BCC <a href="#CHECK.EXIT">CHECK.EXIT</a>
E55B- E6 5F            INC INDEX+1
                *--------------------------------
                <b><a name="CHECK.EXIT" id="CHECK.EXIT">CHECK.EXIT</a></b>
E55D- A6 5F            LDX INDEX+1
E55F- A0 00            LDY #0
E561- 60               RTS
                *--------------------------------
                *      FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
                *      TO TOP AND GO BACK FOR ANOTHER
                *--------------------------------
                <b><a name="MOVE.HIGHEST.STRING.TO.TOP" id="MOVE.HIGHEST.STRING.TO.TOP">MOVE.HIGHEST.STRING.TO.TOP</a></b>
E562- A6 8B            LDX FNCNAM+1 ANY STRING FOUND?
E564- F0 F7            BEQ <a href="#CHECK.EXIT">CHECK.EXIT</a>    NO, RETURN
E566- A5 91            LDA LENGTH   GET LENGTH OF VARIABLE ELEMENT
E568- 29 04            AND #4       WAS 7 OR 3, MAKE 4 OR 0
E56A- 4A               LSR          2 0R 0; IN SIMPLE VARIABLES,
E56B- A8               TAY          NAME PRECEDES DESCRIPTOR
E56C- 85 91            STA LENGTH   2 OR 0
E56E- B1 8A            LDA (FNCNAM),Y    GET LENGTH FROM DESCRIPTOR
E570- 65 9B            ADC LOWTR         CARRY ALREADY CLEARED BY LSR
E572- 85 96            STA HIGHTR   STRING IS BTWN (LOWTR) AND (HIGHTR)
E574- A5 9C            LDA LOWTR+1
E576- 69 00            ADC #0
E578- 85 97            STA HIGHTR+1
E57A- A5 6F            LDA FRETOP   HIGH END DESTINATION
E57C- A6 70            LDX FRETOP+1
E57E- 85 94            STA HIGHDS
E580- 86 95            STX HIGHDS+1
E582- 20 9A D3         JSR <a href="#BLTU2">BLTU2</a>    MOVE STRING UP
E585- A4 91            LDY LENGTH   FIX ITS DESCRIPTOR
E587- C8               INY          POINT AT ADDRESS IN DESCRIPTOR
E588- A5 94            LDA HIGHDS   STORE NEW ADDRESS
E58A- 91 8A            STA (FNCNAM),Y
E58C- AA               TAX
E58D- E6 95            INC HIGHDS+1 CORRECT BLTU'S OVERSHOOT
E58F- A5 95            LDA HIGHDS+1
E591- C8               INY
E592- 91 8A            STA (FNCNAM),Y
E594- 4C 88 E4         JMP <a href="#FIND.HIGHEST.STRING">FIND.HIGHEST.STRING</a>
                *--------------------------------
                *--------------------------------
                *      CONCATENATE TWO STRINGS
                *--------------------------------
E597- A5 A1     <b><a name="CAT" id="CAT">CAT</a></b>    LDA FAC+4    SAVE ADDRESS OF FIRST DESCRIPTOR
E599- 48               PHA
E59A- A5 A0            LDA FAC+3
E59C- 48               PHA
E59D- 20 60 DE         JSR <a href="#FRM.ELEMENT">FRM.ELEMENT</a>   GET SECOND STRING ELEMENT
E5A0- 20 6C DD         JSR <a href="#CHKSTR">CHKSTR</a>        MUST BE A STRING
E5A3- 68               PLA               RECOVER ADDRES OF 1ST DESCRIPTOR
E5A4- 85 AB            STA STRNG1
E5A6- 68               PLA
E5A7- 85 AC            STA STRNG1+1
E5A9- A0 00            LDY #0
E5AB- B1 AB            LDA (STRNG1),Y   ADD LENGTHS, GET CONCATENATED SIZE
E5AD- 18               CLC
E5AE- 71 A0            ADC (FAC+3),Y
E5B0- 90 05            BCC .1            OK IF &lt; $100
E5B2- A2 B0            LDX #ERR.STRLONG
E5B4- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
E5B7- 20 D5 E3  .1     JSR <a href="#STRINI">STRINI</a>   GET SPACE FOR CONCATENATED STRINGS
E5BA- 20 D4 E5         JSR <a href="#MOVINS">MOVINS</a>   MOVE 1ST STRING
E5BD- A5 8C            LDA DSCPTR
E5BF- A4 8D            LDY DSCPTR+1
E5C1- 20 04 E6         JSR <a href="#FRETMP">FRETMP</a>
E5C4- 20 E6 E5         JSR <a href="#MOVSTR.1">MOVSTR.1</a> MOVE 2ND STRING
E5C7- A5 AB            LDA STRNG1
E5C9- A4 AC            LDY STRNG1+1
E5CB- 20 04 E6         JSR <a href="#FRETMP">FRETMP</a>
E5CE- 20 2A E4         JSR <a href="#PUTNEW">PUTNEW</a>   SET UP DESCRIPTOR
E5D1- 4C 95 DD         JMP <a href="#FRMEVL.2">FRMEVL.2</a> FINISH EXPRESSION
                *--------------------------------
                *      GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
                *      AND MOVE DESCRIBED STRING TO (FRESPC)
                *--------------------------------
E5D4- A0 00     <b><a name="MOVINS" id="MOVINS">MOVINS</a></b> LDY #0
E5D6- B1 AB            LDA (STRNG1),Y
E5D8- 48               PHA          LENGTH
E5D9- C8               INY
E5DA- B1 AB            LDA (STRNG1),Y
E5DC- AA               TAX          PUT STRING POINTER IN X,Y
E5DD- C8               INY
E5DE- B1 AB            LDA (STRNG1),Y
E5E0- A8               TAY
E5E1- 68               PLA          RETRIEVE LENGTH
                *--------------------------------
                *      MOVE STRING AT (Y,X) WITH LENGTH (A)
                *      TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
                *--------------------------------
E5E2- 86 5E     <b><a name="MOVSTR" id="MOVSTR">MOVSTR</a></b> STX INDEX    PUT POINTER IN INDEX
E5E4- 84 5F            STY INDEX+1
                <b><a name="MOVSTR.1" id="MOVSTR.1">MOVSTR.1</a></b>
E5E6- A8               TAY          LENGTH TO Y-REG
E5E7- F0 0A            BEQ .2       IF LENGTH IS ZERO, FINISHED
E5E9- 48               PHA          SAVE LENGTH ON STACK
E5EA- 88        .1     DEY          MOVE BYTES FROM (INDEX) TO (FRESPC)
E5EB- B1 5E            LDA (INDEX),Y
E5ED- 91 71            STA (FRESPC),Y
E5EF- 98               TYA          TEST IF ANY LEFT TO MOVE
E5F0- D0 F8            BNE .1       YES, KEEP MOVING
E5F2- 68               PLA          NO, FINISHED.  GET LENGTH
E5F3- 18        .2     CLC          AND ADD TO FRESPC, SO
E5F4- 65 71            ADC FRESPC   FRESPC POINTS TO NEXT HIGHER
E5F6- 85 71            STA FRESPC   BYTE.  (USED BY CONCATENATION)
E5F8- 90 02            BCC .3
E5FA- E6 72            INC FRESPC+1
E5FC- 60        .3     RTS
                *--------------------------------
                *      IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
                *--------------------------------
E5FD- 20 6C DD  <b><a name="FRESTR" id="FRESTR">FRESTR</a></b> JSR <a href="#CHKSTR">CHKSTR</a>   LAST RESULT A STRING?
                *--------------------------------
                *      IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
                *      A TEMPORARY STRING, RELEASE IT.
                *--------------------------------
E600- A5 A0     <b><a name="FREFAC" id="FREFAC">FREFAC</a></b> LDA FAC+3    GET DESCRIPTOR POINTER
E602- A4 A1            LDY FAC+4
                *--------------------------------
                *      IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
                *      A TEMPORARY STRING, RELEASE IT.
                *--------------------------------
E604- 85 5E     <b><a name="FRETMP" id="FRETMP">FRETMP</a></b> STA INDEX    SAVE THE ADDRESS OF THE DESCRIPTOR
E606- 84 5F            STY INDEX+1
E608- 20 35 E6         JSR <a href="#FRETMS">FRETMS</a>   FREE DESCRIPTOR IF IT IS TEMPORARY
E60B- 08               PHP          REMEMBER IF TEMP
E60C- A0 00            LDY #0       POINT AT LENGTH OF STRING
E60E- B1 5E            LDA (INDEX),Y
E610- 48               PHA          SAVE LENGTH ON STACK
E611- C8               INY
E612- B1 5E            LDA (INDEX),Y
E614- AA               TAX          GET ADDRESS OF STRING IN Y,X
E615- C8               INY
E616- B1 5E            LDA (INDEX),Y
E618- A8               TAY
E619- 68               PLA          LENGTH IN A
E61A- 28               PLP          RETRIEVE STATUS, Z=1 IF TEMP
E61B- D0 13            BNE .2       NOT A TEMPORARY STRING
E61D- C4 70            CPY FRETOP+1      IS IT THE LOWEST STRING?
E61F- D0 0F            BNE .2            NO
E621- E4 6F            CPX FRETOP
E623- D0 0B            BNE .2            NO
E625- 48               PHA               YES, PUSH LENGTH AGAIN
E626- 18               CLC               RECOVER THE SPACE USED BY
E627- 65 6F            ADC FRETOP        THE STRING
E629- 85 6F            STA FRETOP
E62B- 90 02            BCC .1
E62D- E6 70            INC FRETOP+1
E62F- 68        .1     PLA          RETRIEVE LENGTH AGAIN
E630- 86 5E     .2     STX INDEX    ADDRESS OF STRING IN Y,X
E632- 84 5F            STY INDEX+1  LENGTH OF STRING IN A-REG
E634- 60               RTS
                *--------------------------------
                *      RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
                *--------------------------------
E635- C4 54     <b><a name="FRETMS" id="FRETMS">FRETMS</a></b> CPY LASTPT+1      COMPARE Y,A TO LATEST TEMP
E637- D0 0C            BNE .1            NOT SAME ONE, CANNOT RELEASE
E639- C5 53            CMP LASTPT
E63B- D0 08            BNE .1            NOT SAME ONE, CANNOT RELEASE
E63D- 85 52            STA TEMPPT        UPDATE TEMPT FOR NEXT TEMP
E63F- E9 03            SBC #3            BACK OFF LASTPT 
E641- 85 53            STA LASTPT
E643- A0 00            LDY #0            NOW Y,A POINTS TO TOP TEMP
E645- 60        .1     RTS          Z=0 IF NOT TEMP, Z=1 IF TEMP
                *--------------------------------
                *      "CHR$" FUNCTION
                *--------------------------------
E646- 20 FB E6  <b><a name="CHRSTR" id="CHRSTR">CHRSTR</a></b> JSR <a href="#CONINT">CONINT</a>   CONVERT ARGUMENT TO BYTE IN X
E649- 8A               TXA
E64A- 48               PHA          SAVE IT
E64B- A9 01            LDA #1       GET SPACE FOR STRING OF LENGTH 1
E64D- 20 DD E3         JSR <a href="#STRSPA">STRSPA</a>
E650- 68               PLA          RECALL THE CHARACTER
E651- A0 00            LDY #0       PUT IN STRING
E653- 91 9E            STA (FAC+1),Y
E655- 68               PLA          POP RETURN ADDRESS
E656- 68               PLA
E657- 4C 2A E4         JMP <a href="#PUTNEW">PUTNEW</a>   MAKE IT A TEMPORARY STRING
                *--------------------------------
                *      "LEFT$" FUNCTION
                *--------------------------------
                <b><a name="LEFTSTR" id="LEFTSTR">LEFTSTR</a></b>
E65A- 20 B9 E6         JSR <a href="#SUBSTRING.SETUP">SUBSTRING.SETUP</a>
E65D- D1 8C            CMP (DSCPTR),Y    COMPARE 1ST PARAMETER TO LENGTH
E65F- 98               TYA               Y=A=0
                <b><a name="SUBSTRING.1" id="SUBSTRING.1">SUBSTRING.1</a></b>
E660- 90 04            BCC .1            1ST PARAMETER SMALLER, USE IT
E662- B1 8C            LDA (DSCPTR),Y    1ST IS LONGER, USE STRING LENGTH
E664- AA               TAX               IN X-REG
E665- 98               TYA               Y=A=0 AGAIN
E666- 48        .1     PHA               PUSH LEFT END OF SUBSTRING
                <b><a name="SUBSTRING.2" id="SUBSTRING.2">SUBSTRING.2</a></b>
E667- 8A               TXA
                <b><a name="SUBSTRING.3" id="SUBSTRING.3">SUBSTRING.3</a></b>
E668- 48               PHA               PUSH LENGTH OF SUBSTRING
E669- 20 DD E3         JSR <a href="#STRSPA">STRSPA</a>        MAKE ROOM FOR STRING OF (A) BYTES
E66C- A5 8C            LDA DSCPTR        RELEASE PARAMETER STRING IF TEMP
E66E- A4 8D            LDY DSCPTR+1
E670- 20 04 E6         JSR <a href="#FRETMP">FRETMP</a>
E673- 68               PLA               GET LENGTH OF SUBSTRING
E674- A8               TAY               IN Y-REG
E675- 68               PLA               GET LEFT END OF SUBSTRING
E676- 18               CLC               ADD TO POINTER TO STRING
E677- 65 5E            ADC INDEX
E679- 85 5E            STA INDEX
E67B- 90 02            BCC .1
E67D- E6 5F            INC INDEX+1
E67F- 98        .1     TYA               LENGTH
E680- 20 E6 E5         JSR <a href="#MOVSTR.1">MOVSTR.1</a>      COPY STRING INTO SPACE
E683- 4C 2A E4         JMP <a href="#PUTNEW">PUTNEW</a>        ADD TO TEMPS
                *--------------------------------
                *      "RIGHT$" FUNCTION
                *--------------------------------
                <b><a name="RIGHTSTR" id="RIGHTSTR">RIGHTSTR</a></b>
E686- 20 B9 E6         JSR <a href="#SUBSTRING.SETUP">SUBSTRING.SETUP</a>
E689- 18               CLC          COMPUTE LENGTH-WIDTH OF SUBSTRING
E68A- F1 8C            SBC (DSCPTR),Y    TO GET STARTING POINT IN STRING
E68C- 49 FF            EOR #$FF
E68E- 4C 60 E6         JMP <a href="#SUBSTRING.1">SUBSTRING.1</a>   JOIN LEFT$
                *--------------------------------
                *      "MID$" FUNCTION
                *--------------------------------
E691- A9 FF     <b><a name="MIDSTR" id="MIDSTR">MIDSTR</a></b> LDA #$FF     FLAG WHETHER 2ND PARAMETER
E693- 85 A1            STA FAC+4
E695- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   SEE IF ")" YET
E698- C9 29            CMP #')'
E69A- F0 06            BEQ .1       YES, NO 2ND PARAMETER
E69C- 20 BE DE         JSR <a href="#CHKCOM">CHKCOM</a>   NO, MUST HAVE COMMA
E69F- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   GET 2ND PARAM IN X-REG
E6A2- 20 B9 E6  .1     JSR <a href="#SUBSTRING.SETUP">SUBSTRING.SETUP</a>
E6A5- CA               DEX          1ST PARAMETER - 1
E6A6- 8A               TXA
E6A7- 48               PHA
E6A8- 18               CLC
E6A9- A2 00            LDX #0
E6AB- F1 8C            SBC (DSCPTR),Y
E6AD- B0 B8            BCS <a href="#SUBSTRING.2">SUBSTRING.2</a>
E6AF- 49 FF            EOR #$FF
E6B1- C5 A1            CMP FAC+4    USE SMALLER OF TWO
E6B3- 90 B3            BCC <a href="#SUBSTRING.3">SUBSTRING.3</a>
E6B5- A5 A1            LDA FAC+4
E6B7- B0 AF            BCS <a href="#SUBSTRING.3">SUBSTRING.3</a>   ...ALWAYS
                *--------------------------------
                *      COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
                *      REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
                *      ADDRESS, GET 1ST PARAMETER OF COMMAND
                *--------------------------------
                <b><a name="SUBSTRING.SETUP" id="SUBSTRING.SETUP">SUBSTRING.SETUP</a></b>
E6B9- 20 B8 DE         JSR <a href="#CHKCLS">CHKCLS</a>   REQUIRE ")"
E6BC- 68               PLA          SAVE RETURN ADDRESS
E6BD- A8               TAY          IN Y-REG AND LENGTH
E6BE- 68               PLA
E6BF- 85 91            STA LENGTH
E6C1- 68               PLA          POP PREVIOUS RETURN ADDRESS
E6C2- 68               PLA           (FROM GOROUT).
E6C3- 68               PLA          RETRIEVE 1ST PARAMETER
E6C4- AA               TAX
E6C5- 68               PLA          GET ADDRESS OF STRING DESCRIPTOR
E6C6- 85 8C            STA DSCPTR
E6C8- 68               PLA
E6C9- 85 8D            STA DSCPTR+1
E6CB- A5 91            LDA LENGTH   RESTORE RETURN ADDRESS
E6CD- 48               PHA
E6CE- 98               TYA
E6CF- 48               PHA
E6D0- A0 00            LDY #0
E6D2- 8A               TXA          GET 1ST PARAMETER IN A-REG
E6D3- F0 1D            BEQ <a href="#GOIQ">GOIQ</a>     ERROR IF 0
E6D5- 60               RTS
                *--------------------------------
                *      "LEN" FUNCTION
                *--------------------------------
E6D6- 20 DC E6  <b><a name="LEN" id="LEN">LEN</a></b>    JSR <a href="#GETSTR">GETSTR</a>   GET LENTGH IN Y-REG, MAKE FAC NUMERIC
E6D9- 4C 01 E3         JMP <a href="#SNGFLT">SNGFLT</a>   FLOAT Y-REG INTO FAC
                *--------------------------------
                *      IF LAST RESULT IS A TEMPORARY STRING, FREE IT
                *      MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
                *--------------------------------
E6DC- 20 FD E5  <b><a name="GETSTR" id="GETSTR">GETSTR</a></b> JSR <a href="#FRESTR">FRESTR</a>   IF LAST RESULT IS A STRING, FREE IT
E6DF- A2 00            LDX #0       MAKE VALTYP NUMERIC
E6E1- 86 11            STX VALTYP
E6E3- A8               TAY          LENGTH OF STRING TO Y-REG
E6E4- 60               RTS
                *--------------------------------
                *      "ASC" FUNCTION
                *--------------------------------
E6E5- 20 DC E6  <b><a name="ASC" id="ASC">ASC</a></b>    JSR <a href="#GETSTR">GETSTR</a>   GET STRING, GET LENGTH IN Y-REG
E6E8- F0 08            BEQ <a href="#GOIQ">GOIQ</a>     ERROR IF LENGTH 0
E6EA- A0 00            LDY #0
E6EC- B1 5E            LDA (INDEX),Y     GET 1ST CHAR OF STRING
E6EE- A8               TAY
E6EF- 4C 01 E3         JMP <a href="#SNGFLT">SNGFLT</a>        FLOAT Y-REG INTO FAC
                *--------------------------------
E6F2- 4C 99 E1  <b><a name="GOIQ" id="GOIQ">GOIQ</a></b>   JMP <a href="#IQERR">IQERR</a>    ILLEGAL QUANTITY ERROR
                *--------------------------------
                *      SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
                *      TO SINGLE BYTE IN X-REG
                *--------------------------------
E6F5- 20 B1 00  <b><a name="GTBYTC" id="GTBYTC">GTBYTC</a></b> JSR <a href="#CHRGET">CHRGET</a>
                *--------------------------------
                *      EVALUATE EXPRESSION AT TXTPTR, AND
                *      CONVERT IT TO SINGLE BYTE IN X-REG
                *--------------------------------
E6F8- 20 67 DD  <b><a name="GETBYT" id="GETBYT">GETBYT</a></b> JSR <a href="#FRMNUM">FRMNUM</a>
                *--------------------------------
                *      CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
                *--------------------------------
E6FB- 20 08 E1  <b><a name="CONINT" id="CONINT">CONINT</a></b> JSR <a href="#MKINT">MKINT</a>    CONVERT IF IN RANGE -32767 TO +32767
E6FE- A6 A0            LDX FAC+3    HI-BYTE MUST BE ZERO
E700- D0 F0            BNE <a href="#GOIQ">GOIQ</a>     VALUE &gt; 255, ERROR
E702- A6 A1            LDX FAC+4    VALUE IN X-REG
E704- 4C B7 00         JMP <a href="#CHRGOT">CHRGOT</a>   GET NEXT CHAR IN A-REG
                *--------------------------------
                *      "VAL" FUNCTION
                *--------------------------------
E707- 20 DC E6  <b><a name="VAL" id="VAL">VAL</a></b>    JSR <a href="#GETSTR">GETSTR</a>   GET POINTER TO STRING IN INDEX
E70A- D0 03            BNE .1       LENGTH NON-ZERO
E70C- 4C 4E E8         JMP <a href="#ZERO.FAC">ZERO.FAC</a>      RETURN 0 IF LENGTH=0
E70F- A6 B8     .1     LDX TXTPTR   SAVE CURRENT TXTPTR
E711- A4 B9            LDY TXTPTR+1
E713- 86 AD            STX STRNG2
E715- 84 AE            STY STRNG2+1
E717- A6 5E            LDX INDEX
E719- 86 B8            STX TXTPTR   POINT TXTPTR TO START OF STRING
E71B- 18               CLC
E71C- 65 5E            ADC INDEX    ADD LENGTH
E71E- 85 60            STA DEST     POINT DEST TO END OF STRING + 1
E720- A6 5F            LDX INDEX+1
E722- 86 B9            STX TXTPTR+1
E724- 90 01            BCC .2
E726- E8               INX
E727- 86 61     .2     STX DEST+1
E729- A0 00            LDY #0       SAVE BYTE THAT FOLLOWS STRING
E72B- B1 60            LDA (DEST),Y      ON STACK
E72D- 48               PHA
E72E- A9 00            LDA #0            AND STORE $00 IN ITS PLACE
E730- 91 60            STA (DEST),Y
                *  &lt;&lt;&lt; THAT CAUSES A BUG IF HIMEM = $BFFF, &gt;&gt;&gt;
                *  &lt;&lt;&lt; BECAUSE STORING $00 AT $C000 IS NO  &gt;&gt;&gt;
                *  &lt;&lt;&lt; USE; $C000 WILL ALWAYS BE LAST CHAR &gt;&gt;&gt;
                *  &lt;&lt;&lt; TYPED, SO FIN WON'T TERMINATE UNTIL &gt;&gt;&gt;
                *  &lt;&lt;&lt; IT SEES A ZERO AT $C010!            &gt;&gt;&gt;
E732- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   PRIME THE PUMP
E735- 20 4A EC         JSR <a href="#FIN">FIN</a>      EVALUATE STRING
E738- 68               PLA          GET BYTE THAT SHOULD FOLLOW STRING
E739- A0 00            LDY #0       AND PUT IT BACK
E73B- 91 60            STA (DEST),Y
                *                   RESTORE TXTPTR
                *--------------------------------
                *      COPY STRNG2 INTO TXTPTR
                *--------------------------------
E73D- A6 AD     <b><a name="POINT" id="POINT">POINT</a></b>  LDX STRNG2
E73F- A4 AE            LDY STRNG2+1
E741- 86 B8            STX TXTPTR
E743- 84 B9            STY TXTPTR+1
E745- 60               RTS
                *--------------------------------
                *      EVALUATE "EXP1,EXP2"
                *
                *      CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
                *      CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
                *--------------------------------
E746- 20 67 DD  <b><a name="GTNUM" id="GTNUM">GTNUM</a></b>  JSR <a href="#FRMNUM">FRMNUM</a>
E749- 20 52 E7         JSR <a href="#GETADR">GETADR</a>
                *--------------------------------
                *      EVALUATE ",EXPRESSION"
                *      CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
                *--------------------------------
                <b><a name="COMBYTE" id="COMBYTE">COMBYTE</a></b>
E74C- 20 BE DE         JSR <a href="#CHKCOM">CHKCOM</a>   MUST HAVE COMMA FIRST
E74F- 4C F8 E6         JMP <a href="#GETBYT">GETBYT</a>   CONVERT EXPRESSION TO BYTE IN X-REG
                *--------------------------------
                *      CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
                *--------------------------------
E752- A5 9D     <b><a name="GETADR" id="GETADR">GETADR</a></b> LDA FAC      FAC &lt; 2^16?
E754- C9 91            CMP #$91
E756- B0 9A            BCS <a href="#GOIQ">GOIQ</a>     NO, ILLEGAL QUANTITY
E758- 20 F2 EB         JSR <a href="#QINT">QINT</a>     CONVERT TO INTEGER
E75B- A5 A0            LDA FAC+3    COPY IT INTO LINNUM
E75D- A4 A1            LDY FAC+4
E75F- 84 50            STY LINNUM    TO LINNUM
E761- 85 51            STA LINNUM+1
E763- 60               RTS
                *--------------------------------
                *      "PEEK" FUNCTION
                *--------------------------------
E764- A5 50     <b><a name="PEEK" id="PEEK">PEEK</a></b>   LDA LINNUM   SAVE (LINNUM) ON STACK DURING PEEK
E766- 48               PHA
E767- A5 51            LDA LINNUM+1
E769- 48               PHA
E76A- 20 52 E7         JSR <a href="#GETADR">GETADR</a>   GET ADDRESS PEEKING AT
E76D- A0 00            LDY #0
E76F- B1 50            LDA (LINNUM),Y    TAKE A QUICK LOOK
E771- A8               TAY               VALUE IN Y-REG
E772- 68               PLA          RESTORE LINNUM FROM STACK
E773- 85 51            STA LINNUM+1
E775- 68               PLA
E776- 85 50            STA LINNUM
E778- 4C 01 E3         JMP <a href="#SNGFLT">SNGFLT</a>   FLOAT Y-REG INTO FAC
                *--------------------------------
                *      "POKE" STATEMENT
                *--------------------------------
E77B- 20 46 E7  <b><a name="POKE" id="POKE">POKE</a></b>   JSR <a href="#GTNUM">GTNUM</a>    GET THE ADDRESS AND VALUE
E77E- 8A               TXA               VALUE IN A,
E77F- A0 00            LDY #0
E781- 91 50            STA (LINNUM),Y    STORE IT AWAY,
E783- 60               RTS               AND THAT'S ALL FOR TODAY
                *--------------------------------
                *      "WAIT" STATEMENT
                *--------------------------------
E784- 20 46 E7  <b><a name="WAIT" id="WAIT">WAIT</a></b>   JSR <a href="#GTNUM">GTNUM</a>    GET ADDRESS IN LINNUM, MASK IN X
E787- 86 85            STX FORPNT   SAVE MASK
E789- A2 00            LDX #0
E78B- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   ANOTHER PARAMETER?
E78E- F0 03            BEQ .1       NO, USE $00 FOR EXCLUSIVE-OR
E790- 20 4C E7         JSR <a href="#COMBYTE">COMBYTE</a>  GET XOR-MASK
E793- 86 86     .1     STX FORPNT+1 SAVE XOR-MASK HERE
E795- A0 00            LDY #0
E797- B1 50     .2     LDA (LINNUM),Y  GET BYTE AT ADDRESS
E799- 45 86            EOR FORPNT+1    INVERT SPECIFIED BITS
E79B- 25 85            AND FORPNT      SELECT SPECIFIED BITS
E79D- F0 F8            BEQ .2          LOOP TILL NOT 0
E79F- 60        <b><a name="RTS.10" id="RTS.10">RTS.10</a></b> RTS
                *--------------------------------
                *      ADD 0.5 TO FAC
                *--------------------------------
E7A0- A9 64     <b><a name="FADDH" id="FADDH">FADDH</a></b>  LDA #CON.HALF     FAC+1/2 -&gt; FAC
E7A2- A0 EE            LDY /CON.HALF
E7A4- 4C BE E7         JMP <a href="#FADD">FADD</a>
                *--------------------------------
                *      FAC = (Y,A) - FAC
                *--------------------------------
E7A7- 20 E3 E9  <b><a name="FSUB" id="FSUB">FSUB</a></b>   JSR <a href="#LOAD.ARG.FROM.YA">LOAD.ARG.FROM.YA</a>
                *--------------------------------
                *      FAC = ARG - FAC
                *--------------------------------
E7AA- A5 A2     <b><a name="FSUBT" id="FSUBT">FSUBT</a></b>  LDA FAC.SIGN   COMPLEMENT FAC AND ADD
E7AC- 49 FF            EOR #$FF
E7AE- 85 A2            STA FAC.SIGN
E7B0- 45 AA            EOR ARG.SIGN   FIX SGNCPR TOO
E7B2- 85 AB            STA SGNCPR
E7B4- A5 9D            LDA FAC        MAKE STATUS SHOW FAC EXPONENT
E7B6- 4C C1 E7         JMP <a href="#FADDT">FADDT</a>      JOIN FADD
                *--------------------------------
                *      SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
                *--------------------------------
E7B9- 20 F0 E8  <b><a name="FADD.1" id="FADD.1">FADD.1</a></b> JSR <a href="#SHIFT.RIGHT">SHIFT.RIGHT</a>   ALIGN RADIX BY SHIFTING
E7BC- 90 3C            BCC <a href="#FADD.3">FADD.3</a>   ...ALWAYS
                *--------------------------------
                *      FAC = (Y,A) + FAC
                *--------------------------------
E7BE- 20 E3 E9  <b><a name="FADD" id="FADD">FADD</a></b>   JSR <a href="#LOAD.ARG.FROM.YA">LOAD.ARG.FROM.YA</a>
                *--------------------------------
                *      FAC = ARG + FAC
                *--------------------------------
E7C1- D0 03     <b><a name="FADDT" id="FADDT">FADDT</a></b>  BNE .1       FAC IS NON-ZERO
E7C3- 4C 53 EB         JMP <a href="#COPY.ARG.TO.FAC">COPY.ARG.TO.FAC</a>   FAC = 0 + ARG
E7C6- A6 AC     .1     LDX FAC.EXTENSION
E7C8- 86 92            STX ARG.EXTENSION
E7CA- A2 A5            LDX #ARG     SET UP TO SHIFT ARG
E7CC- A5 A5            LDA ARG      EXPONENT
                *--------------------------------
E7CE- A8        <b><a name="FADD.2" id="FADD.2">FADD.2</a></b> TAY
E7CF- F0 CE            BEQ <a href="#RTS.10">RTS.10</a>   IF ARG=0, WE ARE FINISHED
E7D1- 38               SEC
E7D2- E5 9D            SBC FAC      GET DIFFNCE OF EXP
E7D4- F0 24            BEQ <a href="#FADD.3">FADD.3</a>   GO ADD IF SAME EXP
E7D6- 90 12            BCC .1       ARG HAS SMALLER EXPONENT
E7D8- 84 9D            STY FAC      EXP HAS SMALLER EXPONENT
E7DA- A4 AA            LDY ARG.SIGN
E7DC- 84 A2            STY FAC.SIGN
E7DE- 49 FF            EOR #$FF     COMPLEMENT SHIFT COUNT
E7E0- 69 00            ADC #0       CARRY WAS SET
E7E2- A0 00            LDY #0
E7E4- 84 92            STY ARG.EXTENSION
E7E6- A2 9D            LDX #FAC     SET UP TO SHIFT FAC
E7E8- D0 04            BNE .2       ...ALWAYS
E7EA- A0 00     .1     LDY #0
E7EC- 84 AC            STY FAC.EXTENSION
E7EE- C9 F9     .2     CMP #$F9     SHIFT MORE THAN 7 BITS?
E7F0- 30 C7            BMI <a href="#FADD.1">FADD.1</a>      YES
E7F2- A8               TAY          INDEX TO # OF SHIFTS
E7F3- A5 AC            LDA FAC.EXTENSION
E7F5- 56 01            LSR 1,X      START SHIFTING...
E7F7- 20 07 E9         JSR <a href="#SHIFT.RIGHT.4">SHIFT.RIGHT.4</a>  ...COMPLETE SHIFTING
E7FA- 24 AB     <b><a name="FADD.3" id="FADD.3">FADD.3</a></b> BIT <a href="#SGNCPR">SGNCPR</a>   DO FAC AND ARG HAVE SAME SIGNS?
E7FC- 10 57            BPL <a href="#FADD.4">FADD.4</a>   YES, ADD THE MANTISSAS
E7FE- A0 9D            LDY #FAC     NO, SUBTRACT SMALLER FROM LARGER
E800- E0 A5            CPX #ARG     WHICH WAS ADJUSTED?
E802- F0 02            BEQ .1       IF ARG, DO FAC-ARG
E804- A0 A5            LDY #ARG     IF FAC, DO ARG-FAC
E806- 38        .1     SEC          SUBTRACT SMALLER FROM LARGER (WE HOPE)
E807- 49 FF            EOR #$FF     (IF EXPONENTS WERE EQUAL, WE MIGHT BE
E809- 65 92            ADC ARG.EXTENSION  SUBTRACTING LARGER FROM SMALLER)
E80B- 85 AC            STA FAC.EXTENSION
E80D- B9 04 00         LDA 4,Y
E810- F5 04            SBC 4,X
E812- 85 A1            STA FAC+4
E814- B9 03 00         LDA 3,Y
E817- F5 03            SBC 3,X
E819- 85 A0            STA FAC+3
E81B- B9 02 00         LDA 2,Y
E81E- F5 02            SBC 2,X
E820- 85 9F            STA FAC+2
E822- B9 01 00         LDA 1,Y
E825- F5 01            SBC 1,X
E827- 85 9E            STA FAC+1
                *--------------------------------
                *      NORMALIZE VALUE IN FAC
                *--------------------------------
                <b><a name="NORMALIZE.FAC.1" id="NORMALIZE.FAC.1">NORMALIZE.FAC.1</a></b>
E829- B0 03            BCS <a href="#NORMALIZE.FAC.2">NORMALIZE.FAC.2</a>
E82B- 20 9E E8         JSR <a href="#COMPLEMENT.FAC">COMPLEMENT.FAC</a>
                *--------------------------------
                <b><a name="NORMALIZE.FAC.2" id="NORMALIZE.FAC.2">NORMALIZE.FAC.2</a></b>
E82E- A0 00            LDY #0       SHIFT UP SIGNIF DIGIT
E830- 98               TYA          START A=0, COUNT SHIFTS IN A-REG
E831- 18               CLC
E832- A6 9E     .1     LDX FAC+1    LOOK AT MOST SIGNIFICANT BYTE
E834- D0 4A            BNE <a href="#NORMALIZE.FAC.4">NORMALIZE.FAC.4</a>   SOME 1-BITS HERE
E836- A6 9F            LDX FAC+2    HI-BYTE OF MANTISSA STILL ZERO,
E838- 86 9E            STX FAC+1         SO DO A FAST 8-BIT SHUFFLE
E83A- A6 A0            LDX FAC+3
E83C- 86 9F            STX FAC+2
E83E- A6 A1            LDX FAC+4
E840- 86 A0            STX FAC+3
E842- A6 AC            LDX FAC.EXTENSION
E844- 86 A1            STX FAC+4
E846- 84 AC            STY FAC.EXTENSION  ZERO EXTENSION BYTE
E848- 69 08            ADC #8       BUMP SHIFT COUNT
E84A- C9 20            CMP #32      DONE 4 TIMES YET?
E84C- D0 E4            BNE .1       NO, STILL MIGHT BE SOME 1'S
                *                   YES, VALUE OF FAC IS ZERO
                *--------------------------------
                *      SET FAC = 0
                *      (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
                *--------------------------------
                <b><a name="ZERO.FAC" id="ZERO.FAC">ZERO.FAC</a></b>
E84E- A9 00            LDA #0
                *--------------------------------
                <b><a name="STA.IN.FAC.SIGN.AND.EXP" id="STA.IN.FAC.SIGN.AND.EXP">STA.IN.FAC.SIGN.AND.EXP</a></b>
E850- 85 9D            STA FAC
                *--------------------------------
                <b><a name="STA.IN.FAC.SIGN" id="STA.IN.FAC.SIGN">STA.IN.FAC.SIGN</a></b>
E852- 85 A2            STA FAC.SIGN
E854- 60               RTS
                *--------------------------------
                *      ADD MANTISSAS OF FAC AND ARG INTO FAC
                *--------------------------------
E855- 65 92     <b><a name="FADD.4" id="FADD.4">FADD.4</a></b> ADC ARG.EXTENSION
E857- 85 AC            STA FAC.EXTENSION
E859- A5 A1            LDA FAC+4
E85B- 65 A9            ADC ARG+4
E85D- 85 A1            STA FAC+4
E85F- A5 A0            LDA FAC+3
E861- 65 A8            ADC ARG+3
E863- 85 A0            STA FAC+3
E865- A5 9F            LDA FAC+2
E867- 65 A7            ADC ARG+2
E869- 85 9F            STA FAC+2
E86B- A5 9E            LDA FAC+1
E86D- 65 A6            ADC ARG+1
E86F- 85 9E            STA FAC+1
E871- 4C 8D E8         JMP <a href="#NORMALIZE.FAC.5">NORMALIZE.FAC.5</a>
                *--------------------------------
                *      FINISH NORMALIZING FAC
                *--------------------------------
                <b><a name="NORMALIZE.FAC.3" id="NORMALIZE.FAC.3">NORMALIZE.FAC.3</a></b>
E874- 69 01            ADC #1       COUNT BITS SHIFTED
E876- 06 AC            ASL FAC.EXTENSION
E878- 26 A1            ROL FAC+4
E87A- 26 A0            ROL FAC+3
E87C- 26 9F            ROL FAC+2
E87E- 26 9E            ROL FAC+1
                *--------------------------------
                <b><a name="NORMALIZE.FAC.4" id="NORMALIZE.FAC.4">NORMALIZE.FAC.4</a></b>
E880- 10 F2            BPL <a href="#NORMALIZE.FAC.3">NORMALIZE.FAC.3</a>    UNTIL TOP BIT = 1
E882- 38               SEC
E883- E5 9D            SBC FAC      ADJUST EXPONENT BY BITS SHIFTED
E885- B0 C7            BCS <a href="#ZERO.FAC">ZERO.FAC</a> UNDERFLOW, RETURN ZERO
E887- 49 FF            EOR #$FF
E889- 69 01            ADC #1       2'S COMPLEMENT
E88B- 85 9D            STA FAC      CARRY=0 NOW
                *--------------------------------
                <b><a name="NORMALIZE.FAC.5" id="NORMALIZE.FAC.5">NORMALIZE.FAC.5</a></b>
E88D- 90 0E            BCC <a href="#RTS.11">RTS.11</a>   UNLESS MANTISSA CARRIED
                *--------------------------------
                <b><a name="NORMALIZE.FAC.6" id="NORMALIZE.FAC.6">NORMALIZE.FAC.6</a></b>
E88F- E6 9D            INC FAC      MANTISSA CARRIED, SO SHIFT RIGHT
E891- F0 42            BEQ <a href="#OVERFLOW">OVERFLOW</a>      OVERFLOW IF EXPONENT TOO BIG
E893- 66 9E            ROR FAC+1
E895- 66 9F            ROR FAC+2
E897- 66 A0            ROR FAC+3
E899- 66 A1            ROR FAC+4
E89B- 66 AC            ROR FAC.EXTENSION
E89D- 60        <b><a name="RTS.11" id="RTS.11">RTS.11</a></b> RTS
                *--------------------------------
                *      2'S COMPLEMENT OF FAC
                *--------------------------------
                <b><a name="COMPLEMENT.FAC" id="COMPLEMENT.FAC">COMPLEMENT.FAC</a></b>
E89E- A5 A2            LDA FAC.SIGN
E8A0- 49 FF            EOR #$FF
E8A2- 85 A2            STA FAC.SIGN
                *--------------------------------
                *      2'S COMPLEMENT OF FAC MANTISSA ONLY
                *--------------------------------
                <b><a name="COMPLEMENT.FAC.MANTISSA" id="COMPLEMENT.FAC.MANTISSA">COMPLEMENT.FAC.MANTISSA</a></b>
E8A4- A5 9E            LDA FAC+1
E8A6- 49 FF            EOR #$FF
E8A8- 85 9E            STA FAC+1
E8AA- A5 9F            LDA FAC+2
E8AC- 49 FF            EOR #$FF
E8AE- 85 9F            STA FAC+2
E8B0- A5 A0            LDA FAC+3
E8B2- 49 FF            EOR #$FF
E8B4- 85 A0            STA FAC+3
E8B6- A5 A1            LDA FAC+4
E8B8- 49 FF            EOR #$FF
E8BA- 85 A1            STA FAC+4
E8BC- A5 AC            LDA FAC.EXTENSION
E8BE- 49 FF            EOR #$FF
E8C0- 85 AC            STA FAC.EXTENSION
E8C2- E6 AC            INC FAC.EXTENSION START INCREMENTING MANTISSA
E8C4- D0 0E            BNE <a href="#RTS.12">RTS.12</a>
                *--------------------------------
                *      INCREMENT FAC MANTISSA
                *--------------------------------
                <b><a name="INCREMENT.FAC.MANTISSA" id="INCREMENT.FAC.MANTISSA">INCREMENT.FAC.MANTISSA</a></b>
E8C6- E6 A1            INC FAC+4   ADD CARRY FROM EXTRA
E8C8- D0 0A            BNE <a href="#RTS.12">RTS.12</a>
E8CA- E6 A0            INC FAC+3
E8CC- D0 06            BNE <a href="#RTS.12">RTS.12</a>
E8CE- E6 9F            INC FAC+2
E8D0- D0 02            BNE <a href="#RTS.12">RTS.12</a>
E8D2- E6 9E            INC FAC+1
E8D4- 60        <b><a name="RTS.12" id="RTS.12">RTS.12</a></b> RTS
                *--------------------------------
                <b><a name="OVERFLOW" id="OVERFLOW">OVERFLOW</a></b>
E8D5- A2 45            LDX #ERR.OVERFLOW
E8D7- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
                *      SHIFT 1,X THRU 5,X RIGHT
                *      (A) = NEGATIVE OF SHIFT COUNT
                *      (X) = POINTER TO BYTES TO BE SHIFTED
                *
                *      RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
                *--------------------------------
                <b><a name="SHIFT.RIGHT.1" id="SHIFT.RIGHT.1">SHIFT.RIGHT.1</a></b>
E8DA- A2 61            LDX #RESULT-1     SHIFT RESULT RIGHT
                <b><a name="SHIFT.RIGHT.2" id="SHIFT.RIGHT.2">SHIFT.RIGHT.2</a></b>
E8DC- B4 04            LDY 4,X           SHIFT 8 BITS RIGHT
E8DE- 84 AC            STY FAC.EXTENSION
E8E0- B4 03            LDY 3,X
E8E2- 94 04            STY 4,X
E8E4- B4 02            LDY 2,X
E8E6- 94 03            STY 3,X
E8E8- B4 01            LDY 1,X
E8EA- 94 02            STY 2,X
E8EC- A4 A4            LDY SHIFT.SIGN.EXT   $00 IF +, $FF IF -
E8EE- 94 01            STY 1,X
                *--------------------------------
                *      MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
                *--------------------------------
                <b><a name="SHIFT.RIGHT" id="SHIFT.RIGHT">SHIFT.RIGHT</a></b>
E8F0- 69 08            ADC #8
E8F2- 30 E8            BMI <a href="#SHIFT.RIGHT.2">SHIFT.RIGHT.2</a> STILL MORE THAN 8 BITS TO GO
E8F4- F0 E6            BEQ <a href="#SHIFT.RIGHT.2">SHIFT.RIGHT.2</a> EXACTLY 8 MORE BITS TO GO
E8F6- E9 08            SBC #8            UNDO ADC ABOVE
E8F8- A8               TAY               REMAINING SHIFT COUNT
E8F9- A5 AC            LDA FAC.EXTENSION
E8FB- B0 14            BCS <a href="#SHIFT.RIGHT.5">SHIFT.RIGHT.5</a> FINISHED SHIFTING
                <b><a name="SHIFT.RIGHT.3" id="SHIFT.RIGHT.3">SHIFT.RIGHT.3</a></b>
E8FD- 16 01     L      ASL 1,X           SIGN -&gt; CARRY (SIGN EXTENSION)
E8FF- 90 02            BCC .1            SIGN +
E901- F6 01            INC 1,X           PUT SIGN IN LSB
E903- 76 01     .1     ROR 1,X          RESTORE VALUE, SIGN STILL IN CARRY
E905- 76 01            ROR 1,X           START RIGHT SHIFT, INSERTING SIGN
                *--------------------------------
                *      ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
                *--------------------------------
                <b><a name="SHIFT.RIGHT.4" id="SHIFT.RIGHT.4">SHIFT.RIGHT.4</a></b>
E907- 76 02            ROR 2,X
E909- 76 03            ROR 3,X
E90B- 76 04            ROR 4,X
E90D- 6A               ROR               EXTENSION
E90E- C8               INY               COUNT THE SHIFT
E90F- D0 EC            BNE <a href="#SHIFT.RIGHT.3">SHIFT.RIGHT.3</a>
                <b><a name="SHIFT.RIGHT.5" id="SHIFT.RIGHT.5">SHIFT.RIGHT.5</a></b>
E911- 18               CLC               RETURN WITH CARRY CLEAR
E912- 60               RTS
                *--------------------------------
                *--------------------------------
E913- 81 00 00
E916- 00 00     <b><a name="CON.ONE" id="CON.ONE">CON.ONE</a></b> .HS 8100000000
                *--------------------------------
E918- 03        <b><a name="POLY.LOG" id="POLY.LOG">POLY.LOG</a></b>     .DA #3      # OF COEFFICIENTS - 1
E919- 7F 5E 56
E91C- CB 79                  .HS 7F5E56CB79 * X^7 +
E91E- 80 13 9B
E921- 0B 64                  .HS 80139B0B64 * X^5 +
E923- 80 76 38
E926- 93 16                  .HS 8076389316 * X^3 +
E928- 82 38 AA
E92B- 3B 20                  .HS 8238AA3B20 * X
                *--------------------------------
E92D- 80 35 04
E930- F3 34     <b><a name="CON.SQR.HALF" id="CON.SQR.HALF">CON.SQR.HALF</a></b> .HS 803504F334
E932- 81 35 04
E935- F3 34     <b><a name="CON.SQR.TWO" id="CON.SQR.TWO">CON.SQR.TWO</a></b>  .HS 813504F334
E937- 80 80 00
E93A- 00 00     <b><a name="CON.NEG.HALF" id="CON.NEG.HALF">CON.NEG.HALF</a></b> .HS 8080000000
E93C- 80 31 72
E93F- 17 F8     <b><a name="CON.LOG.TWO" id="CON.LOG.TWO">CON.LOG.TWO</a></b>  .HS 80317217F8
                *--------------------------------
                *      "LOG" FUNCTION
                *--------------------------------
E941- 20 82 EB  <b><a name="LOG" id="LOG">LOG</a></b>    JSR <a href="#SIGN">SIGN</a>     GET -1,0,+1 IN A-REG FOR FAC
E944- F0 02            BEQ <a href="#GIQ">GIQ</a>      LOG (0) IS ILLEGAL
E946- 10 03            BPL <a href="#LOG.2">LOG.2</a>    &gt;0 IS OK
E948- 4C 99 E1  <b><a name="GIQ" id="GIQ">GIQ</a></b>    JMP <a href="#IQERR">IQERR</a>    &lt;= 0 IS NO GOOD
E94B- A5 9D     <b><a name="LOG.2" id="LOG.2">LOG.2</a></b>  LDA FAC      FIRST GET LOG BASE 2
E94D- E9 7F            SBC #$7F     SAVE UNBIASED EXPONENT
E94F- 48               PHA
E950- A9 80            LDA #$80     NORMALIZE BETWEEN .5 AND 1
E952- 85 9D            STA FAC
E954- A9 2D            LDA #CON.SQR.HALF
E956- A0 E9            LDY /CON.SQR.HALF
E958- 20 BE E7         JSR <a href="#FADD">FADD</a>     COMPUTE VIA SERIES OF ODD
E95B- A9 32            LDA #CON.SQR.TWO   POWERS OF
E95D- A0 E9            LDY /CON.SQR.TWO   (SQR(2)X-1)/(SQR(2)X+1)
E95F- 20 66 EA         JSR <a href="#FDIV">FDIV</a>
E962- A9 13            LDA #CON.ONE
E964- A0 E9            LDY /CON.ONE
E966- 20 A7 E7         JSR <a href="#FSUB">FSUB</a>
E969- A9 18            LDA #POLY.LOG
E96B- A0 E9            LDY /POLY.LOG
E96D- 20 5C EF         JSR <a href="#POLYNOMIAL.ODD">POLYNOMIAL.ODD</a>
E970- A9 37            LDA #CON.NEG.HALF
E972- A0 E9            LDY /CON.NEG.HALF
E974- 20 BE E7         JSR <a href="#FADD">FADD</a>
E977- 68               PLA
E978- 20 D5 EC         JSR <a href="#ADDACC">ADDACC</a>   ADD ORIGINAL EXPONENT
E97B- A9 3C            LDA #CON.LOG.TWO  MULTIPLY BY LOG(2) TO FORM
E97D- A0 E9            LDY /CON.LOG.TWO  NATURAL LOG OF X
                *--------------------------------
                *      FAC = (Y,A) * FAC
                *--------------------------------
E97F- 20 E3 E9  <b><a name="FMULT" id="FMULT">FMULT</a></b>  JSR <a href="#LOAD.ARG.FROM.YA">LOAD.ARG.FROM.YA</a>
                *--------------------------------
                *      FAC = ARG * FAC
                *--------------------------------
E982- D0 03     <b><a name="FMULTT" id="FMULTT">FMULTT</a></b> BNE .1       FAC .NE. ZERO
E984- 4C E2 E9         JMP <a href="#RTS.13">RTS.13</a>   FAC = 0 * ARG = 0
                *  &lt;&lt;&lt; WHY IS LINE ABOVE JUST "RTS"? &gt;&gt;&gt;
                *--------------------------------
                *
                *--------------------------------
E987- 20 0E EA  .1     JSR <a href="#ADD.EXPONENTS">ADD.EXPONENTS</a>
E98A- A9 00            LDA #0
E98C- 85 62            STA RESULT   INIT PRODUCT = 0
E98E- 85 63            STA RESULT+1
E990- 85 64            STA RESULT+2
E992- 85 65            STA RESULT+3
E994- A5 AC            LDA FAC.EXTENSION
E996- 20 B0 E9         JSR <a href="#MULTIPLY.1">MULTIPLY.1</a>
E999- A5 A1            LDA FAC+4
E99B- 20 B0 E9         JSR <a href="#MULTIPLY.1">MULTIPLY.1</a>
E99E- A5 A0            LDA FAC+3
E9A0- 20 B0 E9         JSR <a href="#MULTIPLY.1">MULTIPLY.1</a>
E9A3- A5 9F            LDA FAC+2
E9A5- 20 B0 E9         JSR <a href="#MULTIPLY.1">MULTIPLY.1</a>
E9A8- A5 9E            LDA FAC+1
E9AA- 20 B5 E9         JSR <a href="#MULTIPLY.2">MULTIPLY.2</a>
E9AD- 4C E6 EA         JMP <a href="#COPY.RESULT.INTO.FAC">COPY.RESULT.INTO.FAC</a>
                *--------------------------------
                *      MULTIPLY ARG BY (A) INTO RESULT
                *--------------------------------
                <b><a name="MULTIPLY.1" id="MULTIPLY.1">MULTIPLY.1</a></b>
E9B0- D0 03            BNE <a href="#MULTIPLY.2">MULTIPLY.2</a>    THIS BYTE NON-ZERO
E9B2- 4C DA E8         JMP <a href="#SHIFT.RIGHT.1">SHIFT.RIGHT.1</a> (A)=0, JUST SHIFT ARG RIGHT 8
                *--------------------------------
                <b><a name="MULTIPLY.2" id="MULTIPLY.2">MULTIPLY.2</a></b>
E9B5- 4A               LSR               SHIFT BIT INTO CARRY
E9B6- 09 80            ORA #$80          SUPPLY SENTINEL BIT
E9B8- A8        .1     TAY               REMAINING MULTIPLIER TO Y
E9B9- 90 19            BCC .2            THIS MULTIPLIER BIT = 0
E9BB- 18               CLC               = 1, SO ADD ARG TO RESULT
E9BC- A5 65            LDA RESULT+3
E9BE- 65 A9            ADC ARG+4
E9C0- 85 65            STA RESULT+3
E9C2- A5 64            LDA RESULT+2
E9C4- 65 A8            ADC ARG+3
E9C6- 85 64            STA RESULT+2 
E9C8- A5 63            LDA RESULT+1
E9CA- 65 A7            ADC ARG+2
E9CC- 85 63            STA RESULT+1
E9CE- A5 62            LDA RESULT
E9D0- 65 A6            ADC ARG+1
E9D2- 85 62            STA RESULT
E9D4- 66 62     .2     ROR RESULT        SHIFT RESULT RIGHT 1
E9D6- 66 63            ROR RESULT+1
E9D8- 66 64            ROR RESULT+2
E9DA- 66 65            ROR RESULT+3
E9DC- 66 AC            ROR FAC.EXTENSION
E9DE- 98               TYA               REMAINING MULTIPLIER
E9DF- 4A               LSR               LSB INTO CARRY
E9E0- D0 D6            BNE .1            IF SENTINEL STILL HERE, MULTIPLY
E9E2- 60        <b><a name="RTS.13" id="RTS.13">RTS.13</a></b> RTS               8 X 32 COMPLETED
                *--------------------------------
                *      UNPACK NUMBER AT (Y,A) INTO ARG
                *--------------------------------
                <b><a name="LOAD.ARG.FROM.YA" id="LOAD.ARG.FROM.YA">LOAD.ARG.FROM.YA</a></b>
E9E3- 85 5E            STA INDEX    USE INDEX FOR PNTR
E9E5- 84 5F            STY INDEX+1
E9E7- A0 04            LDY #4       FIVE BYTES TO MOVE
E9E9- B1 5E            LDA (INDEX),Y
E9EB- 85 A9            STA ARG+4
E9ED- 88               DEY
E9EE- B1 5E            LDA (INDEX),Y
E9F0- 85 A8            STA ARG+3
E9F2- 88               DEY
E9F3- B1 5E            LDA (INDEX),Y
E9F5- 85 A7            STA ARG+2
E9F7- 88               DEY
E9F8- B1 5E            LDA (INDEX),Y
E9FA- 85 AA            STA ARG.SIGN
E9FC- 45 A2            EOR FAC.SIGN SET COMBINED SIGN FOR MULT/DIV
E9FE- 85 AB            STA SGNCPR
EA00- A5 AA            LDA ARG.SIGN TURN ON NORMALIZED INVISIBLE BIT
EA02- 09 80            ORA #$80     TO COMPLETE MANTISSA
EA04- 85 A6            STA ARG+1
EA06- 88               DEY
EA07- B1 5E            LDA (INDEX),Y
EA09- 85 A5            STA ARG      EXPONENT
EA0B- A5 9D            LDA FAC      SET STATUS BITS ON FAC EXPONENT
EA0D- 60               RTS
                *--------------------------------
                *      ADD EXPONENTS OF ARG AND FAC
                *      (CALLED BY FMULT AND FDIV)
                *
                *      ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
                *--------------------------------
                <b><a name="ADD.EXPONENTS" id="ADD.EXPONENTS">ADD.EXPONENTS</a></b>
EA0E- A5 A5            LDA ARG
                *--------------------------------
                <b><a name="ADD.EXPONENTS.1" id="ADD.EXPONENTS.1">ADD.EXPONENTS.1</a></b>
EA10- F0 1F            BEQ <a href="#ZERO">ZERO</a>     IF ARG=0, RESULT IS ZERO
EA12- 18               CLC
EA13- 65 9D            ADC FAC
EA15- 90 04            BCC .1       IN RANGE
EA17- 30 1D            BMI <a href="#JOV">JOV</a>      OVERFLOW
EA19- 18               CLC
EA1A- 2C               .HS 2C       TRICK TO SKIP
EA1B- 10 14     .1     BPL <a href="#ZERO">ZERO</a>     OVERFLOW
EA1D- 69 80            ADC #$80     RE-BIAS
EA1F- 85 9D            STA FAC      RESULT
EA21- D0 03            BNE .2
EA23- 4C 52 E8         JMP <a href="#STA.IN.FAC.SIGN">STA.IN.FAC.SIGN</a>  RESULT IS ZERO
                *  &lt;&lt;&lt; CRAZY TO JUMP WAY BACK THERE! &gt;&gt;&gt;
                *  &lt;&lt;&lt; SAME IDENTICAL CODE IS BELOW! &gt;&gt;&gt;
                *  &lt;&lt;&lt; INSTEAD OF BNE .2, JMP STA.IN.FAC.SIGN   &gt;&gt;&gt;
                *  &lt;&lt;&lt; ONLY NEEDED BEQ .3            &gt;&gt;&gt;
EA26- A5 AB     .2     LDA SGNCPR   SET SIGN OF RESULT
EA28- 85 A2     .3     STA FAC.SIGN
EA2A- 60               RTS
                *--------------------------------
                * IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
                * IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
                * CALLED FROM "EXP" FUNCTION
                *--------------------------------
                <b><a name="OUTOFRNG" id="OUTOFRNG">OUTOFRNG</a></b>
EA2B- A5 A2            LDA FAC.SIGN
EA2D- 49 FF            EOR #$FF
EA2F- 30 05            BMI <a href="#JOV">JOV</a>      ERROR IF POSITIVE #
                *--------------------------------
                *      POP RETURN ADDRESS AND SET FAC=0
                *--------------------------------
EA31- 68        <b><a name="ZERO" id="ZERO">ZERO</a></b>   PLA
EA32- 68               PLA
EA33- 4C 4E E8         JMP <a href="#ZERO.FAC">ZERO.FAC</a>
                *--------------------------------
EA36- 4C D5 E8  <b><a name="JOV" id="JOV">JOV</a></b>    JMP <a href="#OVERFLOW">OVERFLOW</a>
                *--------------------------------
                *      MULTIPLY FAC BY 10
                *--------------------------------
EA39- 20 63 EB  <b><a name="MUL10" id="MUL10">MUL10</a></b>  JSR <a href="#COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a>
EA3C- AA               TAX          TEXT FAC EXPONENT
EA3D- F0 10            BEQ .1       FINISHED IF FAC=0
EA3F- 18               CLC
EA40- 69 02            ADC #2       ADD 2 TO EXPONENT GIVES (FAC)*4
EA42- B0 F2            BCS <a href="#JOV">JOV</a>      OVERFLOW
EA44- A2 00            LDX #0
EA46- 86 AB            STX SGNCPR
EA48- 20 CE E7         JSR <a href="#FADD.2">FADD.2</a>   MAKES (FAC)*5
EA4B- E6 9D            INC FAC      *2, MAKES (FAC)*10
EA4D- F0 E7            BEQ <a href="#JOV">JOV</a>      OVERFLOW
EA4F- 60        .1     RTS
                *--------------------------------
EA50- 84 20 00
EA53- 00 00     <b><a name="CON.TEN" id="CON.TEN">CON.TEN</a></b> .HS 8420000000
                *--------------------------------
                *      DIVIDE FAC BY 10
                *--------------------------------
EA55- 20 63 EB  <b><a name="DIV10" id="DIV10">DIV10</a></b>  JSR <a href="#COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a>
EA58- A9 50            LDA #CON.TEN   SET UP TO PUT
EA5A- A0 EA            LDY /CON.TEN   10 IN FAC
EA5C- A2 00            LDX #0
                *--------------------------------
                *      FAC = ARG / (Y,A)
                *--------------------------------
EA5E- 86 AB     <b><a name="DIV" id="DIV">DIV</a></b>    STX SGNCPR
EA60- 20 F9 EA         JSR <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>
EA63- 4C 69 EA         JMP <a href="#FDIVT">FDIVT</a>    DIVIDE ARG BY FAC
                *--------------------------------
                *      FAC = (Y,A) / FAC
                *--------------------------------
EA66- 20 E3 E9  <b><a name="FDIV" id="FDIV">FDIV</a></b>   JSR <a href="#LOAD.ARG.FROM.YA">LOAD.ARG.FROM.YA</a>
                *--------------------------------
                *      FAC = ARG / FAC
                *--------------------------------
EA69- F0 76     <b><a name="FDIVT" id="FDIVT">FDIVT</a></b>  BEQ .8       FAC = 0, DIVIDE BY ZERO ERROR
EA6B- 20 72 EB         JSR <a href="#ROUND.FAC">ROUND.FAC</a>
EA6E- A9 00            LDA #0       NEGATE FAC EXPONENT, SO 
EA70- 38               SEC          ADD.EXPONENTS FORMS DIFFERENCE
EA71- E5 9D            SBC FAC
EA73- 85 9D            STA FAC
EA75- 20 0E EA         JSR <a href="#ADD.EXPONENTS">ADD.EXPONENTS</a>
EA78- E6 9D            INC FAC
EA7A- F0 BA            BEQ <a href="#JOV">JOV</a>      OVERFLOW
EA7C- A2 FC            LDX #-4      INDEX FOR RESULT
EA7E- A9 01            LDA #1       SENTINEL
EA80- A4 A6     .1     LDY ARG+1    SEE IF FAC CAN BE SUBTRACTED
EA82- C4 9E            CPY FAC+1
EA84- D0 10            BNE .2
EA86- A4 A7            LDY ARG+2
EA88- C4 9F            CPY FAC+2
EA8A- D0 0A            BNE .2
EA8C- A4 A8            LDY ARG+3
EA8E- C4 A0            CPY FAC+3
EA90- D0 04            BNE .2
EA92- A4 A9            LDY ARG+4
EA94- C4 A1            CPY FAC+4
EA96- 08        .2     PHP          SAVE THE ANSWER, AND ALSO ROLL THE
EA97- 2A               ROL          BIT INTO THE QUOTIENT, SENTINEL OUT
EA98- 90 09            BCC .3       NO SENTINEL, STILL NOT 8 TRIPS
EA9A- E8               INX          8 TRIPS, STORE BYTE OF QUOTIENT
EA9B- 95 65            STA RESULT+3,X
EA9D- F0 32            BEQ .6       32-BITS COMPLETED
EA9F- 10 34            BPL .7       FINAL EXIT WHEN X=1
EAA1- A9 01            LDA #1       RE-START SENTINEL
EAA3- 28        .3     PLP          GET ANSWER, CAN FAC BE SUBTRACTED?
EAA4- B0 0E            BCS .5       YES, DO IT
EAA6- 06 A9     .4     ASL ARG+4    NO, SHIFT ARG LEFT
EAA8- 26 A8            ROL ARG+3
EAAA- 26 A7            ROL ARG+2
EAAC- 26 A6            ROL ARG+1
EAAE- B0 E6            BCS .2       ANOTHER TRIP
EAB0- 30 CE            BMI .1       HAVE TO COMPARE FIRST
EAB2- 10 E2            BPL .2       ...ALWAYS
EAB4- A8        .5     TAY          SAVE QUOTIENT/SENTINEL BYTE
EAB5- A5 A9            LDA ARG+4    SUBTRACT FAC FROM ARG ONCE
EAB7- E5 A1            SBC FAC+4
EAB9- 85 A9            STA ARG+4
EABB- A5 A8            LDA ARG+3
EABD- E5 A0            SBC FAC+3
EABF- 85 A8            STA ARG+3
EAC1- A5 A7            LDA ARG+2
EAC3- E5 9F            SBC FAC+2
EAC5- 85 A7            STA ARG+2
EAC7- A5 A6            LDA ARG+1
EAC9- E5 9E            SBC FAC+1
EACB- 85 A6            STA ARG+1
EACD- 98               TYA          RESTORE QUOTIENT/SENTINEL BYTE
EACE- 4C A6 EA         JMP .4       GO TO SHIFT ARG AND CONTINUE
                *--------------------------------
EAD1- A9 40     .6     LDA #$40     DO A FEW EXTENSION BITS
EAD3- D0 CE            BNE .3       ...ALWAYS
                *--------------------------------
EAD5- 0A        .7     ASL          LEFT JUSTIFY THE EXTENSION BITS WE DID
EAD6- 0A               ASL
EAD7- 0A               ASL
EAD8- 0A               ASL
EAD9- 0A               ASL
EADA- 0A               ASL
EADB- 85 AC            STA FAC.EXTENSION
EADD- 28               PLP
EADE- 4C E6 EA         JMP <a href="#COPY.RESULT.INTO.FAC">COPY.RESULT.INTO.FAC</a>
                *--------------------------------
EAE1- A2 85     .8     LDX #ERR.ZERODIV
EAE3- 4C 12 D4         JMP <a href="#ERROR">ERROR</a>
                *--------------------------------
                *      COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
                *--------------------------------
                <b><a name="COPY.RESULT.INTO.FAC" id="COPY.RESULT.INTO.FAC">COPY.RESULT.INTO.FAC</a></b>
EAE6- A5 62            LDA RESULT
EAE8- 85 9E            STA FAC+1
EAEA- A5 63            LDA RESULT+1
EAEC- 85 9F            STA FAC+2
EAEE- A5 64            LDA RESULT+2
EAF0- 85 A0            STA FAC+3
EAF2- A5 65            LDA RESULT+3
EAF4- 85 A1            STA FAC+4
EAF6- 4C 2E E8         JMP <a href="#NORMALIZE.FAC.2">NORMALIZE.FAC.2</a>
                *--------------------------------
                *      UNPACK (Y,A) INTO FAC
                *--------------------------------
                <b><a name="LOAD.FAC.FROM.YA" id="LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a></b>
EAF9- 85 5E            STA INDEX    USE INDEX FOR PNTR
EAFB- 84 5F            STY INDEX+1
EAFD- A0 04            LDY #4       PICK UP 5 BYTES
EAFF- B1 5E            LDA (INDEX),Y
EB01- 85 A1            STA FAC+4
EB03- 88               DEY
EB04- B1 5E            LDA (INDEX),Y
EB06- 85 A0            STA FAC+3
EB08- 88               DEY
EB09- B1 5E            LDA (INDEX),Y
EB0B- 85 9F            STA FAC+2
EB0D- 88               DEY
EB0E- B1 5E            LDA (INDEX),Y
EB10- 85 A2            STA FAC.SIGN FIRST BIT IS SIGN
EB12- 09 80            ORA #$80     SET NORMALIZED INVISIBLE BIT
EB14- 85 9E            STA FAC+1
EB16- 88               DEY
EB17- B1 5E            LDA (INDEX),Y
EB19- 85 9D            STA FAC      EXPONENT
EB1B- 84 AC            STY FAC.EXTENSION  Y=0
EB1D- 60               RTS
                *--------------------------------
                *      ROUND FAC, STORE IN TEMP2
                *--------------------------------
                <b><a name="STORE.FAC.IN.TEMP2.ROUNDED" id="STORE.FAC.IN.TEMP2.ROUNDED">STORE.FAC.IN.TEMP2.ROUNDED</a></b>
EB1E- A2 98            LDX #TEMP2   PACK FAC INTO TEMP2
EB20- 2C               .HS 2C       TRICK TO BRANCH
                *--------------------------------
                *      ROUND FAC, STORE IN TEMP1
                *--------------------------------
                <b><a name="STORE.FAC.IN.TEMP1.ROUNDED" id="STORE.FAC.IN.TEMP1.ROUNDED">STORE.FAC.IN.TEMP1.ROUNDED</a></b>
EB21- A2 93            LDX #TEMP1   PACK FAC INTO TEMP1
EB23- A0 00            LDY /TEMP1   HI-BYTE OF TEMP1 SAME AS TEMP2
EB25- F0 04            BEQ <a href="#STORE.FAC.AT.YX.ROUNDED">STORE.FAC.AT.YX.ROUNDED</a>    ...ALWAYS
                *--------------------------------
                *      ROUND FAC, AND STORE WHERE FORPNT POINTS
                *--------------------------------
EB27- A6 85     <b><a name="SETFOR" id="SETFOR">SETFOR</a></b> LDX FORPNT
EB29- A4 86            LDY FORPNT+1
                *--------------------------------
                *      ROUND FAC, AND STORE AT (Y,X)
                *--------------------------------
                <b><a name="STORE.FAC.AT.YX.ROUNDED" id="STORE.FAC.AT.YX.ROUNDED">STORE.FAC.AT.YX.ROUNDED</a></b>
EB2B- 20 72 EB         JSR <a href="#ROUND.FAC">ROUND.FAC</a>    ROUND VALUE IN FAC USING EXTENSION
EB2E- 86 5E            STX INDEX         USE INDEX FOR PNTR
EB30- 84 5F            STY INDEX+1
EB32- A0 04            LDY #4            STORING 5 PACKED BYTES
EB34- A5 A1            LDA FAC+4
EB36- 91 5E            STA (INDEX),Y
EB38- 88               DEY
EB39- A5 A0            LDA FAC+3
EB3B- 91 5E            STA (INDEX),Y
EB3D- 88               DEY
EB3E- A5 9F            LDA FAC+2
EB40- 91 5E            STA (INDEX),Y
EB42- 88               DEY
EB43- A5 A2            LDA FAC.SIGN      PACK SIGN IN TOP BIT OF MANTISSA
EB45- 09 7F            ORA #$7F
EB47- 25 9E            AND FAC+1
EB49- 91 5E            STA (INDEX),Y
EB4B- 88               DEY
EB4C- A5 9D            LDA FAC           EXPONENT
EB4E- 91 5E            STA (INDEX),Y
EB50- 84 AC            STY FAC.EXTENSION ZERO THE EXTENSION
EB52- 60               RTS
                *--------------------------------
                *      COPY ARG INTO FAC
                *--------------------------------
                <b><a name="COPY.ARG.TO.FAC" id="COPY.ARG.TO.FAC">COPY.ARG.TO.FAC</a></b>
EB53- A5 AA            LDA ARG.SIGN      COPY SIGN
EB55- 85 A2     <b><a name="MFA" id="MFA">MFA</a></b>    STA FAC.SIGN
EB57- A2 05            LDX #5            MOVE 5 BYTES
EB59- B5 A4     .1     LDA ARG-1,X
EB5B- 95 9C            STA FAC-1,X
EB5D- CA               DEX
EB5E- D0 F9            BNE .1
EB60- 86 AC            STX FAC.EXTENSION ZERO EXTENSION
EB62- 60               RTS
                *--------------------------------
                *      ROUND FAC AND COPY TO ARG
                *--------------------------------
                <b><a name="COPY.FAC.TO.ARG.ROUNDED" id="COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a></b>
EB63- 20 72 EB         JSR <a href="#ROUND.FAC">ROUND.FAC</a>     ROUND FAC USING EXTENSION
EB66- A2 06     <b><a name="MAF" id="MAF">MAF</a></b>    LDX #6            COPY 6 BYTES, INCLUDES SIGN
EB68- B5 9C     .1     LDA FAC-1,X
EB6A- 95 A4            STA ARG-1,X
EB6C- CA               DEX
EB6D- D0 F9            BNE .1
EB6F- 86 AC            STX FAC.EXTENSION ZERO FAC EXTENSION
EB71- 60        <b><a name="RTS.14" id="RTS.14">RTS.14</a></b> RTS
                *--------------------------------
                *      ROUND FAC USING EXTENSION BYTE
                *--------------------------------
                <b><a name="ROUND.FAC" id="ROUND.FAC">ROUND.FAC</a></b>
EB72- A5 9D            LDA FAC
EB74- F0 FB            BEQ <a href="#RTS.14">RTS.14</a>   FAC = 0, RETURN
EB76- 06 AC            ASL FAC.EXTENSION  IS FAC.EXTENSION &gt;= 128?
EB78- 90 F7            BCC <a href="#RTS.14">RTS.14</a>         NO, FINISHED
                *--------------------------------
                *      INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
                *--------------------------------
                <b><a name="INCREMENT.MANTISSA" id="INCREMENT.MANTISSA">INCREMENT.MANTISSA</a></b>
EB7A- 20 C6 E8         JSR <a href="#INCREMENT.FAC.MANTISSA">INCREMENT.FAC.MANTISSA</a>  YES, INCREMENT FAC
EB7D- D0 F2            BNE <a href="#RTS.14">RTS.14</a>         HIGH BYTE HAS BITS, FINISHED
EB7F- 4C 8F E8         JMP <a href="#NORMALIZE.FAC.6">NORMALIZE.FAC.6</a>  HI-BYTE=0, SO SHIFT LEFT
                *--------------------------------
                *      TEST FAC FOR ZERO AND SIGN
                *
                *      FAC &gt; 0, RETURN +1
                *      FAC = 0, RETURN  0
                *      FAC &lt; 0, RETURN -1
                *--------------------------------
EB82- A5 9D     <b><a name="SIGN" id="SIGN">SIGN</a></b>   LDA FAC      CHECK SIGN OF FAC AND
EB84- F0 09            BEQ <a href="#RTS.15">RTS.15</a>   RETURN -1,0,1 IN A-REG
                *--------------------------------
EB86- A5 A2     <b><a name="SIGN1" id="SIGN1">SIGN1</a></b>  LDA FAC.SIGN
                *--------------------------------
EB88- 2A        <b><a name="SIGN2" id="SIGN2">SIGN2</a></b>  ROL          MSBIT TO CARRY
EB89- A9 FF            LDA #$FF     -1
EB8B- B0 02            BCS <a href="#RTS.15">RTS.15</a>   MSBIT = 1
EB8D- A9 01            LDA #1       +1
EB8F- 60        <b><a name="RTS.15" id="RTS.15">RTS.15</a></b> RTS
                *--------------------------------
                *      "SGN" FUNCTION
                *--------------------------------
EB90- 20 82 EB  <b><a name="SGN" id="SGN">SGN</a></b>    JSR <a href="#SIGN">SIGN</a>        CONVERT FAC TO -1,0,1
                *--------------------------------
                *      CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
                *--------------------------------
EB93- 85 9E     <b><a name="FLOAT" id="FLOAT">FLOAT</a></b>  STA FAC+1    PUT IN HIGH BYTE OF MANTISSA
EB95- A9 00            LDA #0       CLEAR 2ND BYTE OF MANTISSA
EB97- 85 9F            STA FAC+2
EB99- A2 88            LDX #$88     USE EXPONENT 2^9
                *--------------------------------
                *      FLOAT UNSIGNED VALUE IN FAC+1,2
                *      (X) = EXPONENT
                *--------------------------------
                <b><a name="FLOAT.1" id="FLOAT.1">FLOAT.1</a></b>
EB9B- A5 9E            LDA FAC+1    MSBIT=0, SET CARRY; =1, CLEAR CARRY
EB9D- 49 FF            EOR #$FF
EB9F- 2A               ROL
                *--------------------------------
                *      FLOAT UNSIGNED VALUE IN FAC+1,2
                *      (X) = EXPONENT
                *      C=0 TO MAKE VALUE NEGATIVE
                *      C=1 TO MAKE VALUE POSITIVE
                *--------------------------------
                <b><a name="FLOAT.2" id="FLOAT.2">FLOAT.2</a></b>
EBA0- A9 00            LDA #0       CLEAR LOWER 16-BITS OF MANTISSA
EBA2- 85 A1            STA FAC+4
EBA4- 85 A0            STA FAC+3
EBA6- 86 9D            STX FAC      STORE EXPONENT
EBA8- 85 AC            STA FAC.EXTENSION CLEAR EXTENSION
EBAA- 85 A2            STA FAC.SIGN      MAKE SIGN POSITIVE
EBAC- 4C 29 E8         JMP <a href="#NORMALIZE.FAC.1">NORMALIZE.FAC.1</a>   IF C=0, WILL NEGATE FAC
                *--------------------------------
                *      "ABS" FUNCTION
                *--------------------------------
EBAF- 46 A2     <b><a name="ABS" id="ABS">ABS</a></b>    LSR FAC.SIGN      CHANGE SIGN TO +
EBB1- 60               RTS
                *--------------------------------
                *      COMPARE FAC WITH PACKED # AT (Y,A)
                *      RETURN A=1,0,-1 AS (Y,A) IS &lt;,=,&gt; FAC
                *--------------------------------
EBB2- 85 60     <b><a name="FCOMP" id="FCOMP">FCOMP</a></b>  STA DEST     USE DEST FOR PNTR
                *--------------------------------
                *      SPECIAL ENTRY FROM "NEXT" PROCESSOR
                *      "DEST" ALREADY SET UP
                *--------------------------------
EBB4- 84 61     <b><a name="FCOMP2" id="FCOMP2">FCOMP2</a></b> STY DEST+1
EBB6- A0 00            LDY #0       GET EXPONENT OF COMPARAND
EBB8- B1 60            LDA (DEST),Y
EBBA- C8               INY          POINT AT NEXT BYTE
EBBB- AA               TAX          EXPONENT TO X-REG
EBBC- F0 C4            BEQ <a href="#SIGN">SIGN</a>     IF COMPARAND=0, "SIGN" COMPARES FAC
EBBE- B1 60            LDA (DEST),Y GET HI-BYTE OF MANTISSA
EBC0- 45 A2            EOR FAC.SIGN COMPARE WITH FAC SIGN
EBC2- 30 C2            BMI <a href="#SIGN1">SIGN1</a>    DIFFERENT SIGNS, "SIGN" GIVES ANSWER
EBC4- E4 9D            CPX FAC      SAME SIGN, SO COMPARE EXPONENTS
EBC6- D0 21            BNE .1       DIFFERENT, SO SUFFICIENT TEST
EBC8- B1 60            LDA (DEST),Y SAME EXPONENT, COMPARE MANTISSA
EBCA- 09 80            ORA #$80     SET INVISIBLE NORMALIZED BIT
EBCC- C5 9E            CMP FAC+1
EBCE- D0 19            BNE .1       NOT SAME, SO SUFFICIENT
EBD0- C8               INY          SAME, COMPARE MORE MANTISSA
EBD1- B1 60            LDA (DEST),Y
EBD3- C5 9F            CMP FAC+2
EBD5- D0 12            BNE .1       NOT SAME, SO SUFFICIENT
EBD7- C8               INY          SAME, COMPARE MORE MANTISSA
EBD8- B1 60            LDA (DEST),Y
EBDA- C5 A0            CMP FAC+3
EBDC- D0 0B            BNE .1       NOT SAME, SO SUFFICIENT
EBDE- C8               INY          SAME, COMPARE REST OF MANTISSA
EBDF- A9 7F            LDA #$7F    ARTIFICIAL EXTENSION BYTE FOR COMPARAND
EBE1- C5 AC            CMP FAC.EXTENSION
EBE3- B1 60            LDA (DEST),Y
EBE5- E5 A1            SBC FAC+4
EBE7- F0 28            BEQ <a href="#RTS.16">RTS.16</a>   NUMBERS ARE EQUAL, RETURN (A)=0
EBE9- A5 A2     .1     LDA FAC.SIGN NUMBERS ARE DIFFERENT
EBEB- 90 02            BCC .2       FAC IS LARGER MAGNITUDE
EBED- 49 FF            EOR #$FF     FAC IS SMALLER MAGNITUDE
                * &lt;&lt;&lt;  NOTE THAT ABOVE THREE LINES CAN BE SHORTENED: &gt;&gt;&gt;
                * &lt;&lt;&lt;  .1  ROR              PUT CARRY INTO SIGN BIT  &gt;&gt;&gt;
                * &lt;&lt;&lt;      EOR FAC.SIGN     TOGGLE WITH SIGN OF FAC  &gt;&gt;&gt;
EBEF- 4C 88 EB  .2     JMP <a href="#SIGN2">SIGN2</a>    CONVERT +1 OR -1
                *--------------------------------
                *      QUICK INTEGER FUNCTION
                *
                *      CONVERTS FP VALUE IN FAC TO INTEGER VALUE
                *      IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
                *      EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
                *
                *      THIS SUBROUTINE ASSUMES THE EXPONENT &lt; 32.
                *--------------------------------
EBF2- A5 9D     <b><a name="QINT" id="QINT">QINT</a></b>   LDA FAC      LOOK AT FAC EXPONENT
EBF4- F0 4A            BEQ <a href="#QINT.3">QINT.3</a>   FAC=0, SO FINISHED
EBF6- 38               SEC          GET -(NUMBER OF FRACTIONAL BITS)
EBF7- E9 A0            SBC #$A0          IN A-REG FOR SHIFT COUNT
EBF9- 24 A2            BIT <a href="#FAC.SIGN">FAC.SIGN</a> CHECK SIGN OF FAC
EBFB- 10 09            BPL .1       POSITIVE, CONTINUE
EBFD- AA               TAX          NEGATIVE, SO COMPLEMENT MANTISSA
EBFE- A9 FF            LDA #$FF     AND SET SIGN EXTENSION FOR SHIFT
EC00- 85 A4            STA SHIFT.SIGN.EXT
EC02- 20 A4 E8         JSR <a href="#COMPLEMENT.FAC.MANTISSA">COMPLEMENT.FAC.MANTISSA</a>
EC05- 8A               TXA          RESTORE BIT COUNT TO A-REG
EC06- A2 9D     .1     LDX #FAC     POINT SHIFT SUBROUTINE AT FAC
EC08- C9 F9            CMP #$F9     MORE THAN 7 BITS TO SHIFT?
EC0A- 10 06            BPL <a href="#QINT.2">QINT.2</a>   NO, SHORT SHIFT
EC0C- 20 F0 E8         JSR <a href="#SHIFT.RIGHT">SHIFT.RIGHT</a>   YES, USE GENERAL ROUTINE
EC0F- 84 A4            STY SHIFT.SIGN.EXT    Y=0, CLEAR SIGN EXTENSION
EC11- 60        <b><a name="RTS.16" id="RTS.16">RTS.16</a></b> RTS
                *--------------------------------
EC12- A8        <b><a name="QINT.2" id="QINT.2">QINT.2</a></b> TAY          SAVE SHIFT COUNT
EC13- A5 A2            LDA FAC.SIGN      GET SIGN BIT
EC15- 29 80            AND #$80
EC17- 46 9E            LSR FAC+1         START RIGHT SHIFT
EC19- 05 9E            ORA FAC+1         AND MERGE WITH SIGN
EC1B- 85 9E            STA FAC+1
EC1D- 20 07 E9         JSR <a href="#SHIFT.RIGHT.4">SHIFT.RIGHT.4</a>     JUMP INTO MIDDLE OF SHIFTER
EC20- 84 A4            STY SHIFT.SIGN.EXT    Y=0, CLEAR SIGN EXTENSION
EC22- 60               RTS
                *--------------------------------
                *      "INT" FUNCTION
                *
                *      USES QINT TO CONVERT (FAC) TO INTEGER FORM,
                *      AND THEN REFLOATS THE INTEGER.
                *      &lt;&lt;&lt; A FASTER APPROACH WOULD SIMPLY CLEAR &gt;&gt;&gt;
                *      &lt;&lt;&lt; THE FRACTIONAL BITS BY ZEROING THEM  &gt;&gt;&gt;
                *--------------------------------
EC23- A5 9D     <b><a name="INT" id="INT">INT</a></b>    LDA FAC      CHECK IF EXPONENT &lt; 32
EC25- C9 A0            CMP #$A0     BECAUSE IF &gt; 31 THERE IS NO FRACTION
EC27- B0 20            BCS <a href="#RTS.17">RTS.17</a>   NO FRACTION, WE ARE FINISHED
EC29- 20 F2 EB         JSR <a href="#QINT">QINT</a>     USE GENERAL INTEGER CONVERSION
EC2C- 84 AC            STY FAC.EXTENSION  Y=0, CLEAR EXTENSION
EC2E- A5 A2            LDA FAC.SIGN      GET SIGN OF VALUE
EC30- 84 A2            STY FAC.SIGN      Y=0, CLEAR SIGN
EC32- 49 80            EOR #$80          TOGGLE ACTUAL SIGN
EC34- 2A               ROL               AND SAVE IN CARRY
EC35- A9 A0            LDA #$A0          SET EXPONENT TO 32
EC37- 85 9D            STA FAC           BECAUSE 4-BYTE INTEGER NOW
EC39- A5 A1            LDA FAC+4         SAVE LOW 8-BITS OF INTEGER FORM
EC3B- 85 0D            STA CHARAC        FOR EXP AND POWER
EC3D- 4C 29 E8         JMP <a href="#NORMALIZE.FAC.1">NORMALIZE.FAC.1</a>  NORMALIZE TO FINISH CONVERSION
                *--------------------------------
EC40- 85 9E     <b><a name="QINT.3" id="QINT.3">QINT.3</a></b> STA FAC+1    FAC=0, SO CLEAR ALL 4 BYTES FOR
EC42- 85 9F            STA FAC+2    INTEGER VERSION
EC44- 85 A0            STA FAC+3
EC46- 85 A1            STA FAC+4
EC48- A8               TAY          Y=0 TOO
EC49- 60        <b><a name="RTS.17" id="RTS.17">RTS.17</a></b> RTS
         1010 *--------------------------------
                *      CONVERT STRING TO FP VALUE IN FAC
                *
                *      STRING POINTED TO BY TXTPTR
                *      FIRST CHAR ALREADY SCANNED BY CHRGET
                *      (A) = FIRST CHAR, C=0 IF DIGIT.
                *--------------------------------
EC4A- A0 00     <b><a name="FIN" id="FIN">FIN</a></b>    LDY #0       CLEAR WORKING AREA ($99...$A3)
EC4C- A2 0A            LDX #10   TMPEXP, EXPON, DPFLG, EXPSGN, FAC, SERLEN
EC4E- 94 99     .1     STY TMPEXP,X
EC50- CA               DEX
EC51- 10 FB            BPL .1
                *--------------------------------
EC53- 90 0F            BCC <a href="#FIN.2">FIN.2</a>    FIRST CHAR IS A DIGIT
EC55- C9 2D            CMP #'-'     CHECK FOR LEADING SIGN
EC57- D0 04            BNE .2       NOT MINUS
EC59- 86 A3            STX SERLEN   MINUS, SET SERLEN = $FF FOR FLAG
EC5B- F0 04            BEQ <a href="#FIN.1">FIN.1</a>    ...ALWAYS
EC5D- C9 2B     .2     CMP #'+'     MIGHT BE PLUS
EC5F- D0 05            BNE <a href="#FIN.3">FIN.3</a>    NOT PLUS EITHER, CHECK DECIMAL POINT
                *--------------------------------
EC61- 20 B1 00  <b><a name="FIN.1" id="FIN.1">FIN.1</a></b>  JSR <a href="#CHRGET">CHRGET</a>   GET NEXT CHAR OF STRING
                *--------------------------------
EC64- 90 5B     <b><a name="FIN.2" id="FIN.2">FIN.2</a></b>  BCC <a href="#FIN.9">FIN.9</a>    INSERT THIS DIGIT
                *--------------------------------
EC66- C9 2E     <b><a name="FIN.3" id="FIN.3">FIN.3</a></b>  CMP #'.'     CHECK FOR DECIMAL POINT
EC68- F0 2E            BEQ <a href="#FIN.10">FIN.10</a>   YES
EC6A- C9 45            CMP #'E'     CHECK FOR EXPONENT PART
EC6C- D0 30            BNE <a href="#FIN.7">FIN.7</a>    NO, END OF NUMBER
EC6E- 20 B1 00         JSR <a href="#CHRGET">CHRGET</a>   YES, START CONVERTING EXPONENT
EC71- 90 17            BCC <a href="#FIN.5">FIN.5</a>    EXPONENT DIGIT
EC73- C9 C9            CMP #TOKEN.MINUS  NEGATIVE EXPONENT?
EC75- F0 0E            BEQ .1            YES
EC77- C9 2D            CMP #'-'          MIGHT NOT BE TOKENIZED YET
EC79- F0 0A            BEQ .1            YES, IT IS NEGATIVE
EC7B- C9 C8            CMP #TOKEN.PLUS   OPTIONAL "+"
EC7D- F0 08            BEQ <a href="#FIN.4">FIN.4</a>         YES
EC7F- C9 2B            CMP #'+'          MIGHT NOT BE TOKENIZED YET
EC81- F0 04            BEQ <a href="#FIN.4">FIN.4</a>         YES, FOUND "+"
EC83- D0 07            BNE <a href="#FIN.6">FIN.6</a>    ...ALWAYS, NUMBER COMPLETED
EC85- 66 9C     .1     ROR EXPSGN   C=1, SET FLAG NEGATIVE
                *--------------------------------
EC87- 20 B1 00  <b><a name="FIN.4" id="FIN.4">FIN.4</a></b>  JSR <a href="#CHRGET">CHRGET</a>   GET NEXT DIGIT OF EXPONENT
                *--------------------------------
EC8A- 90 5C     <b><a name="FIN.5" id="FIN.5">FIN.5</a></b>  BCC <a href="#GETEXP">GETEXP</a>   CHAR IS A DIGIT OF EXPONENT
                *--------------------------------
EC8C- 24 9C     <b><a name="FIN.6" id="FIN.6">FIN.6</a></b>  BIT <a href="#EXPSGN">EXPSGN</a>   END OF NUMBER, CHECK EXP SIGN
EC8E- 10 0E            BPL <a href="#FIN.7">FIN.7</a>    POSITIVE EXPONENT
EC90- A9 00            LDA #0       NEGATIVE EXPONENT
EC92- 38               SEC          MAKE 2'S COMPLEMENT OF EXPONENT
EC93- E5 9A            SBC EXPON
EC95- 4C A0 EC         JMP <a href="#FIN.8">FIN.8</a>
                *--------------------------------
                *      FOUND A DECIMAL POINT
                *--------------------------------
EC98- 66 9B     <b><a name="FIN.10" id="FIN.10">FIN.10</a></b> ROR DPFLG    C=1, SET DPFLG FOR DECIMAL POINT
EC9A- 24 9B            BIT <a href="#DPFLG">DPFLG</a>    CHECK IF PREVIOUS DEC. PT.
EC9C- 50 C3            BVC <a href="#FIN.1">FIN.1</a>    NO PREVIOUS DECIMAL POINT
                *      A SECOND DECIMAL POINT IS TAKEN AS A TERMINATOR
                *      TO THE NUMERIC STRING.
                *      "A=11..22" WILL GIVE A SYNTAX ERROR, BECAUSE
                *      IT IS TWO NUMBERS WITH NO OPERATOR BETWEEN.
                *      "PRINT 11..22" GIVES NO ERROR, BECAUSE IT IS
                *      JUST THE CONCATENATION OF TWO NUMBERS.
                *--------------------------------
                *      NUMBER TERMINATED, ADJUST EXPONENT NOW
                *--------------------------------
EC9E- A5 9A     <b><a name="FIN.7" id="FIN.7">FIN.7</a></b>  LDA EXPON    E-VALUE
ECA0- 38        <b><a name="FIN.8" id="FIN.8">FIN.8</a></b>  SEC          MODIFY WITH COUNT OF DIGITS
ECA1- E5 99            SBC TMPEXP        AFTER THE DECIMAL POINT
ECA3- 85 9A            STA EXPON    COMPLETE CURRENT EXPONENT
ECA5- F0 12            BEQ .15      NO ADJUST NEEDED IF EXP=0
ECA7- 10 09            BPL .14      EXP&gt;0, MULTIPLY BY TEN
ECA9- 20 55 EA  .13    JSR <a href="#DIV10">DIV10</a>    EXP&lt;0, DIVIDE BY TEN
ECAC- E6 9A            INC EXPON    UNTIL EXP=0
ECAE- D0 F9            BNE .13
ECB0- F0 07            BEQ .15      ...ALWAYS, WE ARE FINISHED
ECB2- 20 39 EA  .14    JSR <a href="#MUL10">MUL10</a>    EXP&gt;0, MULTIPLY BKY TEN
ECB5- C6 9A            DEC EXPON    UNTIL EXP=0
ECB7- D0 F9            BNE .14
ECB9- A5 A3     .15    LDA SERLEN   IS WHOLE NUMBER NEGATIVE?
ECBB- 30 01            BMI .16      YES
ECBD- 60               RTS          NO, RETURN, WHOLE JOB DONE!
ECBE- 4C D0 EE  .16    JMP <a href="#NEGOP">NEGOP</a>    NEGATIVE NUMBER, SO NEGATE FAC
                *--------------------------------
                *      ACCUMULATE A DIGIT INTO FAC
                *--------------------------------
ECC1- 48        <b><a name="FIN.9" id="FIN.9">FIN.9</a></b>  PHA          SAVE DIGIT
ECC2- 24 9B            BIT <a href="#DPFLG">DPFLG</a>    SEEN A DECIMAL POINT YET?
ECC4- 10 02            BPL .1       NO, STILL IN INTEGER PART
ECC6- E6 99            INC TMPEXP   YES, COUNT THE FRACTIONAL DIGIT
ECC8- 20 39 EA  .1     JSR <a href="#MUL10">MUL10</a>    FAC = FAC * 10
ECCB- 68               PLA          CURRENT DIGIT
ECCC- 38               SEC          &lt;&lt;&lt;SHORTER HERE TO JUST "AND #$0F"&gt;&gt;&gt;
ECCD- E9 30            SBC #'0'     &lt;&lt;&lt;TO CONVERT ASCII TO BINARY FORM&gt;&gt;&gt;
ECCF- 20 D5 EC         JSR <a href="#ADDACC">ADDACC</a>   ADD THE DIGIT
ECD2- 4C 61 EC         JMP <a href="#FIN.1">FIN.1</a>    GO BACK FOR MORE
                *--------------------------------
                *      ADD (A) TO FAC
                *--------------------------------
ECD5- 48        <b><a name="ADDACC" id="ADDACC">ADDACC</a></b> PHA          SAVE ADDEND
ECD6- 20 63 EB         JSR <a href="#COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a>
ECD9- 68               PLA          GET ADDEND AGAIN
ECDA- 20 93 EB         JSR <a href="#FLOAT">FLOAT</a>    CONVERT TO FP VALUE IN FAC
ECDD- A5 AA            LDA ARG.SIGN
ECDF- 45 A2            EOR FAC.SIGN
ECE1- 85 AB            STA SGNCPR
ECE3- A6 9D            LDX FAC      TO SIGNAL IF FAC=0
ECE5- 4C C1 E7         JMP <a href="#FADDT">FADDT</a>    PERFORM THE ADDITION
                *--------------------------------
                *      ACCUMULATE DIGIT OF EXPONENT
                *--------------------------------
ECE8- A5 9A     <b><a name="GETEXP" id="GETEXP">GETEXP</a></b> LDA EXPON    CHECK CURRENT VALUE
ECEA- C9 0A            CMP #10      FOR MORE THAN 2 DIGITS
ECEC- 90 09            BCC .1       NO, THIS IS 1ST OR 2ND DIGIT
ECEE- A9 64            LDA #100     EXPONENT TOO BIG
ECF0- 24 9C            BIT <a href="#EXPSGN">EXPSGN</a>   UNLESS IT IS NEGATIVE
ECF2- 30 11            BMI .2       LARGE NEGATIVE EXPONENT MAKES FAC=0
ECF4- 4C D5 E8         JMP <a href="#OVERFLOW">OVERFLOW</a> LARGE POSITIVE EXPONENT IS ERROR
ECF7- 0A        .1     ASL          EXPONENT TIMES 10
ECF8- 0A               ASL
ECF9- 18               CLC
ECFA- 65 9A            ADC EXPON
ECFC- 0A               ASL
ECFD- 18               CLC          &lt;&lt;&lt; ASL ALREADY DID THIS! &gt;&gt;&gt;
ECFE- A0 00            LDY #0       ADD THE NEW DIGIT
ED00- 71 B8            ADC (TXTPTR),Y    BUT THIS IS IN ASCII,
ED02- 38               SEC               SO ADJUST BACK TO BINARY
ED03- E9 30            SBC #'0'
ED05- 85 9A     .2     STA EXPON    NEW VALUE
ED07- 4C 87 EC         JMP <a href="#FIN.4">FIN.4</a>    BACK FOR MORE
                *--------------------------------
              1010 *--------------------------------
ED0A- 9B 3E BC
ED0D- 1F FD     <b><a name="CON.99999999.9" id="CON.99999999.9">CON.99999999.9</a></b> .HS 9B3EBC1FFD  99,999,999.9
ED0F- 9E 6E 6B
ED12- 27 FD     <b><a name="CON.999999999" id="CON.999999999">CON.999999999</a></b>  .HS 9E6E6B27FD  999,999,999
ED14- 9E 6E 6B
ED17- 28 00     <b><a name="CON.BILLION" id="CON.BILLION">CON.BILLION</a></b>    .HS 9E6E6B2800  1,000,000,000
                *--------------------------------
                *      PRINT "IN &lt;LINE #&gt;"
                *--------------------------------
ED19- A9 58     <b><a name="INPRT" id="INPRT">INPRT</a></b>  LDA #QT.IN    PRINT " IN "
ED1B- A0 D3            LDY /QT.IN
ED1D- 20 31 ED         JSR <a href="#GO.STROUT">GO.STROUT</a>
ED20- A5 76            LDA CURLIN+1
ED22- A6 75            LDX CURLIN
                *--------------------------------
                *      PRINT A,X AS DECIMAL INTEGER
                *--------------------------------
ED24- 85 9E     <b><a name="LINPRT" id="LINPRT">LINPRT</a></b> STA FAC+1    PRINT A,X IN DECIMAL
ED26- 86 9F            STX FAC+2
ED28- A2 90            LDX #$90     EXPONENT = 2^16
ED2A- 38               SEC          CONVERT UNSIGNED
ED2B- 20 A0 EB         JSR <a href="#FLOAT.2">FLOAT.2</a>  CONVERT LINE # TO FP 
                *--------------------------------
                *      CONVERT (FAC) TO STRING, AND PRINT IT
                *--------------------------------
                <b><a name="PRINT.FAC" id="PRINT.FAC">PRINT.FAC</a></b>
ED2E- 20 34 ED         JSR <a href="#FOUT">FOUT</a>     CONVERT (FAC) TO STRING AT STACK
                *--------------------------------
                *      PRINT STRING STARTING AT Y,A
                *--------------------------------
                <b><a name="GO.STROUT" id="GO.STROUT">GO.STROUT</a></b>
ED31- 4C 3A DB         JMP <a href="#STROUT">STROUT</a>    PRINT STRING AT A,Y
                *--------------------------------
                *      CONVERT (FAC) TO STRING STARTING AT STACK
                *      RETURN WITH (Y,A) POINTING AT STRING
                *--------------------------------
ED34- A0 01     <b><a name="FOUT" id="FOUT">FOUT</a></b>   LDY #1       NORMAL ENTRY PUTS STRING AT STACK...
                *--------------------------------
                *      "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
                *      SO THAT RESULT STRING STARTS AT STACK-1
                *      (THIS IS USED AS A FLAG)
                *--------------------------------
ED36- A9 2D     <b><a name="FOUT.1" id="FOUT.1">FOUT.1</a></b> LDA #'-'     IN CASE VALUE NEGATIVE
ED38- 88               DEY          BACK UP PNTR
ED39- 24 A2            BIT <a href="#FAC.SIGN">FAC.SIGN</a>
ED3B- 10 04            BPL .1       VALUE IS +
ED3D- C8               INY          VALUE IS -
ED3E- 99 FF 00         STA STACK-1,Y     EMIT "-"
ED41- 85 A2     .1     STA FAC.SIGN MAKE FAC.SIGN POSITIVE ($2D)
ED43- 84 AD            STY STRNG2   SAVE STRING PNTR
ED45- C8               INY
ED46- A9 30            LDA #'0'     IN CASE (FAC)=0
ED48- A6 9D            LDX FAC      NUMBER=0?
ED4A- D0 03            BNE .2       NO, (FAC) NOT ZERO
ED4C- 4C 57 EE         JMP <a href="#FOUT.4">FOUT.4</a>   YES, FINISHED
                *--------------------------------
ED4F- A9 00     .2     LDA #0       STARTING VALUE FOR TMPEXP
ED51- E0 80            CPX #$80     ANY INTEGER PART?
ED53- F0 02            BEQ .3       NO, BTWN .5 AND .999999999
ED55- B0 09            BCS .4       YES
                *--------------------------------
ED57- A9 14     .3     LDA #CON.BILLION  MULTIPLY BY 1E9
ED59- A0 ED            LDY /CON.BILLION  TO GIVE ADJUSTMENT A HEAD START
ED5B- 20 7F E9         JSR <a href="#FMULT">FMULT</a>
ED5E- A9 F7            LDA #-9           EXPONENT ADJUSTMENT
ED60- 85 99     .4     STA TMPEXP        0 OR -9
                *--------------------------------
                *      ADJUST UNTIL 1E8 &lt;= (FAC) &lt;1E9
                *--------------------------------
ED62- A9 0F     .5     LDA #CON.999999999
ED64- A0 ED            LDY /CON.999999999
ED66- 20 B2 EB         JSR <a href="#FCOMP">FCOMP</a>    COMPARE TO 1E9-1
ED69- F0 1E            BEQ .10      (FAC) = 1E9-1
ED6B- 10 12            BPL .8       TOO LARGE, DIVIDE BY TEN
ED6D- A9 0A     .6     LDA #CON.99999999.9   COMPARE TO 1E8-.1
ED6F- A0 ED            LDY /CON.99999999.9
ED71- 20 B2 EB         JSR <a href="#FCOMP">FCOMP</a>    COMPARE TO 1E8-.1
ED74- F0 02            BEQ .7       (FAC) = 1E8-.1
ED76- 10 0E            BPL .9       IN RANGE, ADJUSTMENT FINISHED
ED78- 20 39 EA  .7     JSR <a href="#MUL10">MUL10</a>    TOO SMALL, MULTIPLY BY TEN
ED7B- C6 99            DEC TMPEXP   KEEP TRACK OF MULTIPLIES
ED7D- D0 EE            BNE .6       ...ALWAYS
ED7F- 20 55 EA  .8     JSR <a href="#DIV10">DIV10</a>    TOO LARGE, DIVIDE BY TEN
ED82- E6 99            INC TMPEXP   KEEP TRACK OF DIVISIONS
ED84- D0 DC            BNE .5       ...ALWAYS
                *--------------------------------
ED86- 20 A0 E7  .9     JSR <a href="#FADDH">FADDH</a>    ROUND ADJUSTED RESULT
ED89- 20 F2 EB  .10    JSR <a href="#QINT">QINT</a>   CONVERT ADJUSTED VALUE TO 32-BIT INTEGER
                *--------------------------------
                *      FAC+1...FAC+4 IS NOW IN INTEGER FORM
                *      WITH POWER OF TEN ADJUSTMENT IN TMPEXP
                *
                *      IF -10 &lt; TMPEXP &gt; 1, PRINT IN DECIMAL FORM
                *      OTHERWISE, PRINT IN EXPONENTIAL FORM
                *--------------------------------
ED8C- A2 01     <b><a name="FOUT.2" id="FOUT.2">FOUT.2</a></b> LDX #1       ASSUME 1 DIGIT BEFORE "."
ED8E- A5 99            LDA TMPEXP   CHECK RANGE
ED90- 18               CLC
ED91- 69 0A            ADC #10
ED93- 30 09            BMI .1       &lt; .01, USE EXPONENTIAL FORM
ED95- C9 0B            CMP #11
ED97- B0 06            BCS .2       &gt;= 1E10, USE EXPONENTIAL FORM
ED99- 69 FF            ADC #$FF     LESS 1 GIVES INDEX FOR "."
ED9B- AA               TAX
ED9C- A9 02            LDA #2       SET REMAINING EXPONENT = 0
ED9E- 38        .1     SEC          COMPUTE REMAINING EXPONENT
ED9F- E9 02     .2     SBC #2
EDA1- 85 9A            STA EXPON    VALUE FOR "E+XX" OR "E-XX"
EDA3- 86 99            STX TMPEXP   INDEX FOR DECIMAL POINT
EDA5- 8A               TXA          SEE IF "." COMES FIRST
EDA6- F0 02            BEQ .3       YES
EDA8- 10 13            BPL .5       NO, LATER
EDAA- A4 AD     .3     LDY STRNG2   GET INDEX INTO STRING BEING BUILT
EDAC- A9 2E            LDA #'.'     STORE A DECIMAL POINT
EDAE- C8               INY
EDAF- 99 FF 00         STA STACK-1,Y
EDB2- 8A               TXA          SEE IF NEED ".0"
EDB3- F0 06            BEQ .4       NO
EDB5- A9 30            LDA #'0'     YES, STORE "0"
EDB7- C8               INY
EDB8- 99 FF 00         STA STACK-1,Y
EDBB- 84 AD     .4     STY STRNG2   SAVE OUTPUT INDEX AGAIN
                *--------------------------------
                *     NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
                *--------------------------------
EDBD- A0 00     .5     LDY #0       INDEX TO TABLE OF POWERS OF TEN
EDBF- A2 80            LDX #$80    STARTING VALUE FOR DIGIT WITH DIRECTION
EDC1- A5 A1     .6     LDA FAC+4    START BY ADDING -100000000 UNTIL
EDC3- 18               CLC          OVERSHOOT.  THEN ADD +10000000,
EDC4- 79 6C EE         ADC DECTBL+3,Y    THEN ADD -1000000, THEN ADD
EDC7- 85 A1            STA FAC+4         +100000, AND SO ON.
EDC9- A5 A0            LDA FAC+3    THE # OF TIMES EACH POWER IS ADDED
EDCB- 79 6B EE         ADC DECTBL+2,Y   IS 1 MORE THAN CORRESPONDING DIGIT
EDCE- 85 A0            STA FAC+3
EDD0- A5 9F            LDA FAC+2
EDD2- 79 6A EE         ADC DECTBL+1,Y
EDD5- 85 9F            STA FAC+2
EDD7- A5 9E            LDA FAC+1
EDD9- 79 69 EE         ADC DECTBL,Y
EDDC- 85 9E            STA FAC+1
EDDE- E8               INX          COUNT THE ADD
EDDF- B0 04            BCS .7       IF C=1 AND X NEGATIVE, KEEP ADDING
EDE1- 10 DE            BPL .6       IF C=0 AND X POSITIVE, KEEP ADDING
EDE3- 30 02            BMI .8       IF C=0 AND X NEGATIVE, WE OVERSHOT
EDE5- 30 DA     .7     BMI .6       IF C=1 AND X POSITIVE, WE OVERSHOT
EDE7- 8A        .8     TXA          OVERSHOT, SO MAKE X INTO A DIGIT
EDE8- 90 04            BCC .9       HOW DEPENDS ON DIRECTION WE WERE GOING
EDEA- 49 FF            EOR #$FF     DIGIT = 9-X
EDEC- 69 0A            ADC #10
EDEE- 69 2F     .9     ADC #'0'-1   MAKE DIGIT INTO ASCII
EDF0- C8               INY          ADVANCE TO NEXT SMALLER POWER OF TEN
EDF1- C8               INY
EDF2- C8               INY
EDF3- C8               INY
EDF4- 84 83            STY VARPNT   SAVE PNTR TO POWERS
EDF6- A4 AD            LDY STRNG2   GET OUTPUT PNTR
EDF8- C8               INY          STORE THE DIGIT
EDF9- AA               TAX          SAVE DIGIT, HI-BIT IS DIRECTION
EDFA- 29 7F            AND #$7F     MAKE SURE $30...$39 FOR STRING
EDFC- 99 FF 00         STA STACK-1,Y
EDFF- C6 99            DEC TMPEXP   COUNT THE DIGIT
EE01- D0 06            BNE .10      NOT TIME FOR "." YET
EE03- A9 2E            LDA #'.'     TIME, SO STORE THE DECIMAL POINT
EE05- C8               INY
EE06- 99 FF 00         STA STACK-1,Y
EE09- 84 AD     .10    STY STRNG2   SAVE OUTPUT PNTR AGAIN
EE0B- A4 83            LDY VARPNT   GET PNTR TO POWERS
EE0D- 8A               TXA          GET DIGIT WITH HI-BIT = DIRECTION
EE0E- 49 FF            EOR #$FF     CHANGE DIRECTION
EE10- 29 80            AND #$80     $00 IF ADDING, $80 IF SUBTRACTING
EE12- AA               TAX
EE13- C0 24            CPY #DECTBL.END-DECTBL
EE15- D0 AA            BNE .6       NOT FINISHED YET
                *--------------------------------
                *      NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
                *      BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
                *      DECIMAL POINT.
                *--------------------------------
EE17- A4 AD     <b><a name="FOUT.3" id="FOUT.3">FOUT.3</a></b> LDY STRNG2   POINTS AT LAST STORED CHAR
EE19- B9 FF 00  .1     LDA STACK-1,Y     SEE IF LOPPABLE
EE1C- 88               DEY
EE1D- C9 30            CMP #'0'     SUPPRESS TRAILING ZEROES
EE1F- F0 F8            BEQ .1       YES, KEEP LOOPING
EE21- C9 2E            CMP #'.'     SUPPRESS TRAILING DECIMAL POINT
EE23- F0 01            BEQ .2       ".", SO WRITE OVER IT
EE25- C8               INY          NOT ".", SO INCLUDE IN STRING AGAIN
EE26- A9 2B     .2     LDA #'+'     PREPARE FOR POSITIVE EXPONENT "E+XX"
EE28- A6 9A            LDX EXPON    SEE IF ANY E-VALUE
EE2A- F0 2E            BEQ <a href="#FOUT.5">FOUT.5</a>   NO, JUST MARK END OF STRING
EE2C- 10 08            BPL .3       YES, AND IT IS POSITIVE
EE2E- A9 00            LDA #0       YES, AND IT IS NEGATIVE
EE30- 38               SEC          COMPLEMENT THE VALUE
EE31- E5 9A            SBC EXPON
EE33- AA               TAX          GET MAGNITUDE IN X
EE34- A9 2D            LDA #'-'     E SIGN
EE36- 99 01 01  .3     STA STACK+1,Y     STORE SIGN IN STRING
EE39- A9 45            LDA #'E'          STORE "E" IN STRING BEFORE SIGN
EE3B- 99 00 01         STA STACK,Y
EE3E- 8A               TXA          EXPONENT MAGNITUDE IN A-REG
EE3F- A2 2F            LDX #'0'-1   SEED FOR EXPONENT DIGIT
EE41- 38               SEC          CONVERT TO DECIMAL
EE42- E8        .4     INX          COUNT THE SUBTRACTION
EE43- E9 0A            SBC #10      TEN'S DIGIT
EE45- B0 FB            BCS .4       MORE TENS TO SUBTRACT
EE47- 69 3A            ADC #'0'+10  CONVERT REMAINDER TO ONE'S DIGIT
EE49- 99 03 01         STA STACK+3,Y     STORE ONE'S DIGIT
EE4C- 8A               TXA
EE4D- 99 02 01         STA STACK+2,Y     STORE TEN'S DIGIT
EE50- A9 00            LDA #0       MARK END OF STRING WITH $00
EE52- 99 04 01         STA STACK+4,Y
EE55- F0 08            BEQ <a href="#FOUT.6">FOUT.6</a>   ...ALWAYS
EE57- 99 FF 00  <b><a name="FOUT.4" id="FOUT.4">FOUT.4</a></b> STA STACK-1,Y     STORE "0" IN ASCII
EE5A- A9 00     <b><a name="FOUT.5" id="FOUT.5">FOUT.5</a></b> LDA #0       STORE $00 ON END OF STRING
EE5C- 99 00 01         STA STACK,Y
EE5F- A9 00     <b><a name="FOUT.6" id="FOUT.6">FOUT.6</a></b> LDA #STACK   POINT Y,A AT BEGINNING OF STRING
EE61- A0 01            LDY /STACK   (STR$ STARTED STRING AT STACK-1, BUT
EE63- 60               RTS          STR$ DOESN'T USE Y,A ANYWAY.)
                *--------------------------------
EE64- 80 00 00
EE67- 00 00     <b><a name="CON.HALF" id="CON.HALF">CON.HALF</a></b>   .HS 8000000000  FP CONSTANT 0.5
                *--------------------------------
                *      POWERS OF 10 FROM 1E8 DOWN TO 1,
                *      AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
                *--------------------------------
EE69- FA 0A 1F
EE6C- 00        <b><a name="DECTBL" id="DECTBL">DECTBL</a></b> .HS FA0A1F00  -100000000
EE6D- 00 98 96
EE70- 80               .HS 00989680  10000000
EE71- FF F0 BD
EE74- C0               .HS FFF0BDC0  -1000000
EE75- 00 01 86
EE78- A0               .HS 000186A0  100000
EE79- FF FF D8
EE7C- F0               .HS FFFFD8F0  -10000
EE7D- 00 00 03
EE80- E8               .HS 000003E8  1000
EE81- FF FF FF
EE84- 9C               .HS FFFFFF9C  -100
EE85- 00 00 00
EE88- 0A               .HS 0000000A  10
EE89- FF FF FF
EE8C- FF               .HS FFFFFFFF  -1
                <b><a name="DECTBL.END" id="DECTBL.END">DECTBL.END</a></b>
                *--------------------------------
              1010 *--------------------------------
                *      "SQR" FUNCTION
                *
                *      &lt;&lt;&lt; UNFORTUNATELY, RATHER THAN A NEWTON-RAPHSON &gt;&gt;&gt;
                *      &lt;&lt;&lt; ITERATION, APPLESOFT USES EXPONENTIATION    &gt;&gt;&gt;
                *      &lt;&lt;&lt; SQR(X) = X^.5                               &gt;&gt;&gt;
                *--------------------------------
EE8D- 20 63 EB  <b><a name="SQR" id="SQR">SQR</a></b>    JSR <a href="#COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a>
EE90- A9 64            LDA #CON.HALF     SET UP POWER OF 0.5
EE92- A0 EE            LDY /CON.HALF
EE94- 20 F9 EA         JSR <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>
                *--------------------------------
                *      EXPONENTIATION OPERATION
                *
                *      ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
                *--------------------------------
EE97- F0 70     <b><a name="FPWRT" id="FPWRT">FPWRT</a></b>  BEQ <a href="#EXP">EXP</a>      IF FAC=0, ARG^FAC=EXP(0)
EE99- A5 A5            LDA ARG      IF ARG=0, ARG^FAC=0
EE9B- D0 03            BNE .1       NEITHER IS ZERO
EE9D- 4C 50 E8         JMP <a href="#STA.IN.FAC.SIGN.AND.EXP">STA.IN.FAC.SIGN.AND.EXP</a>   SET FAC = 0
EEA0- A2 8A     .1     LDX #TEMP3   SAVE FAC IN TEMP3
EEA2- A0 00            LDY #0
EEA4- 20 2B EB         JSR <a href="#STORE.FAC.AT.YX.ROUNDED">STORE.FAC.AT.YX.ROUNDED</a>
EEA7- A5 AA            LDA ARG.SIGN NORMALLY, ARG MUST BE POSITIVE
EEA9- 10 0F            BPL .2       IT IS POSITIVE, SO ALL IS WELL
EEAB- 20 23 EC         JSR <a href="#INT">INT</a>      NEGATIVE, BUT OK IF INTEGRAL POWER
EEAE- A9 8A            LDA #TEMP3   SEE IF INT(FAC)=FAC
EEB0- A0 00            LDY #0
EEB2- 20 B2 EB         JSR <a href="#FCOMP">FCOMP</a>    IS IT AN INTEGER POWER?
EEB5- D0 03            BNE .2       NOT INTEGRAL,  WILL CAUSE ERROR LATER
EEB7- 98               TYA          MAKE ARG SIGN + AS IT IS MOVED TO FAC
EEB8- A4 0D            LDY CHARAC   INTEGRAL, SO ALLOW NEGATIVE ARG
EEBA- 20 55 EB  .2     JSR <a href="#MFA">MFA</a>      MOVE ARGUMENT TO FAC
EEBD- 98               TYA          SAVE FLAG FOR NEGATIVE ARG (0=+) 
EEBE- 48               PHA
EEBF- 20 41 E9         JSR <a href="#LOG">LOG</a>      GET LOG(ARG)
EEC2- A9 8A            LDA #TEMP3   MULTIPLY BY POWER
EEC4- A0 00            LDY #0
EEC6- 20 7F E9         JSR <a href="#FMULT">FMULT</a>
EEC9- 20 09 EF         JSR <a href="#EXP">EXP</a>      E ^ LOG(FAC)
EECC- 68               PLA          GET FLAG FOR NEGATIVE ARG
EECD- 4A               LSR          &lt;&lt;&lt;LSR,BCC COULD BE MERELY BPL&gt;&gt;&gt;
EECE- 90 0A            BCC <a href="#RTS.18">RTS.18</a>   NOT NEGATIVE, FINISHED
                *                   NEGATIVE ARG, SO NEGATE RESULT
                *--------------------------------
                *      NEGATE VALUE IN FAC
                *--------------------------------
EED0- A5 9D     <b><a name="NEGOP" id="NEGOP">NEGOP</a></b>  LDA FAC      IF FAC=0, NO NEED TO COMPLEMENT
EED2- F0 06            BEQ <a href="#RTS.18">RTS.18</a>   YES, FAC=0
EED4- A5 A2            LDA FAC.SIGN NO, SO TOGGLE SIGN
EED6- 49 FF            EOR #$FF
EED8- 85 A2            STA FAC.SIGN
EEDA- 60        <b><a name="RTS.18" id="RTS.18">RTS.18</a></b> RTS
                *--------------------------------
EEDB- 81 38 AA
EEDE- 3B 29     <b><a name="CON.LOG.E" id="CON.LOG.E">CON.LOG.E</a></b> .HS 8138AA3B29  LOG(E) TO BASE 2
                *--------------------------------
EEE0- 07        <b><a name="POLY.EXP" id="POLY.EXP">POLY.EXP</a></b> .DA #7          ( # OF TERMS IN POLYNOMIAL) - 1
EEE1- 71 34 58
EEE4- 3E 56              .HS 7134583E56  (LOG(2)^7)/8!
EEE6- 74 16 7E
EEE9- B3 1B              .HS 74167EB31B  (LOG(2)^6)/7!
EEEB- 77 2F EE
EEEE- E3 85              .HS 772FEEE385  (LOG(2)^5)/6!
EEF0- 7A 1D 84
EEF3- 1C 2A              .HS 7A1D841C2A  (LOG(2)^4)/5!
EEF5- 7C 63 59
EEF8- 58 0A              .HS 7C6359580A  (LOG(2)^3)/4!
EEFA- 7E 75 FD
EEFD- E7 C6              .HS 7E75FDE7C6  (LOG(2)^2)/3!
EEFF- 80 31 72
EF02- 18 10              .HS 8031721810  LOG(2)/2!
EF04- 81 00 00
EF07- 00 00              .HS 8100000000  1
                *--------------------------------
                *      "EXP" FUNCTION
                *
                *      FAC = E ^ FAC
                *--------------------------------
EF09- A9 DB     <b><a name="EXP" id="EXP">EXP</a></b>    LDA #CON.LOG.E    CONVERT TO POWER OF TWO PROBLEM
EF0B- A0 EE            LDY /CON.LOG.E    E^X = 2^(LOG2(E)*X)
EF0D- 20 7F E9         JSR <a href="#FMULT">FMULT</a>
EF10- A5 AC            LDA FAC.EXTENSION NON-STANDARD ROUNDING HERE
EF12- 69 50            ADC #$50          ROUND UP IF EXTENSION &gt; $AF
EF14- 90 03            BCC .1            NO, DON'T ROUND UP
EF16- 20 7A EB         JSR <a href="#INCREMENT.MANTISSA">INCREMENT.MANTISSA</a>
EF19- 85 92     .1     STA ARG.EXTENSION STRANGE VALUE
EF1B- 20 66 EB         JSR <a href="#MAF">MAF</a>      COPY FAC INTO ARG
EF1E- A5 9D            LDA FAC      MAXIMUM EXPONENT IS &lt; 128
EF20- C9 88            CMP #$88     WITHIN RANGE?
EF22- 90 03            BCC .3       YES
EF24- 20 2B EA  .2     JSR <a href="#OUTOFRNG">OUTOFRNG</a> OVERFLOW IF +, RETURN 0.0 IF -
EF27- 20 23 EC  .3     JSR <a href="#INT">INT</a>      GET INT(FAC)
EF2A- A5 0D            LDA CHARAC   THIS IS THE INETGRAL PART OF THE POWER
EF2C- 18               CLC          ADD TO EXPONENT BIAS + 1
EF2D- 69 81            ADC #$81
EF2F- F0 F3            BEQ .2       OVERFLOW
EF31- 38               SEC          BACK OFF TO NORMAL BIAS
EF32- E9 01            SBC #1
EF34- 48               PHA          SAVE EXPONENT
                *--------------------------------
EF35- A2 05            LDX #5       SWAP ARG AND FAC
EF37- B5 A5     .4     LDA ARG,X    &lt;&lt;&lt; WHY SWAP? IT IS DOING      &gt;&gt;&gt;
EF39- B4 9D            LDY FAC,X    &lt;&lt;&lt; -(A-B) WHEN (B-A) IS THE   &gt;&gt;&gt;
EF3B- 95 9D            STA FAC,X    &lt;&lt;&lt; SAME THING!                &gt;&gt;&gt;
EF3D- 94 A5            STY ARG,X
EF3F- CA               DEX
EF40- 10 F5            BPL .4
EF42- A5 92            LDA ARG.EXTENSION
EF44- 85 AC            STA FAC.EXTENSION
EF46- 20 AA E7         JSR <a href="#FSUBT">FSUBT</a>    POWER-INT(POWER) --&gt; FRACTIONAL PART
EF49- 20 D0 EE         JSR <a href="#NEGOP">NEGOP</a>
EF4C- A9 E0            LDA #POLY.EXP
EF4E- A0 EE            LDY /POLY.EXP
EF50- 20 72 EF         JSR <a href="#POLYNOMIAL">POLYNOMIAL</a>    COMPUTE F(X) ON FRACTIONAL PART
EF53- A9 00            LDA #0
EF55- 85 AB            STA SGNCPR
EF57- 68               PLA          GET EXPONENT
EF58- 20 10 EA         JSR <a href="#ADD.EXPONENTS.1">ADD.EXPONENTS.1</a>
EF5B- 60               RTS          &lt;&lt;&lt; WASTED BYTE HERE, COULD HAVE &gt;&gt;&gt;
                *                   &lt;&lt;&lt; JUST USED "JMP ADD.EXPO..."  &gt;&gt;&gt;
                *--------------------------------
                *      ODD POLYNOMIAL SUBROUTINE
                *
                *      F(X) = X * P(X^2)
                *
                *      WHERE:  X IS VALUE IN FAC
                *              Y,A POINTS AT COEFFICIENT TABLE
                *              FIRST BYTE OF COEFF. TABLE IS N
                *              COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
                *
                *      P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
                *
                *--------------------------------
                <b><a name="POLYNOMIAL.ODD" id="POLYNOMIAL.ODD">POLYNOMIAL.ODD</a></b>
EF5C- 85 AD            STA SERPNT   SAVE ADDRESS OF COEFFICIENT TABLE
EF5E- 84 AE            STY SERPNT+1
EF60- 20 21 EB         JSR <a href="#STORE.FAC.IN.TEMP1.ROUNDED">STORE.FAC.IN.TEMP1.ROUNDED</a>
EF63- A9 93            LDA #TEMP1   Y=0 ALREADY, SO Y,A POINTS AT TEMP1
EF65- 20 7F E9         JSR <a href="#FMULT">FMULT</a>    FORM X^2
EF68- 20 76 EF         JSR <a href="#SERMAIN">SERMAIN</a>  DO SERIES IN X^2
EF6B- A9 93            LDA #TEMP1   GET X AGAIN
EF6D- A0 00            LDY /TEMP1
EF6F- 4C 7F E9         JMP <a href="#FMULT">FMULT</a>    MULTIPLY X BY P(X^2) AND EXIT
                *--------------------------------
                *      NORMAL POLYNOMIAL SUBROUTINE
                *
                *      P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
                *
                *      WHERE:  X IS VALUE IN FAC
                *              Y,A POINTS AT COEFFICIENT TABLE
                *              FIRST BYTE OF COEFF. TABLE IS N
                *              COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
                *
                *--------------------------------
                <b><a name="POLYNOMIAL" id="POLYNOMIAL">POLYNOMIAL</a></b>
EF72- 85 AD            STA SERPNT   POINTER TO COEFFICIENT TABLE
EF74- 84 AE            STY SERPNT+1
                *--------------------------------
                <b><a name="SERMAIN" id="SERMAIN">SERMAIN</a></b>
EF76- 20 1E EB         JSR <a href="#STORE.FAC.IN.TEMP2.ROUNDED">STORE.FAC.IN.TEMP2.ROUNDED</a>
EF79- B1 AD            LDA (SERPNT),Y    GET N
EF7B- 85 A3            STA SERLEN        SAVE N
EF7D- A4 AD            LDY SERPNT        BUMP PNTR TO HIGHEST COEFFICIENT
EF7F- C8               INY               AND GET PNTR INTO Y,A
EF80- 98               TYA
EF81- D0 02            BNE .1
EF83- E6 AE            INC SERPNT+1
EF85- 85 AD     .1     STA SERPNT
EF87- A4 AE            LDY SERPNT+1
EF89- 20 7F E9  .2     JSR <a href="#FMULT">FMULT</a>         ACCUMULATE SERIES TERMS
EF8C- A5 AD            LDA SERPNT        BUMP PNTR TO NEXT COEFFICIENT
EF8E- A4 AE            LDY SERPNT+1
EF90- 18               CLC
EF91- 69 05            ADC #5
EF93- 90 01            BCC .3
EF95- C8               INY
EF96- 85 AD     .3     STA SERPNT
EF98- 84 AE            STY SERPNT+1
EF9A- 20 BE E7         JSR <a href="#FADD">FADD</a>          ADD NEXT COEFFICIENT
EF9D- A9 98            LDA #TEMP2        POINT AT X AGAIN
EF9F- A0 00            LDY #0
EFA1- C6 A3            DEC SERLEN        IF SERIES NOT FINISHED,
EFA3- D0 E4            BNE .2            THEN ADD ANOTHER TERM
EFA5- 60        <b><a name="RTS.19" id="RTS.19">RTS.19</a></b> RTS               FINISHED
                *--------------------------------
EFA6- 98 35 44
EFA9- 7A        <b><a name="CON.RND.1" id="CON.RND.1">CON.RND.1</a></b> .HS 9835447A  &lt;&lt;&lt; THESE ARE MISSING ONE BYTE &gt;&gt;&gt;
EFAA- 68 28 B1
EFAD- 46        <b><a name="CON.RND.2" id="CON.RND.2">CON.RND.2</a></b> .HS 6828B146  &lt;&lt;&lt; FOR FP VALUES              &gt;&gt;&gt;
                *--------------------------------
                *      "RND" FUNCTION
                *--------------------------------
EFAE- 20 82 EB  <b><a name="RND" id="RND">RND</a></b>    JSR <a href="#SIGN">SIGN</a>     REDUCE ARGUMENT TO -1, 0, OR +1
EFB1- AA               TAX          SAVE ARGUMENT
EFB2- 30 18            BMI .1       = -1, USE CURRENT ARGUMENT FOR SEED
EFB4- A9 C9            LDA #RNDSEED USE CURRENT SEED
EFB6- A0 00            LDY /RNDSEED
EFB8- 20 F9 EA         JSR <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>
EFBB- 8A               TXA          RECALL SIGN OF ARGUMENT
EFBC- F0 E7            BEQ <a href="#RTS.19">RTS.19</a>   =0, RETURN SEED UNCHANGED
EFBE- A9 A6            LDA #CON.RND.1  VERY POOR RND ALGORITHM
EFC0- A0 EF            LDY /CON.RND.1
EFC2- 20 7F E9         JSR <a href="#FMULT">FMULT</a>
EFC5- A9 AA            LDA #CON.RND.2  ALSO, CONSTANTS ARE TRUNCATED
EFC7- A0 EF            LDY /CON.RND.2  &lt;&lt;&lt;THIS DOES NOTHING, DUE TO &gt;&gt;&gt;
                *                      &lt;&lt;&lt;SMALL EXPONENT            &gt;&gt;&gt;
EFC9- 20 BE E7         JSR <a href="#FADD">FADD</a>
EFCC- A6 A1     .1     LDX FAC+4    SHUFFLE HI AND LO BYTES
EFCE- A5 9E            LDA FAC+1    TO SUPPOSEDLY MAKE IT MORE RANDOM
EFD0- 85 A1            STA FAC+4
EFD2- 86 9E            STX FAC+1
EFD4- A9 00            LDA #0       MAKE IT POSITIVE
EFD6- 85 A2            STA FAC.SIGN
EFD8- A5 9D            LDA FAC      A SOMEWHAT RANDOM EXTENSION
EFDA- 85 AC            STA FAC.EXTENSION
EFDC- A9 80            LDA #$80     EXPONENT TO MAKE VALUE &lt; 1.0
EFDE- 85 9D            STA FAC
EFE0- 20 2E E8         JSR <a href="#NORMALIZE.FAC.2">NORMALIZE.FAC.2</a>
EFE3- A2 C9            LDX #RNDSEED  MOVE FAC TO RND SEED
EFE5- A0 00            LDY /RNDSEED
EFE7- 4C 2B EB  <b><a name="GO.MOVMF" id="GO.MOVMF">GO.MOVMF</a></b> JMP STORE.FAC.AT.YX.ROUNDED
                *--------------------------------
                *--------------------------------
                *      "COS" FUNCTION
                *--------------------------------
EFEA- A9 66     <b><a name="COS" id="COS">COS</a></b>    LDA #CON.PI.HALF     COS(X)=SIN(X + PI/2)
EFEC- A0 F0            LDY /CON.PI.HALF
EFEE- 20 BE E7         JSR <a href="#FADD">FADD</a>
                *--------------------------------
                *      "SIN" FUNCTION
                *--------------------------------
EFF1- 20 63 EB  <b><a name="SIN" id="SIN">SIN</a></b>    JSR <a href="#COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a>
EFF4- A9 6B            LDA #CON.PI.DOUB  REMOVE MULTIPLES OF 2*PI
EFF6- A0 F0            LDY /CON.PI.DOUB  BY DIVIDING AND SAVING
EFF8- A6 AA            LDX ARG.SIGN      THE FRACTIONAL PART
EFFA- 20 5E EA         JSR <a href="#DIV">DIV</a>           USE SIGN OF ARGUMENT
EFFD- 20 63 EB         JSR <a href="#COPY.FAC.TO.ARG.ROUNDED">COPY.FAC.TO.ARG.ROUNDED</a>
F000- 20 23 EC         JSR <a href="#INT">INT</a>      TAKE INTEGER PART
F003- A9 00            LDA #0       &lt;&lt;&lt; WASTED LINES, BECAUSE FSUBT &gt;&gt;&gt;
F005- 85 AB            STA SGNCPR   &lt;&lt;&lt; CHANGES SGNCPR AGAIN        &gt;&gt;&gt;
F007- 20 AA E7         JSR <a href="#FSUBT">FSUBT</a>    SUBTRACT TO GET FRACTIONAL PART
                *--------------------------------
                *      (FAC) = ANGLE AS A FRACTION OF A FULL CIRCLE
                *
                *      NOW FOLD THE RANGE INTO A QUARTER CIRCLE
                *
                *      &lt;&lt;&lt; THERE ARE MUCH SIMPLER WAYS TO DO THIS &gt;&gt;&gt;
                *--------------------------------
F00A- A9 70            LDA #QUARTER      1/4 - FRACTION MAKES
F00C- A0 F0            LDY /QUARTER      -3/4 &lt;= FRACTION &lt; 1/4
F00E- 20 A7 E7         JSR <a href="#FSUB">FSUB</a>
F011- A5 A2            LDA FAC.SIGN      TEST SIGN OF RESULT
F013- 48               PHA               SAVE SIGN FOR LATER UNFOLDING
F014- 10 0D            BPL <a href="#SIN.1">SIN.1</a>         ALREADY 0...1/4
F016- 20 A0 E7         JSR <a href="#FADDH">FADDH</a>         ADD 1/2 TO SHIFT TO -1/4...1/2
F019- A5 A2            LDA FAC.SIGN      TEST SIGN
F01B- 30 09            BMI <a href="#SIN.2">SIN.2</a>         -1/4...0
                *                        0...1/2
F01D- A5 16            LDA SIGNFLG       SIGNFLG INITIALIZED = 0 IN "TAN"
F01F- 49 FF            EOR #$FF          FUNCTION
F021- 85 16            STA SIGNFLG      "TAN" IS ONLY USER OF SIGNFLG TOO
                *--------------------------------
                *      IF FALL THRU, RANGE IS 0...1/2
                *      IF BRANCH HERE, RANGE IS 0...1/4
                *--------------------------------
F023- 20 D0 EE  <b><a name="SIN.1" id="SIN.1">SIN.1</a></b>  JSR <a href="#NEGOP">NEGOP</a>
                *--------------------------------
                *      IF FALL THRU, RANGE IS -1/2...0
                *      IF BRANCH HERE, RANGE IS -1/4...0
                *--------------------------------
F026- A9 70     <b><a name="SIN.2" id="SIN.2">SIN.2</a></b>  LDA #QUARTER      ADD 1/4 TO SHIFT RANGE 
F028- A0 F0            LDY /QUARTER      TO -1/4...1/4
F02A- 20 BE E7         JSR <a href="#FADD">FADD</a>
F02D- 68               PLA               GET SAVED SIGN FROM ABOVE
F02E- 10 03            BPL .1 
F030- 20 D0 EE         JSR <a href="#NEGOP">NEGOP</a>         MAKE RANGE 0...1/4
F033- A9 75     .1     LDA #POLY.SIN     DO STANDARD SIN SERIES
F035- A0 F0            LDY /POLY.SIN
F037- 4C 5C EF         JMP <a href="#POLYNOMIAL.ODD">POLYNOMIAL.ODD</a>
                *--------------------------------
                *      "TAN" FUNCTION
                *
                *      COMPUTE TAN(X) = SIN(X) / COS(X)
                *--------------------------------
F03A- 20 21 EB  <b><a name="TAN" id="TAN">TAN</a></b>    JSR <a href="#STORE.FAC.IN.TEMP1.ROUNDED">STORE.FAC.IN.TEMP1.ROUNDED</a>
F03D- A9 00            LDA #0       SIGNFLG WILL BE TOGGLED IF 2ND OR 3RD
F03F- 85 16            STA SIGNFLG  QUADRANT
F041- 20 F1 EF         JSR <a href="#SIN">SIN</a>      GET SIN(X)
F044- A2 8A            LDX #TEMP3   SAVE SIN(X) IN TEMP3
F046- A0 00            LDY /TEMP3
F048- 20 E7 EF         JSR <a href="#GO.MOVMF">GO.MOVMF</a> &lt;&lt;&lt;FUNNY WAY TO CALL MOVMF! &gt;&gt;&gt;
F04B- A9 93            LDA #TEMP1   RETRIEVE X
F04D- A0 00            LDY /TEMP1
F04F- 20 F9 EA         JSR <a href="#LOAD.FAC.FROM.YA">LOAD.FAC.FROM.YA</a>
F052- A9 00            LDA #0       AND COMPUTE COS(X)
F054- 85 A2            STA FAC.SIGN
F056- A5 16            LDA SIGNFLG
F058- 20 62 F0         JSR <a href="#TAN.1">TAN.1</a>    WEIRD &amp; DANGEROUS WAY TO GET INTO SIN
F05B- A9 8A            LDA #TEMP3   NOW FORM SIN/COS
F05D- A0 00            LDY /TEMP3
F05F- 4C 66 EA         JMP <a href="#FDIV">FDIV</a>
                *--------------------------------
F062- 48        <b><a name="TAN.1" id="TAN.1">TAN.1</a></b>  PHA          SHAME, SHAME!
F063- 4C 23 F0         JMP <a href="#SIN.1">SIN.1</a>
                *--------------------------------
F066- 81 49 0F
F069- DA A2     <b><a name="CON.PI.HALF" id="CON.PI.HALF">CON.PI.HALF</a></b> .HS 81490FDAA2
F06B- 83 49 0F
F06E- DA A2     <b><a name="CON.PI.DOUB" id="CON.PI.DOUB">CON.PI.DOUB</a></b> .HS 83490FDAA2
F070- 7F 00 00
F073- 00 00     <b><a name="QUARTER" id="QUARTER">QUARTER</a></b>     .HS 7F00000000
                *--------------------------------
F075- 05        <b><a name="POLY.SIN" id="POLY.SIN">POLY.SIN</a></b> .DA #5     POWER OF POLYNOMIAL
F076- 84 E6 1A
F079- 2D 1B              .HS 84E61A2D1B  (2PI)^11/11!
F07B- 86 28 07
F07E- FB F8              .HS 862807FBF8  (2PI)^9/9!
F080- 87 99 68
F083- 89 01              .HS 8799688901  (2PI)^7/7!
F085- 87 23 35
F088- DF E1              .HS 872335DFE1  (2PI)^5/5!
F08A- 86 A5 5D
F08D- E7 28              .HS 86A55DE728  (2PI)^3/3!
F08F- 83 49 0F
F092- DA A2              .HS 83490FDAA2  2PI
                *--------------------------------
                *  &lt;&lt;&lt; NEXT TEN BYTES ARE NEVER REFERENCED &gt;&gt;&gt;
                *--------------------------------
F094- A6 D3 C1
F097- C8 D4              .HS A6D3C1C8D4  OR "&amp;SAHT;" IN ASCII [exclusive-or each byte with $87 ]
F099- C8 D5 C4                                                   [to get the string "!TFOSORCIM"  ]
F09C- CE CA              .HS C8D5C4CECA  OR "HUDNJ" IN ASCII [which is "MICROSOFT!" backwards.]
                *--------------------------------
                *      "ATN" FUNCTION
                *--------------------------------
F09E- A5 A2     <b><a name="ATN" id="ATN">ATN</a></b>    LDA FAC.SIGN      FOLD THE ARGUMENT RANGE FIRST
F0A0- 48               PHA               SAVE SIGN FOR LATER UNFOLDING
F0A1- 10 03            BPL .1            .GE. 0
F0A3- 20 D0 EE         JSR <a href="#NEGOP">NEGOP</a>         .LT. 0, SO COMPLEMENT
F0A6- A5 9D     .1     LDA FAC           IF .GE. 1, FORM RECIPROCAL
F0A8- 48               PHA               SAVE FOR LATER UNFOLDING
F0A9- C9 81            CMP #$81          (EXPONENT FOR .GE. 1
F0AB- 90 07            BCC .2            X &lt; 1
F0AD- A9 13            LDA #CON.ONE      FORM 1/X
F0AF- A0 E9            LDY /CON.ONE
F0B1- 20 66 EA         JSR <a href="#FDIV">FDIV</a>
                *--------------------------------
                *      0 &lt;= X &lt;= 1
                *      0 &lt;= ATN(X) &lt;= PI/8
                *--------------------------------
F0B4- A9 CE     .2     LDA #POLY.ATN     COMPUTE POLYNOMIAL APPROXIMATION
F0B6- A0 F0            LDY /POLY.ATN
F0B8- 20 5C EF         JSR <a href="#POLYNOMIAL.ODD">POLYNOMIAL.ODD</a>
F0BB- 68               PLA               START TO UNFOLD
F0BC- C9 81            CMP #$81          WAS IT .GE. 1?
F0BE- 90 07            BCC .3            NO
F0C0- A9 66            LDA #CON.PI.HALF  YES, SUBTRACT FROM PI/2
F0C2- A0 F0            LDY /CON.PI.HALF
F0C4- 20 A7 E7         JSR <a href="#FSUB">FSUB</a>
F0C7- 68        .3     PLA               WAS IT NEGATIVE?
F0C8- 10 03            BPL <a href="#RTS.20">RTS.20</a>        NO
F0CA- 4C D0 EE         JMP <a href="#NEGOP">NEGOP</a>         YES, COMPLEMENT
F0CD- 60        <b><a name="RTS.20" id="RTS.20">RTS.20</a></b> RTS
                *--------------------------------
F0CE- 0B        <b><a name="POLY.ATN" id="POLY.ATN">POLY.ATN</a></b> .DA #11    POWER OF POLYNOMIAL
F0CF- 76 B3 83
F0D2- BD D3              .HS 76B383BDD3
F0D4- 79 1E F4
F0D7- A6 F5              .HS 791EF4A6F5
F0D9- 7B 83 FC
F0DC- B0 10              .HS 7B83FCB010
F0DE- 7C 0C 1F
F0E1- 67 CA              .HS 7C0C1F67CA
F0E3- 7C DE 53
F0E6- CB C1              .HS 7CDE53CBC1
F0E8- 7D 14 64
F0EB- 70 4C              .HS 7D1464704C
F0ED- 7D B7 EA
F0F0- 51 7A              .HS 7DB7EA517A
F0F2- 7D 63 30
F0F5- 88 7E              .HS 7D6330887E
F0F7- 7E 92 44
F0FA- 99 3A              .HS 7E9244993A
F0FC- 7E 4C CC
F0FF- 91 C7              .HS 7E4CCC91C7
F101- 7F AA AA
F104- AA 13              .HS 7FAAAAAA13
F106- 81 00 00
F109- 00 00              .HS 8100000000
                *--------------------------------
                *      GENERIC COPY OF CHRGET SUBROUTINE, WHICH
                *      IS COPIED INTO $00B1...$00C8 DURING INITIALIZATION
                *
                *      CORNELIS BONGERS DESCRIBED SEVERAL IMPROVEMENTS 
                *      TO CHRGET IN MICRO MAGAZINE OR CALL A.P.P.L.E.
                *      (I DON'T REMEMBER WHICH OR EXACTLY WHEN)
                *--------------------------------
                <b><a name="GENERIC.CHRGET" id="GENERIC.CHRGET">GENERIC.CHRGET</a></b>
F10B- E6 B8            INC TXTPTR
F10D- D0 02            BNE .1
F10F- E6 B9            INC TXTPTR+1
F111- AD 60 EA  .1     LDA $EA60    &lt;&lt;&lt; ACTUAL ADDRESS FILLED IN LATER &gt;&gt;&gt;
F114- C9 3A            CMP #':'     EOS, ALSO TOP OF NUMERIC RANGE
F116- B0 0A            BCS .2       NOT NUMBER, MIGHT BE EOS
F118- C9 20            CMP #' '     IGNORE BLANKS
F11A- F0 EF            BEQ <a href="#GENERIC.CHRGET">GENERIC.CHRGET</a>
F11C- 38               SEC          TEST FOR NUMERIC RANGE IN WAY THAT
F11D- E9 30            SBC #'0'     CLEARS CARRY IF CHAR IS DIGIT
F11F- 38               SEC          AND LEAVES CHAR IN A-REG
F120- E9 D0            SBC #-'0'
F122- 60        .2     RTS
                *--------------------------------
                *      INITIAL VALUE FOR RANDOM NUMBER, ALSO COPIED
                *      IN ALONG WITH CHRGET, BUT ERRONEOUSLY:
                *  &lt;&lt;&lt; THE LAST BYTE IS NOT COPIED &gt;&gt;&gt;
                *--------------------------------
F123- 80 4F C7
F126- 52 58            .HS 804FC75258  APPROX. = .811635157
                <b><a name="GENERIC.END" id="GENERIC.END">GENERIC.END</a></b>
                *--------------------------------
                <b><a name="COLD.START" id="COLD.START">COLD.START</a></b>
F128- A2 FF            LDX #$FF     SET DIRECT MODE FLAG
F12A- 86 76            STX CURLIN+1
F12C- A2 FB            LDX #$FB     SET STACK POINTER, LEAVING ROOM FOR
F12E- 9A               TXS          LINE BUFFER DURING PARSING
F12F- A9 28            LDA #COLD.START   SET RESTART TO COLD.START
F131- A0 F1            LDY /COLD.START   UNTIL COLDSTART IS COMPLETED
F133- 85 01            STA GOWARM+1
F135- 84 02            STY GOWARM+2
F137- 85 04            STA GOSTROUT+1    ALSO SECOND USER VECTOR...
F139- 84 05            STY GOSTROUT+2  ..WE SIMPLY MUST FINISH COLD.START!
F13B- 20 73 F2         JSR <a href="#NORMAL">NORMAL</a>        SET NORMAL DISPLAY MODE
F13E- A9 4C            LDA #$4C          "JMP" OPCODE FOR 4 VECTORS
F140- 85 00            STA GOWARM        WARM START
F142- 85 03            STA GOSTROUT      ANYONE EVER USE THIS ONE?
F144- 85 90            STA JMPADRS       USED BY FUNCTIONS (JSR JMPADRS)
F146- 85 0A            STA USR           "USR" FUNCTION VECTOR
F148- A9 99            LDA #IQERR        POINT "USR" TO ILLEGAL QUANTITY
F14A- A0 E1            LDY /IQERR        ERROR, UNTIL USER SETS IT UP
F14C- 85 0B            STA USR+1
F14E- 84 0C            STY USR+2
                *--------------------------------
                *      MOVE GENERIC CHRGET AND RANDOM SEED INTO PLACE
                *
                *  &lt;&lt;&lt; NOTE THAT LOOP VALUE IS WRONG!          &gt;&gt;&gt;
                *  &lt;&lt;&lt; THE LAST BYTE OF THE RANDOM SEED IS NOT &gt;&gt;&gt;
                *  &lt;&lt;&lt; COPIED INTO PAGE ZERO!                  &gt;&gt;&gt;
                *--------------------------------
F150- A2 1C            LDX #GENERIC.END-GENERIC.CHRGET-1
F152- BD 0A F1  .1     LDA GENERIC.CHRGET-1,X
F155- 95 B0            STA CHRGET-1,X
F157- 86 F1            STX SPEEDZ        ON LAST PASS STORES $01)
F159- CA               DEX
F15A- D0 F6            BNE .1
                *--------------------------------
F15C- 86 F2            STX TRCFLG        X=0, TURN OFF TRACING
F15E- 8A               TXA               A=0
F15F- 85 A4            STA SHIFT.SIGN.EXT
F161- 85 54            STA LASTPT+1
F163- 48               PHA               PUT $00 ON STACK (WHAT FOR?)
F164- A9 03            LDA #3       SET LENGTH OF TEMP. STRING DESCRIPTORS
F166- 85 8F            STA DSCLEN   FOR GARBAGE COLLECTION SUBROUTINE
F168- 20 FB DA         JSR <a href="#CRDO">CRDO</a>     PRINT &lt;RETURN&gt;
F16B- A9 01            LDA #1       SET UP FAKE FORWARD LINK
F16D- 8D FD 01         STA INPUT.BUFFER-3
F170- 8D FC 01         STA INPUT.BUFFER-4
F173- A2 55            LDX #TEMPST  INIT INDEX TO TEMP STRING DESCRIPTORS
F175- 86 52            STX TEMPPT
                *--------------------------------
                *      FIND HIGH END OF RAM
                *--------------------------------
F177- A9 00            LDA #$0800   SET UP POINTER TO LOW END OF RAM
F179- A0 08            LDY /$0800
F17B- 85 50            STA LINNUM
F17D- 84 51            STY LINNUM+1
F17F- A0 00            LDY #0
F181- E6 51     .2     INC LINNUM+1      TEST FIRST BYTE OF EACH PAGE
F183- B1 50            LDA (LINNUM),Y    BY COMPLEMENTING IT AND WATCHING
F185- 49 FF            EOR #$FF          IT CHANGE THE SAME WAY
F187- 91 50            STA (LINNUM),Y
F189- D1 50            CMP (LINNUM),Y    ROM OR EMPTY SOCKETS WON'T TRACK
F18B- D0 08            BNE .3            NOT RAM HERE
F18D- 49 FF            EOR #$FF          RESTORE ORIGINAL VALUE
F18F- 91 50            STA (LINNUM),Y
F191- D1 50            CMP (LINNUM),Y    DID IT TRACK AGAIN?
F193- F0 EC            BEQ .2            YES, STILL IN RAM
F195- A4 50     .3     LDY LINNUM        NO, END OF RAM
F197- A5 51            LDA LINNUM+1
F199- 29 F0            AND #$F0          FORCE A MULTIPLE OF 4096 BYTES
F19B- 84 73            STY MEMSIZ  (BAD RAM MAY HAVE YIELDED NON-MULTIPLE)
F19D- 85 74            STA MEMSIZ+1
F19F- 84 6F            STY FRETOP        SET HIMEM AND BOTTOM OF STRINGS
F1A1- 85 70            STA FRETOP+1
F1A3- A2 00            LDX #$0800        SET PROGRAM POINTER TO $0800
F1A5- A0 08            LDY /$0800
F1A7- 86 67            STX TXTTAB
F1A9- 84 68            STY TXTTAB+1
F1AB- A0 00            LDY #0            TURN OFF SEMI-SECRET LOCK FLAG
F1AD- 84 D6            STY LOCK
F1AF- 98               TYA               A=0 TOO
F1B0- 91 67            STA (TXTTAB),Y    FIRST BYTE IN PROGRAM SPACE = 0
F1B2- E6 67            INC TXTTAB        ADVANCE PAST THE $00
F1B4- D0 02            BNE .4
F1B6- E6 68            INC TXTTAB+1
F1B8- A5 67     .4     LDA TXTTAB
F1BA- A4 68            LDY TXTTAB+1
F1BC- 20 E3 D3         JSR <a href="#REASON">REASON</a>        SET REST OF POINTERS UP
F1BF- 20 4B D6         JSR <a href="#SCRTCH">SCRTCH</a>        MORE POINTERS
F1C2- A9 3A            LDA #STROUT       PUT CORRECT ADDRESSES IN TWO
F1C4- A0 DB            LDY /STROUT       USER VECTORS
F1C6- 85 04            STA GOSTROUT+1
F1C8- 84 05            STY GOSTROUT+2
F1CA- A9 3C            LDA #RESTART
F1CC- A0 D4            LDY /RESTART
F1CE- 85 01            STA GOWARM+1
F1D0- 84 02            STY GOWARM+2
F1D2- 6C 01 00         JMP (GOWARM+1)    SILLY, WHY NOT JUST "JMP RESTART"
                *--------------------------------
                *--------------------------------
                *      "CALL" STATEMENT
                *
                *      EFFECTIVELY PERFORMS A "JSR" TO THE SPECIFIED
                *      ADDRESS, WITH THE FOLLOWING REGISTER CONTENTS:
                *           (A,Y) = CALL ADDRESS
                *           (X)   = $9D
                *
                *      THE CALLED ROUTINE CAN RETURN WITH "RTS",
                *      AND APPLESOFT WILL CONTINUE WITH THE NEXT
                *      STATEMENT.
                *--------------------------------
F1D5- 20 67 DD  <b><a name="CALL" id="CALL">CALL</a></b>   JSR <a href="#FRMNUM">FRMNUM</a>   EVALUATE EXPRESSION FOR CALL ADDRESS
F1D8- 20 52 E7         JSR <a href="#GETADR">GETADR</a>   CONVERT EXPRESSION TO 16-BIT INTEGER
F1DB- 6C 50 00         JMP (LINNUM)     IN LINNUM, AND JUMP THERE.
                *--------------------------------
                *      "IN#" STATEMENT
                *
                *      NOTE:  NO CHECK FOR VALID SLOT #, AS LONG
                *      AS VALUE IS &lt; 256 IT IS ACCEPTED.
                *      MONITOR MASKS VALUE TO 4 BITS (0-15).
                *--------------------------------
                <b><a name="IN.NUMBER" id="IN.NUMBER">IN.NUMBER</a></b>
F1DE- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   GET SLOT NUMBER IN X-REG
F1E1- 8A               TXA          MONITOR WILL INSTALL IN VECTOR
F1E2- 4C 8B FE         JMP <a href="#MON.INPORT">MON.INPORT</a>    AT $38,39.
                *--------------------------------
                *      "PR#" STATEMENT
                *
                *      NOTE:  NO CHECK FOR VALID SLOT #, AS LONG
                *      AS VALUE IS &lt; 256 IT IS ACCEPTED.
                *      MONITOR MASKS VALUE TO 4 BITS (0-15).
                *--------------------------------
                <b><a name="PR.NUMBER" id="PR.NUMBER">PR.NUMBER</a></b>
F1E5- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   GET SLOT NUMBER IN X-REG
F1E8- 8A               TXA          MONITOR WILL INSTALL IN VECTOR
F1E9- 4C 95 FE         JMP <a href="#MON.OUTPORT">MON.OUTPORT</a>   AT $36,37
                *--------------------------------
                *      GET TWO VALUES &lt; 48, WITH COMMA SEPARATOR
                *
                *      CALLED FOR "PLOT X,Y" 
                *             AND "HLIN A,B AT Y"
                *             AND "VLIN A,B AT X"
                *
                *--------------------------------
                <b><a name="PLOTFNS" id="PLOTFNS">PLOTFNS</a></b>
F1EC- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   GET FIRST VALUE IN X-REG
F1EF- E0 30            CPX #48      MUST BE &lt; 48
F1F1- B0 13            BCS <a href="#GOERR">GOERR</a>    TOO LARGE
F1F3- 86 F0            STX FIRST    SAVE FIRST VALUE
F1F5- A9 2C            LDA #','     MUST HAVE A COMMA
F1F7- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
F1FA- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   GET SECOND VALUE IN X-REG
F1FD- E0 30            CPX #48      MUST BE &lt; 48
F1FF- B0 05            BCS <a href="#GOERR">GOERR</a>    TOO LARGE
F201- 86 2C            STX MON.H2   SAVE SECOND VALUE
F203- 86 2D            STX MON.V2
F205- 60               RTS          SECOND VALUE STILL IN X-REG
                *--------------------------------
F206- 4C 99 E1  <b><a name="GOERR" id="GOERR">GOERR</a></b>  JMP <a href="#IQERR">IQERR</a>    ILLEGAL QUANTITY ERROR
                *--------------------------------
                *      GET "A,B AT C" VALUES FOR "HLIN" AND "VLIN"
                *
                *      PUT SMALLER OF (A,B) IN FIRST,
                *      AND LARGER  OF (A,B) IN H2 AND V2.
                *      RETURN WITH (X) = C-VALUE.
                *--------------------------------
                <b><a name="LINCOOR" id="LINCOOR">LINCOOR</a></b>
F209- 20 EC F1         JSR <a href="#PLOTFNS">PLOTFNS</a>  GET A,B VALUES
F20C- E4 F0            CPX FIRST    IS A &lt; B?
F20E- B0 08            BCS .1       YES, IN RIGHT ORDER
F210- A5 F0            LDA FIRST    NO, INTERCHANGE THEM
F212- 85 2C            STA MON.H2
F214- 85 2D            STA MON.V2
F216- 86 F0            STX FIRST
F218- A9 C5     .1     LDA #TOKEN.AT     MUST HAVE "AT" NEXT
F21A- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
F21D- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   GET C-VALUE IN X-REG
F220- E0 30            CPX #48      MUST BE &lt; 48
F222- B0 E2            BCS <a href="#GOERR">GOERR</a>    TOO LARGE
F224- 60               RTS          C-VALUE IN X-REG
                *--------------------------------
                *      "PLOT" STATEMENT
                *--------------------------------
F225- 20 EC F1  <b><a name="PLOT" id="PLOT">PLOT</a></b>   JSR <a href="#PLOTFNS">PLOTFNS</a>  GET X,Y VALUES
F228- 8A               TXA          Y-COORD TO A-REG FOR MONITOR
F229- A4 F0            LDY FIRST    X-COORD TO Y-YEG FOR MONITOR
F22B- C0 28            CPY #40      X-COORD MUST BE &lt; 40
F22D- B0 D7            BCS <a href="#GOERR">GOERR</a>    X-COORD IS TOO LARGE
F22F- 4C 00 F8         JMP <a href="#MON.PLOT">MON.PLOT</a>      PLOT!
                *--------------------------------
                *      "HLIN" STATEMENT
                *--------------------------------
F232- 20 09 F2  <b><a name="HLIN" id="HLIN">HLIN</a></b>   JSR <a href="#LINCOOR">LINCOOR</a>  GET "A,B AT C"
F235- 8A               TXA          Y-COORD IN A-REG
F236- A4 2C            LDY MON.H2   RIGHT END OF LINE
F238- C0 28            CPY #40      MUST BE &lt; 40
F23A- B0 CA            BCS <a href="#GOERR">GOERR</a>    TOO LARGE
F23C- A4 F0            LDY FIRST    LEFT END OF LINE IN Y-REG
F23E- 4C 19 F8         JMP <a href="#MON.HLINE">MON.HLINE</a>     LET MONITOR DRAW LINE
                *--------------------------------
                *      "VLIN" STATEMENT
                *--------------------------------
F241- 20 09 F2  <b><a name="VLIN" id="VLIN">VLIN</a></b>  JSR LINCOOR   GET "A,B AT C"
F244- 8A               TXA          X-COORD IN Y-REG
F245- A8               TAY
F246- C0 28            CPY #40      X-COORD MUST BE &lt; 40
F248- B0 BC            BCS <a href="#GOERR">GOERR</a>    TOO LARGE
F24A- A5 F0            LDA FIRST    TOP END OF LINE IN A-REG
F24C- 4C 28 F8         JMP <a href="#MON.VLINE">MON.VLINE</a>     LET MONITOR DRAW LINE
                *--------------------------------
                *      "COLOR=" STATEMENT
                *--------------------------------
F24F- 20 F8 E6  <b><a name="COLOR" id="COLOR">COLOR</a></b>  JSR <a href="#GETBYT">GETBYT</a>   GET COLOR VALUE IN X-REG
F252- 8A               TXA
F253- 4C 64 F8         JMP <a href="#MON.SETCOL">MON.SETCOL</a>    LET MONITOR STORE COLOR
                *--------------------------------
                *      "VTAB" STATEMENT
                *--------------------------------
F256- 20 F8 E6  <b><a name="VTAB" id="VTAB">VTAB</a></b>   JSR <a href="#GETBYT">GETBYT</a>   GET LINE # IN X-REG
F259- CA               DEX          CONVERT TO ZERO BASE
F25A- 8A               TXA
F25B- C9 18            CMP #24      MUST BE 0-23
F25D- B0 A7            BCS <a href="#GOERR">GOERR</a>    TOO LARGE, OR WAS "VTAB 0"
F25F- 4C 5B FB         JMP <a href="#MON.TABV">MON.TABV</a>      LET MONITOR COMPUTE BASE
                *--------------------------------
                *      "SPEED=" STATEMENT
                *--------------------------------
F262- 20 F8 E6  <b><a name="SPEED" id="SPEED">SPEED</a></b>  JSR <a href="#GETBYT">GETBYT</a>   GET SPEED SETTING IN X-REG
F265- 8A               TXA          SPEEDZ = $100-SPEED
F266- 49 FF            EOR #$FF     SO "SPEED=255" IS FASTEST
F268- AA               TAX
F269- E8               INX
F26A- 86 F1            STX SPEEDZ
F26C- 60               RTS
                *--------------------------------
                *      "TRACE" STATEMENT
                *      SET SIGN BIT IN TRCFLG
                *--------------------------------
F26D- 38        <b><a name="TRACE" id="TRACE">TRACE</a></b> SEC
F26E- 90               .HS 90       FAKE BCC TO SKIP NEXT OPCODE
                *--------------------------------
                *      "NOTRACE" STATEMENT
                *      CLEAR SIGN BIT IN TRCFLG
                *--------------------------------
                <b><a name="NOTRACE" id="NOTRACE">NOTRACE</a></b>
F26F- 18               CLC
F270- 66 F2            ROR TRCFLG   SHIFT CARRY INTO TRCFLG
F272- 60               RTS
                *--------------------------------
                *      "NORMAL" STATEMENT
                *--------------------------------
F273- A9 FF     <b><a name="NORMAL" id="NORMAL">NORMAL</a></b> LDA #$FF     SET INVFLG = $FF
F275- D0 02            BNE <a href="#N.I.">N.I.</a>     AND FLASH.BIT = $00
                *--------------------------------
                *      "INVERSE" STATEMENT
                *--------------------------------
                <b><a name="INVERSE" id="INVERSE">INVERSE</a></b>
F277- A9 3F            LDA #$3F     SET INVFLG = $3F
F279- A2 00     <b><a name="N.I." id="N.I.">N.I.</a></b>   LDX #0       AND FLASH.BIT = $00
F27B- 85 32     <b><a name="N.I.F." id="N.I.F.">N.I.F.</a></b> STA MON.INVFLG
F27D- 86 F3            STX FLASH.BIT
F27F- 60               RTS
                *--------------------------------
                *      "FLASH" STATEMENT
                *--------------------------------
F280- A9 7F     <b><a name="FLASH" id="FLASH">FLASH</a></b>  LDA #$7F     SET INVFLG = $7F
F282- A2 40            LDX #$40     AND FLASH.BIT = $40
F284- D0 F5            BNE <a href="#N.I.F.">N.I.F.</a>   ...ALWAYS
                *--------------------------------
                *      "HIMEM:" STATEMENT
                *--------------------------------
F286- 20 67 DD  <b><a name="HIMEM" id="HIMEM">HIMEM</a></b>  JSR <a href="#FRMNUM">FRMNUM</a>   GET VALUE SPECIFIED FOR HIMEM
F289- 20 52 E7         JSR <a href="#GETADR">GETADR</a>   AS 16-BIT INTEGER
F28C- A5 50            LDA LINNUM   MUST BE ABOVE VARIABLES AND ARRAYS
F28E- C5 6D            CMP STREND
F290- A5 51            LDA LINNUM+1
F292- E5 6E            SBC STREND+1
F294- B0 03            BCS <a href="#SETHI">SETHI</a>    IT IS ABOVE THEM
F296- 4C 10 D4  <b><a name="JMM" id="JMM">JMM</a></b>    JMP <a href="#MEMERR">MEMERR</a>   NOT ENOUGH MEMORY
F299- A5 50     <b><a name="SETHI" id="SETHI">SETHI</a></b>  LDA LINNUM   STORE NEW HIMEM: VALUE
F29B- 85 73            STA MEMSIZ
F29D- 85 6F            STA FRETOP   &lt;&lt;&lt;NOTE THAT "HIMEM:" DOES NOT&gt;&gt;&gt;
F29F- A5 51            LDA LINNUM+1 &lt;&lt;&lt;CLEAR STRING VARIABLES.    &gt;&gt;&gt;
F2A1- 85 74            STA MEMSIZ+1 &lt;&lt;&lt;THIS COULD BE DISASTROUS.  &gt;&gt;&gt;
F2A3- 85 70            STA FRETOP+1
F2A5- 60               RTS
                *--------------------------------
                *      "LOMEM:" STATEMENT
                *--------------------------------
F2A6- 20 67 DD  <b><a name="LOMEM" id="LOMEM">LOMEM</a></b>  JSR <a href="#FRMNUM">FRMNUM</a>   GET VALUE SPECIFIED FOR LOMEM
F2A9- 20 52 E7         JSR <a href="#GETADR">GETADR</a>   AS 16-BIT INTEGER IN LINNUM
F2AC- A5 50            LDA LINNUM   MUST BE BELOW HIMEM
F2AE- C5 73            CMP MEMSIZ
F2B0- A5 51            LDA LINNUM+1
F2B2- E5 74            SBC MEMSIZ+1
F2B4- B0 E0            BCS <a href="#JMM">JMM</a>      ABOVE HIMEM, MEMORY ERROR
F2B6- A5 50            LDA LINNUM   MUST BE ABOVE PROGRAM
F2B8- C5 69            CMP VARTAB
F2BA- A5 51            LDA LINNUM+1
F2BC- E5 6A            SBC VARTAB+1
F2BE- 90 D6            BCC <a href="#JMM">JMM</a>      NOT ABOVE PROGRAM, ERROR
F2C0- A5 50            LDA LINNUM   STORE NEW LOMEM VALUE
F2C2- 85 69            STA VARTAB
F2C4- A5 51            LDA LINNUM+1
F2C6- 85 6A            STA VARTAB+1
F2C8- 4C 6C D6         JMP <a href="#CLEARC">CLEARC</a>   LOMEM CLEARS VARIABLES AND ARRAYS
                *--------------------------------
                *      "ON ERR GO TO" STATEMENT
                *--------------------------------
F2CB- A9 AB     <b><a name="ONERR" id="ONERR">ONERR</a></b>  LDA #TOKEN.GOTO   MUST BE "GOTO" NEXT
F2CD- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
F2D0- A5 B8            LDA TXTPTR   SAVE TXTPTR FOR HANDLERR
F2D2- 85 F4            STA TXTPSV
F2D4- A5 B9            LDA TXTPTR+1
F2D6- 85 F5            STA TXTPSV+1
F2D8- 38               SEC          SET SIGN BIT OF ERRFLG
F2D9- 66 D8            ROR ERRFLG
F2DB- A5 75            LDA CURLIN   SAVE LINE # OF CURRENT LINE
F2DD- 85 F6            STA CURLSV
F2DF- A5 76            LDA CURLIN+1
F2E1- 85 F7            STA CURLSV+1
F2E3- 20 A6 D9         JSR <a href="#REMN">REMN</a>     IGNORE REST OF LINE &lt;&lt;&lt;WHY?&gt;&gt;&gt;
F2E6- 4C 98 D9         JMP <a href="#ADDON">ADDON</a>    CONTINUE PROGRAM
                *--------------------------------
                *      ROUTINE TO HANDLE ERRORS IF ONERR GOTO ACTIVE
                *--------------------------------
                <b><a name="HANDLERR" id="HANDLERR">HANDLERR</a></b>
F2E9- 86 DE            STX ERRNUM   SAVE ERROR CODE NUMBER
F2EB- A6 F8            LDX REMSTK   GET STACK PNTR SAVED AT NEWSTT
F2ED- 86 DF            STX ERRSTK   REMEMBER IT
                *                   &lt;&lt;&lt;COULD ALSO HAVE DONE TXS  &gt;&gt;&gt;
                *                   &lt;&lt;&lt;HERE; SEE ONERR CORRECTION&gt;&gt;&gt;
                *                   &lt;&lt;&lt;IN APPLESOFT MANUAL.      &gt;&gt;&gt;
F2EF- A5 75            LDA CURLIN   GET LINE # OF OFFENDING STATEMENT
F2F1- 85 DA            STA ERRLIN   SO USER CAN SEE IT IF DESIRED
F2F3- A5 76            LDA CURLIN+1
F2F5- 85 DB            STA ERRLIN+1
F2F7- A5 79            LDA OLDTEXT  ALSO THE POSITION IN THE LINE
F2F9- 85 DC            STA ERRPOS   IN CASE USER WANTS TO "RESUME"
F2FB- A5 7A            LDA OLDTEXT+1
F2FD- 85 DD            STA ERRPOS+1
F2FF- A5 F4            LDA TXTPSV   SET UP TXTPTR TO READ TARGET LINE #
F301- 85 B8            STA TXTPTR   IN "ON ERR GO TO XXXX"
F303- A5 F5            LDA TXTPSV+1
F305- 85 B9            STA TXTPTR+1
F307- A5 F6            LDA CURLSV
F309- 85 75            STA CURLIN   LINE # OF "ON ERR" STATEMENT
F30B- A5 F7            LDA CURLSV+1
F30D- 85 76            STA CURLIN+1
F30F- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   START CONVERSION
F312- 20 3E D9         JSR <a href="#GOTO">GOTO</a>     GOTO SPECIFIED ONERR LINE
F315- 4C D2 D7         JMP <a href="#NEWSTT">NEWSTT</a>
                *--------------------------------
                *      "RESUME" STATEMENT
                *--------------------------------
F318- A5 DA     <b><a name="RESUME" id="RESUME">RESUME</a></b> LDA ERRLIN   RESTORE LINE # AND TXTPTR
F31A- 85 75            STA CURLIN   TO RE-TRY OFFENDING LINE
F31C- A5 DB            LDA ERRLIN+1
F31E- 85 76            STA CURLIN+1
F320- A5 DC            LDA ERRPOS
F322- 85 B8            STA TXTPTR
F324- A5 DD            LDA ERRPOS+1
F326- 85 B9            STA TXTPTR+1
                *  &lt;&lt;&lt; ONERR CORRECTION IN MANUAL IS EASILY &gt;&gt;&gt;
                *  &lt;&lt;&lt; BY "CALL -3288", WHICH IS $F328 HERE &gt;&gt;&gt;
F328- A6 DF            LDX ERRSTK   RETRIEVE STACK PNTR AS IT WAS
F32A- 9A               TXS          BEFORE STATEMENT SCANNED
F32B- 4C D2 D7         JMP <a href="#NEWSTT">NEWSTT</a>   DO STATEMENT AGAIN
                *--------------------------------
F32E- 4C C9 DE  <b><a name="JSYN" id="JSYN">JSYN</a></b>   JMP <a href="#SYNERR">SYNERR</a>
                *--------------------------------
                *      "DEL" STATEMENT
                *--------------------------------
F331- B0 FB     <b><a name="DEL" id="DEL">DEL</a></b>    BCS <a href="#JSYN">JSYN</a>     ERROR IF # NOT SPECIFIED
F333- A6 AF            LDX PRGEND
F335- 86 69            STX VARTAB
F337- A6 B0            LDX PRGEND+1
F339- 86 6A            STX VARTAB+1
F33B- 20 0C DA         JSR <a href="#LINGET">LINGET</a>   GET BEGINNING OF RANGE
F33E- 20 1A D6         JSR <a href="#FNDLIN">FNDLIN</a>   FIND THIS LINE OR NEXT
F341- A5 9B            LDA LOWTR    UPPER PORTION OF PROGRAM WILL
F343- 85 60            STA DEST     BE MOVED DOWN TO HERE
F345- A5 9C            LDA LOWTR+1
F347- 85 61            STA DEST+1
F349- A9 2C            LDA #','     MUST HAVE A COMMA NEXT
F34B- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
F34E- 20 0C DA         JSR <a href="#LINGET">LINGET</a>   GET END RANGE
                *                   (DOES NOTHING IF END RANGE
                *                   IS NOT SPECIFIED)
F351- E6 50            INC LINNUM   POINT ONE PAST IT
F353- D0 02            BNE .1
F355- E6 51            INC LINNUM+1
F357- 20 1A D6  .1     JSR <a href="#FNDLIN">FNDLIN</a>   FIND START LINE AFTER SPECIFIED LINE
F35A- A5 9B            LDA LOWTR    WHICH IS BEGINNING OF PORTION
F35C- C5 60            CMP DEST     TO BE MOVED DOWN
F35E- A5 9C            LDA LOWTR+1  IT MUST BE ABOVE THE TARGET
F360- E5 61            SBC DEST+1
F362- B0 01            BCS .2       IT IS OKAY
F364- 60               RTS          NOTHING TO DELETE
F365- A0 00     .2     LDY #0       MOVE UPPER PORTION DOWN NOW
F367- B1 9B     .3     LDA (LOWTR),Y     SOURCE . . .
F369- 91 60            STA (DEST),Y      ...TO DESTINATION
F36B- E6 9B            INC LOWTR         BUMP SOURCE PNTR
F36D- D0 02            BNE .4
F36F- E6 9C            INC LOWTR+1
F371- E6 60     .4     INC DEST          BUMP DESTINATION PNTR
F373- D0 02            BNE .5
F375- E6 61            INC DEST+1
F377- A5 69     .5     LDA VARTAB        REACHED END OF PROGRAM YET?
F379- C5 9B            CMP LOWTR
F37B- A5 6A            LDA VARTAB+1
F37D- E5 9C            SBC LOWTR+1
F37F- B0 E6            BCS .3            NO, KEEP MOVING
F381- A6 61            LDX DEST+1        STORE NEW END OF PROGRAM
F383- A4 60            LDY DEST          MUST SUBTRACT 1 FIRST
F385- D0 01            BNE .6
F387- CA               DEX
F388- 88        .6     DEY
F389- 86 6A            STX VARTAB+1
F38B- 84 69            STY VARTAB
F38D- 4C F2 D4         JMP <a href="#FIX.LINKS">FIX.LINKS</a>  RESET LINKS AFTER A DELETE
                *--------------------------------
                *      "GR" STATEMENT
                *--------------------------------
F390- AD 56 C0  <b><a name="GR" id="GR">GR</a></b>     LDA SW.LORES
F393- AD 53 C0         LDA SW.MIXSET
F396- 4C 40 FB         JMP <a href="#MON.SETGR">MON.SETGR</a>
                *--------------------------------
                *      "TEXT" STATEMENT
                *--------------------------------
F399- AD 54 C0  <b><a name="TEXT" id="TEXT">TEXT</a></b>   LDA SW.LOWSCR     JMP $FB36 WOULD HAVE
F39C- 4C 39 FB         JMP <a href="#MON.SETTXT">MON.SETTXT</a>    DONE BOTH OF THESE
                * &lt;&lt;&lt;       BETTER CODE WOULD BE:   &gt;&gt;&gt;
                * &lt;&lt;&lt;  LDA SW.MIXSET                &gt;&gt;&gt;
                * &lt;&lt;&lt;  JMP $FB33                    &gt;&gt;&gt;
                *--------------------------------
                *      "STORE" STATEMENT
                *--------------------------------
F39F- 20 D9 F7  <b><a name="STORE" id="STORE">STORE</a></b>  JSR <a href="#GETARYPT">GETARYPT</a> GET ADDRESS OF ARRAY TO BE SAVED
F3A2- A0 03            LDY #3       FORWARD OFFSET - 1 IS SIZE OF
F3A4- B1 9B            LDA (LOWTR),Y     THIS ARRAY
F3A6- AA               TAX
F3A7- 88               DEY
F3A8- B1 9B            LDA (LOWTR),Y
F3AA- E9 01            SBC #1
F3AC- B0 01            BCS .1
F3AE- CA               DEX
F3AF- 85 50     .1     STA LINNUM
F3B1- 86 51            STX LINNUM+1
F3B3- 20 CD FE         JSR <a href="#MON.WRITE">MON.WRITE</a>
F3B6- 20 BC F7         JSR <a href="#TAPEPNT">TAPEPNT</a>
F3B9- 4C CD FE         JMP <a href="#MON.WRITE">MON.WRITE</a>
                *--------------------------------
                *      "RECALL" STATEMENT
                *--------------------------------
F3BC- 20 D9 F7  <b><a name="RECALL" id="RECALL">RECALL</a></b> JSR <a href="#GETARYPT">GETARYPT</a>   FIND ARRAY IN MEMORY
F3BF- 20 FD FE         JSR <a href="#MON.READ">MON.READ</a>      READ HEADER
F3C2- A0 02            LDY #2         MAKE SURE THE NEW DATA FITS
F3C4- B1 9B            LDA (LOWTR),Y
F3C6- C5 50            CMP LINNUM
F3C8- C8               INY
F3C9- B1 9B            LDA (LOWTR),Y
F3CB- E5 51            SBC LINNUM+1
F3CD- B0 03            BCS .1         IT FITS
F3CF- 4C 10 D4         JMP <a href="#MEMERR">MEMERR</a>     DOESN'T FIT
F3D2- 20 BC F7  .1     JSR <a href="#TAPEPNT">TAPEPNT</a>    READ THE DATA
F3D5- 4C FD FE         JMP <a href="#MON.READ">MON.READ</a>
                *--------------------------------
                *      "HGR" AND "HGR2" STATEMENTS
                *--------------------------------
F3D8- 2C 55 C0  <b><a name="HGR2" id="HGR2">HGR2</a></b>   BIT <a href="#SW.HISCR">SW.HISCR</a>      SELECT PAGE 2 ($4000-5FFF)
F3DB- 2C 52 C0         BIT <a href="#SW.MIXCLR">SW.MIXCLR</a>     DEFAULT TO FULL SCREEN
F3DE- A9 40            LDA /$4000        SET STARTING PAGE FOR HIRES
F3E0- D0 08            BNE <a href="#SETHPG">SETHPG</a>        ...ALWAYS
F3E2- A9 20     <b><a name="HGR" id="HGR">HGR</a></b>    LDA /$2000        SET STARTING PAGE FOR HIRES
F3E4- 2C 54 C0         BIT <a href="#SW.LOWSCR">SW.LOWSCR</a>     SELECT PAGE 1 ($2000-3FFF)
F3E7- 2C 53 C0         BIT <a href="#SW.MIXSET">SW.MIXSET</a>     DEFAULT TO MIXED SCREEN
F3EA- 85 E6     <b><a name="SETHPG" id="SETHPG">SETHPG</a></b> STA HGR.PAGE          BASE PAGE OF HIRES BUFFER
F3EC- AD 57 C0         LDA SW.HIRES      TURN ON HIRES
F3EF- AD 50 C0         LDA SW.TXTCLR     TURN ON GRAPHICS
                *--------------------------------
                *      CLEAR SCREEN
                *--------------------------------
F3F2- A9 00     <b><a name="HCLR" id="HCLR">HCLR</a></b>   LDA #0            SET FOR BLACK BACKGROUND
F3F4- 85 1C            STA HGR.BITS
                *--------------------------------
                *      FILL SCREEN WITH (HGR.BITS)
                *--------------------------------
F3F6- A5 E6     <b><a name="BKGND" id="BKGND">BKGND</a></b>  LDA HGR.PAGE     PUT BUFFER ADDRESS IN HGR.SHAPE
F3F8- 85 1B            STA HGR.SHAPE+1
F3FA- A0 00            LDY #0
F3FC- 84 1A            STY HGR.SHAPE
F3FE- A5 1C     .1     LDA HGR.BITS  COLOR BYTE
F400- 91 1A            STA (HGR.SHAPE),Y  CLEAR HIRES TO HGR.BITS
F402- 20 7E F4         JSR <a href="#COLOR.SHIFT">COLOR.SHIFT</a>   CORRECT FOR COLOR SHIFT
F405- C8               INY          (SLOWS CLEAR BY FACTOR OF 2)
F406- D0 F6            BNE .1
F408- E6 1B            INC HGR.SHAPE+1
F40A- A5 1B            LDA HGR.SHAPE+1
F40C- 29 1F            AND #$1F     DONE?  ($40 OR$60)
F40E- D0 EE            BNE .1       NO
F410- 60               RTS          YES, RETURN
                *--------------------------------
                *      SET THE HIRES CURSOR POSITION
                *
                *      (Y,X) = HORIZONTAL COORDINATE  (0-279)
                *      (A)   = VERTICAL COORDINATE    (0-191)
                *--------------------------------
F411- 85 E2     <b><a name="HPOSN" id="HPOSN">HPOSN</a></b>  STA HGR.Y       SAVE Y- AND X-POSITIONS
F413- 86 E0            STX HGR.X
F415- 84 E1            STY HGR.X+1
F417- 48               PHA          Y-POS ALSO ON STACK
F418- 29 C0            AND #$C0     CALCULATE BASE ADDRESS FOR Y-POS
F41A- 85 26            STA MON.GBASL     FOR Y=ABCDEFGH
F41C- 4A               LSR               GBASL=ABAB0000
F41D- 4A               LSR
F41E- 05 26            ORA MON.GBASL
F420- 85 26            STA MON.GBASL
F422- 68               PLA                (A)      (GBASH)   (GBASL)
F423- 85 27            STA MON.GBASH  ?-ABCDEFGH  ABCDEFGH  ABAB0000
F425- 0A               ASL            A-BCDEFGH0  ABCDEFGH  ABAB0000
F426- 0A               ASL            B-CDEFGH00  ABCDEFGH  ABAB0000
F427- 0A               ASL            C-DEFGH000  ABCDEFGH  ABAB0000
F428- 26 27            ROL MON.GBASH  A-DEFGH000  BCDEFGHC  ABAB0000
F42A- 0A               ASL            D-EFGH0000  BCDEFGHC  ABAB0000
F42B- 26 27            ROL MON.GBASH  B-EFGH0000  CDEFGHCD  ABAB0000
F42D- 0A               ASL            E-FGH00000  CDEFGHCD  ABAB0000
F42E- 66 26            ROR MON.GBASL  0-FGH00000  CDEFGHCD  EABAB000
F430- A5 27            LDA MON.GBASH  0-CDEFGHCD  CDEFGHCD  EABAB000
F432- 29 1F            AND #$1F       0-000FGHCD  CDEFGHCD  EABAB000
F434- 05 E6            ORA HGR.PAGE   0-PPPFGHCD  CDEFGHCD  EABAB000
F436- 85 27            STA MON.GBASH  0-PPPFGHCD  PPPFGHCD  EABAB000
F438- 8A               TXA          DIVIDE X-POS BY 7 FOR INDEX FROM BASE
F439- C0 00            CPY #0       IS X-POS &lt; 256?
F43B- F0 05            BEQ .2       YES
F43D- A0 23            LDY #35      NO: 256/7 = 36 REM 4
                *                   CARRY=1, SO ADC #4 IS TOO LARGE;
                *                   HOWEVER, ADC #4 CLEARS CARRY
                *                   WHICH MAKES SBC #7 ONLY -6
                *                   BALANCING IT OUT.
F43F- 69 04            ADC #4       FOLLOWING INY MAKES Y=36
F441- C8        .1     INY
F442- E9 07     .2     SBC #7
F444- B0 FB            BCS .1
F446- 84 E5            STY HGR.HORIZ     HORIZONTAL INDEX
F448- AA               TAX          USE REMAINDER-7 TO LOOK UP THE
F449- BD B9 F4         LDA MSKTBL-$100+7,X  BIT MASK
F44C- 85 30            STA MON.HMASK
F44E- 98               TYA          QUOTIENT GIVES BYTE INDEX
F44F- 4A               LSR          ODD OR EVEN COLUMN?
F450- A5 E4            LDA HGR.COLOR  IF ON ODD BYTE (CARRY SET)
F452- 85 1C            STA HGR.BITS  THEN ROTATE BITS
F454- B0 28            BCS <a href="#COLOR.SHIFT">COLOR.SHIFT</a>   ODD COLUMN
F456- 60               RTS          EVEN COLUMN
                *--------------------------------
                *      PLOT A DOT
                *
                *      (Y,X) = HORIZONTAL POSITION
                *      (A)   = VERTICAL POSITION
                *--------------------------------
F457- 20 11 F4  <b><a name="HPLOT0" id="HPLOT0">HPLOT0</a></b> JSR <a href="#HPOSN">HPOSN</a>
F45A- A5 1C            LDA HGR.BITS      CALCULATE BIT POSN IN GBAS,
F45C- 51 26            EOR (MON.GBASL),Y HGR.HORIZ, AND HMASK FROM
F45E- 25 30            AND MON.HMASK     Y-COOR IN A-REG,
F460- 51 26            EOR (MON.GBASL),Y X-COOR IN X,Y REGS.
F462- 91 26            STA (MON.GBASL),Y FOR ANY 1-BITS, SUBSTITUTE
F464- 60               RTS               CORRESPONDING BIT OF HGR.BITS
                *--------------------------------
                *      MOVE LEFT OR RIGHT ONE PIXEL
                *
                *      IF STATUS IS +, MOVE RIGHT; IF -, MOVE LEFT
                *      IF ALREADY AT LEFT OR RIGHT EDGE, WRAP AROUND
                *
                *      REMEMBER BITS IN HI-RES BYTE ARE BACKWARDS ORDER:
                *          BYTE N   BYTE N+1
                *        S7654321   SEDCBA98
                *--------------------------------
                <b><a name="MOVE.LEFT.OR.RIGHT" id="MOVE.LEFT.OR.RIGHT">MOVE.LEFT.OR.RIGHT</a></b>
F465- 10 23            BPL <a href="#MOVE.RIGHT">MOVE.RIGHT</a>  + MOVE RIGHT, - MOVE LEFT
F467- A5 30            LDA MON.HMASK     MOVE LEFT ONE PIXEL
F469- 4A               LSR          SHIFT MASK RIGHT, MOVES DOT LEFT
F46A- B0 05            BCS <a href="#LR.2">LR.2</a>     ...DOT MOVED TO NEXT BYTE
F46C- 49 C0            EOR #$C0     MOVE SIGN BIT BACK WHERE IT WAS
F46E- 85 30     <b><a name="LR.1" id="LR.1">LR.1</a></b>   STA MON.HMASK     NEW MASK VALUE
F470- 60               RTS
F471- 88        <b><a name="LR.2" id="LR.2">LR.2</a></b>   DEY          MOVED TO NEXT BYTE, SO DECR INDEX
F472- 10 02            BPL <a href="#LR.3">LR.3</a>     STILL NOT PAST EDGE
F474- A0 27            LDY #39      OFF LEFT EDGE, SO WRAP AROUND SCREEN
F476- A9 C0     <b><a name="LR.3" id="LR.3">LR.3</a></b>   LDA #$C0     NEW HMASK, RIGHTMOST BIT ON SCREEN
F478- 85 30     <b><a name="LR.4" id="LR.4">LR.4</a></b>   STA MON.HMASK     NEW MASK AND INDEX
F47A- 84 E5            STY HGR.HORIZ
F47C- A5 1C            LDA HGR.BITS       ALSO NEED TO ROTATE COLOR
                *--------------------------------
                <b><a name="COLOR.SHIFT" id="COLOR.SHIFT">COLOR.SHIFT</a></b>
F47E- 0A               ASL          ROTATE LOW-ORDER 7 BITS
F47F- C9 C0            CMP #$C0      OF HGR.BITS ONE BIT POSN.
F481- 10 06            BPL .1
F483- A5 1C            LDA HGR.BITS
F485- 49 7F            EOR #$7F
F487- 85 1C            STA HGR.BITS
F489- 60        .1     RTS
                *--------------------------------
                *      MOVE RIGHT ONE PIXEL
                *      IF ALREADY AT RIGHT EDGE, WRAP AROUND
                *--------------------------------
                <b><a name="MOVE.RIGHT" id="MOVE.RIGHT">MOVE.RIGHT</a></b>
F48A- A5 30            LDA MON.HMASK
F48C- 0A               ASL          SHIFTING BYTE LEFT MOVES PIXEL RIGHT
F48D- 49 80            EOR #$80
                *          ORIGINAL:  C0 A0 90 88 84 82 81
                *          SHIFTED:   80 40 20 10 08 02 01
                *          EOR #$80:  00 C0 A0 90 88 84 82
F48F- 30 DD            BMI <a href="#LR.1">LR.1</a>     FINISHED
F491- A9 81            LDA #$81     NEW MASK VALUE
F493- C8               INY          MOVE TO NEXT BYTE RIGHT
F494- C0 28            CPY #40      UNLESS THAT IS TOO FAR
F496- 90 E0            BCC <a href="#LR.4">LR.4</a>     NOT TOO FAR
F498- A0 00            LDY #0       TOO FAR, SO WRAP AROUND
F49A- B0 DC            BCS <a href="#LR.4">LR.4</a>     ...ALWAYS
                *--------------------------------
                *--------------------------------
                *      "XDRAW" ONE BIT
                *--------------------------------
F49C- 18        <b><a name="LRUDX1" id="LRUDX1">LRUDX1</a></b> CLC          C=0 MEANS NO 90 DEGREE ROTATION
F49D- A5 D1     <b><a name="LRUDX2" id="LRUDX2">LRUDX2</a></b> LDA HGR.DX+1      C=1 MEANS ROTATE 90 DEGREES
F49F- 29 04            AND #4       IF BIT2=0 THEN DON'T PLOT
F4A1- F0 25            BEQ <a href="#LRUD4">LRUD4</a>    YES, DO NOT PLOT
F4A3- A9 7F            LDA #$7F     NO, LOOK AT WHAT IS ALREADY THERE
F4A5- 25 30            AND MON.HMASK
F4A7- 31 26            AND (MON.GBASL),Y  SCREEN BIT = 1?
F4A9- D0 19            BNE <a href="#LRUD3">LRUD3</a>          YES, GO CLEAR IT
F4AB- E6 EA            INC HGR.COLLISIONS       NO, COUNT THE COLLISION
F4AD- A9 7F            LDA #$7F           AND TURN THE BIT ON
F4AF- 25 30            AND MON.HMASK
F4B1- 10 11            BPL <a href="#LRUD3">LRUD3</a>    ...ALWAYS
                *--------------------------------
                *      "DRAW" ONE BIT
                *--------------------------------
F4B3- 18        <b><a name="LRUD1" id="LRUD1">LRUD1</a></b>  CLC          C=0 MEANS NO 90 DEGREE ROTATION
F4B4- A5 D1     <b><a name="LRUD2" id="LRUD2">LRUD2</a></b>  LDA HGR.DX+1      C=1 MEANS ROTATE
F4B6- 29 04            AND #4       IF BIT2=0 THEN DO NOT PLOT
F4B8- F0 0E            BEQ <a href="#LRUD4">LRUD4</a>    DO NOT PLOT
F4BA- B1 26            LDA (MON.GBASL),Y
F4BC- 45 1C            EOR HGR.BITS      1'S WHERE ANY BITS NOT IN COLOR
F4BE- 25 30            AND MON.HMASK    LOOK AT JUST THIS BIT POSITION
F4C0- D0 02            BNE <a href="#LRUD3">LRUD3</a>        THE BIT WAS ZERO, SO PLOT IT
F4C2- E6 EA            INC HGR.COLLISIONS  BIT IS ALREADY 1; COUNT COLLSN
                *--------------------------------
                *      TOGGLE BIT ON SCREEN WITH (A)
                *--------------------------------
F4C4- 51 26     <b><a name="LRUD3" id="LRUD3">LRUD3</a></b>  EOR (MON.GBASL),Y
F4C6- 91 26            STA (MON.GBASL),Y
                *--------------------------------
                *      DETERMINE WHERE NEXT POINT WILL BE, AND MOVE THERE
                *      C=0 IF NO 90 DEGREE ROTATION
                *      C=1 ROTATES 90 DEGREES
                *--------------------------------
F4C8- A5 D1     <b><a name="LRUD4" id="LRUD4">LRUD4</a></b>  LDA HGR.DX+1      CALCULATE THE DIRECTION TO MOVE
F4CA- 65 D3            ADC HGR.QUADRANT
F4CC- 29 03            AND #3       WRAP AROUND THE CIRCLE
F4CD-           CON.03 .EQ *-1  (( A CONSTANT ))
                *
                *                   00 -- UP
                *                   01 -- DOWN
                *                   10 -- RIGHT
                *                   11 -- LEFT
                *
F4CE- C9 02            CMP #2       C=0 IF 0 OR 1, C=1 IF 2 OR 3
F4D0- 6A               ROR          PUT C INTO SIGN, ODD/EVEN INTO C
F4D1- B0 92            BCS <a href="#MOVE.LEFT.OR.RIGHT">MOVE.LEFT.OR.RIGHT</a>
                *--------------------------------
                <b><a name="MOVE.UP.OR.DOWN" id="MOVE.UP.OR.DOWN">MOVE.UP.OR.DOWN</a></b>
F4D3- 30 30            BMI <a href="#MOVE.DOWN">MOVE.DOWN</a>     SIGN FOR UP/DOWN SELECT.
                *--------------------------------
                *      MOVE UP ONE PIXEL
                *      IF ALREADY AT TOP, GO TO BOTTOM
                *
                *      REMEMBER:  Y-COORD   GBASH     GBASL
                *                ABCDEFGH  PPPFGHCD  EABAB000
                *--------------------------------
F4D5- 18               CLC          MOVE UP
F4D6- A5 27            LDA MON.GBASH    CALC. BASE ADDRESS OF PREV. LINE
F4D8- 2C B9 F5         BIT <a href="#CON.1C">CON.1C</a>       LOOK AT BITS 000FGH00 IN GBASH
F4DB- D0 22            BNE .5           SIMPLE, JUST FGH=FGH-1
                *                   GBASH=PPP000CD, GBASL=EABAB000
F4DD- 06 26            ASL MON.GBASL   WHAT IS "E"?
F4DF- B0 1A            BCS .3          E=1, THEN EFGH=EFGH-1
F4E1- 2C CD F4         BIT <a href="#CON.03">CON.03</a>   LOOK AT 000000CD IN GBASH
F4E4- F0 05            BEQ .1       Y-POS IS AB000000 FORM
F4E6- 69 1F            ADC #$1F     CD &lt;&gt; 0, SO CDEFGH=CDEFGH-1
F4E8- 38               SEC
F4E9- B0 12            BCS .4       ...ALWAYS
F4EB- 69 23     .1     ADC #$23     ENOUGH TO MAKE GBASH=PPP11111 LATER
F4ED- 48               PHA          SAVE FOR LATER
F4EE- A5 26            LDA MON.GBASL  GBASL IS NOW ABAB0000 (AB=00,01,10)
F4F0- 69 B0            ADC #$B0         0000+1011=1011 AND CARRY CLEAR
                *                    OR 0101+1011=0000 AND CARRY SET
                *                    OR 1010+1011=0101 AND CARRY SET
F4F2- B0 02            BCS .2       NO WRAP-AROUND NEEDED
F4F4- 69 F0            ADC #$F0     CHANGE 1011 TO 1010 (WRAP-AROUND)
F4F6- 85 26     .2     STA MON.GBASL   FORM IS NOW STILL ABAB0000
F4F8- 68               PLA          PARTIALLY MODIFIED GBASH
F4F9- B0 02            BCS .4       ...ALWAYS
F4FB- 69 1F     .3     ADC #$1F
F4FD- 66 26     .4     ROR MON.GBASL    SHIFT IN E, TO GET EABAB000 FORM
F4FF- 69 FC     .5     ADC #$FC     FINISH GBASH MODS
F501- 85 27     <b><a name="UD.1" id="UD.1">UD.1</a></b>   STA MON.GBASH
F503- 60               RTS
                *--------------------------------
F504- 18               CLC          &lt;&lt;&lt;NEVER USED&gt;&gt;&gt;
                *--------------------------------
                *      MOVE DOWN ONE PIXEL
                *      IF ALREADY AT BOTTOM, GO TO TOP
                *
                *      REMEMBER:  Y-COORD   GBASH     GBASL
                *                ABCDEFGH  PPPFGHCD  EABAB000
                *--------------------------------
                <b><a name="MOVE.DOWN" id="MOVE.DOWN">MOVE.DOWN</a></b>
F505- A5 27            LDA MON.GBASH     TRY IT FIRST, BY FGH=FGH+1
F507- 69 04            ADC #4            GBASH = PPPFGHCD
F508-           CON.04 .EQ *-1   (( CONSTANT ))
F509- 2C B9 F5         BIT <a href="#CON.1C">CON.1C</a>        IS FGH FIELD NOW ZERO?
F50C- D0 F3            BNE <a href="#UD.1">UD.1</a>          NO, SO WE ARE FINISHED
                *                        YES, RIPPLE THE CARRY AS HIGH
                *                        AS NECESSARY
F50E- 06 26            ASL MON.GBASL     LOOK AT "E" BIT
F510- 90 18            BCC .2            NOW ZERO; MAKE IT 1 AND LEAVE
F512- 69 E0            ADC #$E0     CARRY = 1, SO ADDS $E1
F514- 18               CLC          IS "CD" NOT ZERO?
F515- 2C 08 F5         BIT <a href="#CON.04">CON.04</a>   TESTS BIT 2 FOR CARRY OUT OF "CD"
F518- F0 12            BEQ .3       NO CARRY, FINISHED
                *                   INCREMENT "AB" THEN
                *                   0000 --&gt; 0101
                *                   0101 --&gt; 1010
                *                   1010 --&gt; WRAP AROUND TO LINE 0
F51A- A5 26            LDA MON.GBASL     0000  0101  1010
F51C- 69 50            ADC #$50          0101  1010  1111
F51E- 49 F0            EOR #$F0          1010  0101  0000
F520- F0 02            BEQ .1
F522- 49 F0            EOR #$F0          0101  1010
F524- 85 26     .1     STA MON.GBASL     NEW ABAB0000
F526- A5 E6            LDA HGR.PAGE     WRAP AROUND TO LINE ZERO OF GROUP
F528- 90 02            BCC .3            ...ALWAYS
F52A- 69 E0     .2     ADC #$E0
F52C- 66 26     .3     ROR MON.GBASL
F52E- 90 D1            BCC <a href="#UD.1">UD.1</a>     ...ALWAYS
                *--------------------------------
                *      HLINRL IS NEVER CALLED BY APPLESOFT
                *
                *      ENTER WITH:  (A,X) = DX FROM CURRENT POINT
                *                   (Y)   = DY FROM CURRENT POINT
                *--------------------------------
F530- 48        <b><a name="HLINRL" id="HLINRL">HLINRL</a></b> PHA          SAVE (A)
F531- A9 00            LDA #0       CLEAR CURRENT POINT SO HGLIN WILL
F533- 85 E0            STA HGR.X      ACT RELATIVELY
F535- 85 E1            STA HGR.X+1
F537- 85 E2            STA HGR.Y
F539- 68               PLA          RESTORE (A)
                *--------------------------------
                *      DRAW LINE FROM LAST PLOTTED POINT TO (A,X),(Y)
                *
                *      ENTER WITH:  (A,X) = X OF TARGET POINT
                *                   (Y)   = Y OF TARGET POINT
                *--------------------------------
F53A- 48        <b><a name="HGLIN" id="HGLIN">HGLIN</a></b>  PHA          COMPUTE DX = X- X0
F53B- 38               SEC
F53C- E5 E0            SBC HGR.X
F53E- 48               PHA
F53F- 8A               TXA
F540- E5 E1            SBC HGR.X+1
F542- 85 D3            STA HGR.QUADRANT SAVE DX SIGN (+ = RIGHT, - = LEFT)
F544- B0 0A            BCS .1       NOW FIND ABS (DX)
F546- 68               PLA          FORMS 2'S COMPLEMENT
F547- 49 FF            EOR #$FF
F549- 69 01            ADC #1
F54B- 48               PHA
F54C- A9 00            LDA #0
F54E- E5 D3            SBC HGR.QUADRANT
F550- 85 D1     .1     STA HGR.DX+1
F552- 85 D5            STA HGR.E+1       INIT HGR.E TO ABS(X-X0)
F554- 68               PLA
F555- 85 D0            STA HGR.DX
F557- 85 D4            STA HGR.E
F559- 68               PLA
F55A- 85 E0            STA HGR.X      TARGET X POINT
F55C- 86 E1            STX HGR.X+1
F55E- 98               TYA          TARGET Y POINT
F55F- 18               CLC          COMPUTE DY = Y-HGR.Y
F560- E5 E2            SBC HGR.Y       AND SAVE -ABS(Y-HGR.Y)-1 IN HGR.DY
F562- 90 04            BCC .2       (SO + MEANS UP, - MEANS DOWN)
F564- 49 FF            EOR #$FF     2'S COMPLEMENT OF DY
F566- 69 FE            ADC #$FE
F568- 85 D2     .2     STA HGR.DY
F56A- 84 E2            STY HGR.Y       TARGET Y POINT
F56C- 66 D3            ROR HGR.QUADRANT    SHIFT Y-DIRECTION INTO QUADRANT
F56E- 38               SEC          COUNT = DX -(-DY) = # OF DOTS NEEDED
F56F- E5 D0            SBC HGR.DX
F571- AA               TAX          COUNTL IS IN X-REG
F572- A9 FF            LDA #$FF
F574- E5 D1            SBC HGR.DX+1
F576- 85 1D            STA HGR.COUNT
F578- A4 E5            LDY HGR.HORIZ     HORIZONTAL INDEX
F57A- B0 05            BCS <a href="#MOVEX2">MOVEX2</a>   ...ALWAYS
                *--------------------------------
                *      MOVE LEFT OR RIGHT ONE PIXEL
                *      (A) BIT 6 HAS DIRECTION
                *--------------------------------
F57C- 0A        <b><a name="MOVEX" id="MOVEX">MOVEX</a></b>  ASL          PUT BIT 6 INTO SIGN POSITION
F57D- 20 65 F4         JSR <a href="#MOVE.LEFT.OR.RIGHT">MOVE.LEFT.OR.RIGHT</a>
F580- 38               SEC
                *--------------------------------
                *      DRAW LINE NOW
                *--------------------------------
F581- A5 D4     <b><a name="MOVEX2" id="MOVEX2">MOVEX2</a></b> LDA HGR.E       CARRY IS SET
F583- 65 D2            ADC HGR.DY       E = E-DELTY
F585- 85 D4            STA HGR.E       NOTE: DY IS (-DELTA Y)-1
F587- A5 D5            LDA HGR.E+1       CARRY CLR IF HGR.E GOES NEGATIVE
F589- E9 00            SBC #0
F58B- 85 D5     .1     STA HGR.E+1
F58D- B1 26            LDA (MON.GBASL),Y
F58F- 45 1C            EOR HGR.BITS  PLOT A DOT
F591- 25 30            AND MON.HMASK
F593- 51 26            EOR (MON.GBASL),Y
F595- 91 26            STA (MON.GBASL),Y
F597- E8               INX          FINISHED ALL THE DOTS?
F598- D0 04            BNE .2       NO
F59A- E6 1D            INC HGR.COUNT   TEST REST OF COUNT
F59C- F0 62            BEQ <a href="#RTS.22">RTS.22</a>   YES, FINISHED.
F59E- A5 D3     .2     LDA HGR.QUADRANT    TEST DIRECTION
F5A0- B0 DA            BCS <a href="#MOVEX">MOVEX</a>    NEXT MOVE IS IN THE X DIRECTION
F5A2- 20 D3 F4         JSR <a href="#MOVE.UP.OR.DOWN">MOVE.UP.OR.DOWN</a>    IF CLR, NEG, MOVE
F5A5- 18               CLC          E = E+DX
F5A6- A5 D4            LDA HGR.E
F5A8- 65 D0            ADC HGR.DX
F5AA- 85 D4            STA HGR.E
F5AC- A5 D5            LDA HGR.E+1
F5AE- 65 D1            ADC HGR.DX+1
F5B0- 50 D9            BVC .1       ...ALWAYS
                *--------------------------------
F5B2- 81 82 84
F5B5- 88 90 A0
F5B8- C0        <b><a name="MSKTBL" id="MSKTBL">MSKTBL</a></b> .HS 8182848890A0C0
                *--------------------------------
F5B9- 1C        <b><a name="CON.1C" id="CON.1C">CON.1C</a></b> .HS 1C       MASK FOR "FGH" BITS
                *--------------------------------
           1010 *--------------------------------
                *      TABLE OF COS(90*X/16 DEGREES)*$100 - 1
                *      WITH ONE BYTE PRECISION, X=0 TO 16:
                *--------------------------------
                <b><a name="COSINE.TABLE" id="COSINE.TABLE">COSINE.TABLE</a></b>
F5BA- FF FE FA
F5BD- F4 EC E1
F5C0- D4 C5            .HS FFFEFAF4ECE1D4C5
F5C2- B4 A1 8D
F5C5- 78 61 49
F5C8- 31 18            .HS B4A18D7861493118
F5CA- FF               .HS FF
                *--------------------------------
                *    HFIND -- CALCULATES CURRENT POSITION OF HI-RES CURSOR
                *      (NOT CALLED BY ANY APPLESOFT ROUTINE)
                *
                *      CALCULATE Y-COORD FROM GBASL,H
                *            AND X-COORD FROM HORIZ AND HMASK
                *--------------------------------
F5CB- A5 26     <b><a name="HFIND" id="HFIND">HFIND</a></b>  LDA MON.GBASL     GBASL = EABAB000
F5CD- 0A               ASL               E INTO CARRY
F5CE- A5 27            LDA MON.GBASH     GBASH = PPPFGHCD
F5D0- 29 03            AND #3            000000CD
F5D2- 2A               ROL               00000CDE
F5D3- 05 26            ORA MON.GBASL     EABABCDE
F5D5- 0A               ASL               ABABCDE0
F5D6- 0A               ASL               BABCDE00
F5D7- 0A               ASL               ABCDE000
F5D8- 85 E2            STA HGR.Y         ALL BUT FGH
F5DA- A5 27            LDA MON.GBASH     PPPFGHCD
F5DC- 4A               LSR               0PPPFGHC
F5DD- 4A               LSR               00PPPFGH
F5DE- 29 07            AND #7            00000FGH
F5E0- 05 E2            ORA HGR.Y         ABCDEFGH
F5E2- 85 E2            STA HGR.Y    THAT TAKES CARE OF Y-COORDINATE!
F5E4- A5 E5            LDA HGR.HORIZ     X = 7*HORIZ + BIT POS. IN HMASK
F5E6- 0A               ASL               MULTIPLY BY 7
F5E7- 65 E5            ADC HGR.HORIZ     3* SO FAR
F5E9- 0A               ASL               6*
F5EA- AA               TAX               SINCE 7* MIGHT NOT FIT IN 1 BYTE,
                *                        WAIT TILL LATER FOR LAST ADD
F5EB- CA               DEX
F5EC- A5 30            LDA MON.HMASK     NOW FIND BIT POSITION IN HMASK
F5EE- 29 7F            AND #$7F          ONLY LOOK AT LOW SEVEN
F5F0- E8        .1     INX               COUNT A SHIFT
F5F1- 4A               LSR
F5F2- D0 FC            BNE .1            STILL IN THERE
F5F4- 85 E1            STA HGR.X+1       ZERO TO HI-BYTE
F5F6- 8A               TXA               6*HORIZ+LOG2(HMASK)
F5F7- 18               CLC               ADD HORIZ ONE MORE TIME
F5F8- 65 E5            ADC HGR.HORIZ     7*HORIZ+LOG2(HMASK)
F5FA- 90 02            BCC .2            UPPER BYTE = 0
F5FC- E6 E1            INC HGR.X+1       UPPER BYTE = 1
F5FE- 85 E0     .2     STA HGR.X         STORE LOWER BYTE
F600- 60        <b><a name="RTS.22" id="RTS.22">RTS.22</a></b> RTS
                *--------------------------------
                *      DRAW A SHAPE
                *
                *      (Y,X) = SHAPE STARTING ADDRESS
                *      (A)   = ROTATION (0-3F)
                *--------------------------------
                *      APPLESOFT DOES NOT CALL DRAW0
                *--------------------------------
F601- 86 1A     <b><a name="DRAW0" id="DRAW0">DRAW0</a></b>  STX HGR.SHAPE   SAVE SHAPE ADDRESS
F603- 84 1B            STY HGR.SHAPE+1
                *--------------------------------
                *      APPLESOFT ENTERS HERE
                *--------------------------------
F605- AA        <b><a name="DRAW1" id="DRAW1">DRAW1</a></b>  TAX          SAVE ROTATION (0-$3F)
F606- 4A               LSR          DIVIDE ROTATION BY 16 TO GET
F607- 4A               LSR          QUADRANT (0=UP, 1=RT, 2=DWN, 3=LFT)
F608- 4A               LSR
F609- 4A               LSR
F60A- 85 D3            STA HGR.QUADRANT
F60C- 8A               TXA          USE LOW 4 BITS OF ROTATION TO INDEX
F60D- 29 0F            AND #$0F     THE TRIG TABLE
F60F- AA               TAX
F610- BC BA F5         LDY COSINE.TABLE,X  SAVE COSINE IN HGR.DX
F613- 84 D0            STY HGR.DX
F615- 49 0F            EOR #$F             AND SINE IN DY
F617- AA               TAX
F618- BC BB F5         LDY COSINE.TABLE+1,X
F61B- C8               INY
F61C- 84 D2            STY HGR.DY
F61E- A4 E5            LDY HGR.HORIZ   INDEX FROM GBASL,H TO BYTE WE'RE IN
F620- A2 00            LDX #0
F622- 86 EA            STX HGR.COLLISIONS      CLEAR COLLISION COUNTER
F624- A1 1A            LDA (HGR.SHAPE,X)    GET FIRST BYTE OF SHAPE DEFN
F626- 85 D1     .1     STA HGR.DX+1      KEEP SHAPE BYTE IN HGR.DX+1
F628- A2 80            LDX #$80     INITIAL VALUES FOR FRACTIONAL VECTORS
F62A- 86 D4            STX HGR.E       .5 IN COSINE COMPONENT
F62C- 86 D5            STX HGR.E+1       .5 IN SINE COMPONENT
F62E- A6 E7            LDX HGR.SCALE   SCALE FACTOR
F630- A5 D4     .2     LDA HGR.E       ADD COSINE VALUE TO X-VALUE
F632- 38               SEC          IF &gt;= 1, THEN DRAW
F633- 65 D0            ADC HGR.DX
F635- 85 D4            STA HGR.E       ONLY SAVE FRACTIONAL PART
F637- 90 04            BCC .3       NO INTEGRAL PART
F639- 20 B3 F4         JSR <a href="#LRUD1">LRUD1</a>    TIME TO PLOT COSINE COMPONENT
F63C- 18               CLC
F63D- A5 D5     .3     LDA HGR.E+1       ADD SINE VALUE TO Y-VALUE
F63F- 65 D2            ADC HGR.DY       IF &gt;= 1, THEN DRAW
F641- 85 D5            STA HGR.E+1       ONLY SAVE FRACTIONAL PART
F643- 90 03            BCC .4       NO INTEGRAL PART
F645- 20 B4 F4         JSR <a href="#LRUD2">LRUD2</a>    TIME TO PLOT SINE COMPONENT
F648- CA        .4     DEX          LOOP ON SCALE FACTOR.
F649- D0 E5            BNE .2       STILL ON SAME SHAPE ITEM
F64B- A5 D1            LDA HGR.DX+1      GET NEXT SHAPE ITEM
F64D- 4A               LSR          NEXT 3 BIT VECTOR
F64E- 4A               LSR
F64F- 4A               LSR
F650- D0 D4            BNE .1       MORE IN THIS SHAPE BYTE
F652- E6 1A            INC HGR.SHAPE   GO TO NEXT SHAPE BYTE
F654- D0 02            BNE .5
F656- E6 1B            INC HGR.SHAPE+1
F658- A1 1A     .5     LDA (HGR.SHAPE,X)  NEXT BYTE OF SHAPE DEFINITION
F65A- D0 CA            BNE .1          PROCESS IF NOT ZERO
F65C- 60               RTS             FINISHED
                *--------------------------------
                *      XDRAW A SHAPE (SAME AS DRAW, EXCEPT TOGGLES SCREEN)
                *
                *      (Y,X) = SHAPE STARTING ADDRESS
                *      (A)   = ROTATION (0-3F)
                *--------------------------------
                *      APPLESOFT DOES NOT CALL XDRAW0
                *--------------------------------
F65D- 86 1A     <b><a name="XDRAW0" id="XDRAW0">XDRAW0</a></b> STX HGR.SHAPE   SAVE SHAPE ADDRESS
F65F- 84 1B            STY HGR.SHAPE+1
                *--------------------------------
                *      APPLESOFT ENTERS HERE
                *--------------------------------
F661- AA        <b><a name="XDRAW1" id="XDRAW1">XDRAW1</a></b> TAX          SAVE ROTATION (0-$3F)
F662- 4A               LSR          DIVIDE ROTATION BY 16 TO GET
F663- 4A               LSR          QUADRANT (0=UP, 1=RT, 2=DWN, 3=LFT)
F664- 4A               LSR
F665- 4A               LSR
F666- 85 D3            STA HGR.QUADRANT
F668- 8A               TXA          USE LOW 4 BITS OF ROTATION TO INDEX
F669- 29 0F            AND #$0F     THE TRIG TABLE
F66B- AA               TAX
F66C- BC BA F5         LDY COSINE.TABLE,X  SAVE COSINE IN HGR.DX
F66F- 84 D0            STY HGR.DX
F671- 49 0F            EOR #$F             AND SINE IN DY
F673- AA               TAX
F674- BC BB F5         LDY COSINE.TABLE+1,X
F677- C8               INY
F678- 84 D2            STY HGR.DY
F67A- A4 E5            LDY HGR.HORIZ   INDEX FROM GBASL,H TO BYTE WE'RE IN
F67C- A2 00            LDX #0
F67E- 86 EA            STX HGR.COLLISIONS      CLEAR COLLISION COUNTER
F680- A1 1A            LDA (HGR.SHAPE,X)    GET FIRST BYTE OF SHAPE DEFN
F682- 85 D1     .1     STA HGR.DX+1      KEEP SHAPE BYTE IN HGR.DX+1
F684- A2 80            LDX #$80     INITIAL VALUES FOR FRACTIONAL VECTORS
F686- 86 D4            STX HGR.E       .5 IN COSINE COMPONENT
F688- 86 D5            STX HGR.E+1       .5 IN SINE COMPONENT
F68A- A6 E7            LDX HGR.SCALE   SCALE FACTOR
F68C- A5 D4     .2     LDA HGR.E       ADD COSINE VALUE TO X-VALUE
F68E- 38               SEC          IF &gt;= 1, THEN DRAW
F68F- 65 D0            ADC HGR.DX
F691- 85 D4            STA HGR.E       ONLY SAVE FRACTIONAL PART
F693- 90 04            BCC .3       NO INTEGRAL PART
F695- 20 9C F4         JSR <a href="#LRUDX1">LRUDX1</a>   TIME TO PLOT COSINE COMPONENT
F698- 18               CLC
F699- A5 D5     .3     LDA HGR.E+1       ADD SINE VALUE TO Y-VALUE
F69B- 65 D2            ADC HGR.DY       IF &gt;= 1, THEN DRAW
F69D- 85 D5            STA HGR.E+1       ONLY SAVE FRACTIONAL PART
F69F- 90 03            BCC .4       NO INTEGRAL PART
F6A1- 20 9D F4         JSR <a href="#LRUDX2">LRUDX2</a>   TIME TO PLOT SINE COMPONENT
F6A4- CA        .4     DEX          LOOP ON SCALE FACTOR.
F6A5- D0 E5            BNE .2       STILL ON SAME SHAPE ITEM
F6A7- A5 D1            LDA HGR.DX+1      GET NEXT SHAPE ITEM
F6A9- 4A               LSR          NEXT 3 BIT VECTOR
F6AA- 4A               LSR
F6AB- 4A               LSR
F6AC- D0 D4            BNE .1       MORE IN THIS SHAPE BYTE
F6AE- E6 1A            INC HGR.SHAPE   GO TO NEXT SHAPE BYTE
F6B0- D0 02            BNE .5
F6B2- E6 1B            INC HGR.SHAPE+1
F6B4- A1 1A     .5     LDA (HGR.SHAPE,X)  NEXT BYTE OF SHAPE DEFINITION
F6B6- D0 CA            BNE .1          PROCESS IF NOT ZERO
F6B8- 60               RTS             FINISHED
                *--------------------------------
                *      GET HI-RES PLOTTING COORDINATES (0-279,0-191) FROM
                *      TXTPTR.  LEAVE REGISTERS SET UP FOR HPOSN:
                *          (Y,X)=X-COORD
                *          (A)  =Y-COORD
                *--------------------------------
F6B9- 20 67 DD  <b><a name="HFNS" id="HFNS">HFNS</a></b>   JSR <a href="#FRMNUM">FRMNUM</a>   EVALUATE EXPRESSION, MUST BE NUMERIC
F6BC- 20 52 E7         JSR <a href="#GETADR">GETADR</a>   CONVERT TO 2-BYTE INTEGER IN LINNUM
F6BF- A4 51            LDY LINNUM+1  GET HORIZ COOR IN X,Y
F6C1- A6 50            LDX LINNUM
F6C3- C0 01            CPY /280     MAKE SURE IT IS &lt; 280
F6C5- 90 06            BCC .1       IN RANGE
F6C7- D0 1D            BNE <a href="#GGERR">GGERR</a>
F6C9- E0 18            CPX #280
F6CB- B0 19            BCS <a href="#GGERR">GGERR</a>
F6CD- 8A        .1     TXA          SAVE HORIZ COOR ON STACK
F6CE- 48               PHA
F6CF- 98               TYA
F6D0- 48               PHA
F6D1- A9 2C            LDA #','     REQUIRE A COMMA
F6D3- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>
F6D6- 20 F8 E6         JSR <a href="#GETBYT">GETBYT</a>   EVAL EXP TO SINGLE BYTE IN X-REG
F6D9- E0 C0            CPX #192     CHECK FOR RANGE
F6DB- B0 09            BCS <a href="#GGERR">GGERR</a>    TOO BIG
F6DD- 86 9D            STX FAC      SAVE Y-COORD
F6DF- 68               PLA          RETRIEVE HORIZONTAL COORDINATE
F6E0- A8               TAY
F6E1- 68               PLA
F6E2- AA               TAX
F6E3- A5 9D            LDA FAC      AND VERTICAL COORDINATE
F6E5- 60               RTS
                *--------------------------------
F6E6- 4C 06 F2  <b><a name="GGERR" id="GGERR">GGERR</a></b>  JMP <a href="#GOERR">GOERR</a>    ILLEGAL QUANTITY ERROR
                *--------------------------------
                *      "HCOLOR=" STATEMENT
                *--------------------------------
F6E9- 20 F8 E6  <b><a name="HCOLOR" id="HCOLOR">HCOLOR</a></b> JSR <a href="#GETBYT">GETBYT</a>   EVAL EXP TO SINGLE BYTE IN X
F6EC- E0 08            CPX #8       VALUE MUST BE 0-7
F6EE- B0 F6            BCS <a href="#GGERR">GGERR</a>    TOO BIG
F6F0- BD F6 F6         LDA COLORTBL,X    GET COLOR PATTERN
F6F3- 85 E4            STA HGR.COLOR
F6F5- 60        <b><a name="RTS.23" id="RTS.23">RTS.23</a></b> RTS
                *--------------------------------
F6F6- 00 2A 55
F6F9- 7F 80 AA
F6FC- D5 FF     <b><a name="COLORTBL" id="COLORTBL">COLORTBL</a></b> .HS 002A557F80AAD5FF
                *--------------------------------
                *      "HPLOT" STATEMENT
                *
                *      HPLOT X,Y
                *      HPLOT TO X,Y
                *      HPLOT X1,Y1 TO X2,Y2
                *--------------------------------
F6FE- C9 C1     <b><a name="HPLOT" id="HPLOT">HPLOT</a></b>  CMP #TOKEN.TO     "PLOT TO" FORM?
F700- F0 0D            BEQ .2            YES, START FROM CURRENT LOCATION
F702- 20 B9 F6         JSR <a href="#HFNS">HFNS</a>          NO, GET STARTING POINT OF LINE
F705- 20 57 F4         JSR <a href="#HPLOT0">HPLOT0</a>   PLOT THE POINT, AND SET UP FOR
                *                   DRAWING A LINE FROM THAT POINT
F708- 20 B7 00  .1     JSR <a href="#CHRGOT">CHRGOT</a>   CHARACTER AT END OF EXPRESSION
F70B- C9 C1            CMP #TOKEN.TO     IS A LINE SPECIFIED?
F70D- D0 E6            BNE <a href="#RTS.23">RTS.23</a>        NO, EXIT
F70F- 20 C0 DE  .2     JSR <a href="#SYNCHR">SYNCHR</a>        YES. ADV. TXTPTR (WHY NOT CHRGET)
F712- 20 B9 F6         JSR <a href="#HFNS">HFNS</a>     GET COORDINATES OF LINE END
F715- 84 9D            STY DSCTMP   SET UP FOR LINE
F717- A8               TAY
F718- 8A               TXA
F719- A6 9D            LDX DSCTMP
F71B- 20 3A F5         JSR <a href="#HGLIN">HGLIN</a>    PLOT LINE
F71E- 4C 08 F7         JMP .1       LOOP TILL NO MORE "TO" PHRASES
                *--------------------------------
                *      "ROT=" STATEMENT
                *--------------------------------
F721- 20 F8 E6  <b><a name="ROT" id="ROT">ROT</a></b>    JSR <a href="#GETBYT">GETBYT</a>   EVAL EXP TO A BYTE IN X-REG
F724- 86 F9            STX HGR.ROTATION
F726- 60               RTS
                *--------------------------------
                *      "SCALE=" STATEMENT
                *--------------------------------
F727- 20 F8 E6  <b><a name="SCALE" id="SCALE">SCALE</a></b>  JSR <a href="#GETBYT">GETBYT</a>   EVAL EXP TO A BYTE IN X-REG
F72A- 86 E7            STX HGR.SCALE
F72C- 60               RTS
                *--------------------------------
                *      SET UP FOR DRAW AND XDRAW
                *--------------------------------
F72D- 20 F8 E6  <b><a name="DRWPNT" id="DRWPNT">DRWPNT</a></b> JSR <a href="#GETBYT">GETBYT</a>   GET SHAPE NUMBER IN X-REG
F730- A5 E8            LDA HGR.SHAPE.PNTR SEARCH FOR THAT SHAPE
F732- 85 1A            STA HGR.SHAPE   SET UP PNTR TO BEGINNING OF TABLE
F734- A5 E9            LDA HGR.SHAPE.PNTR+1
F736- 85 1B            STA HGR.SHAPE+1
F738- 8A               TXA
F739- A2 00            LDX #0
F73B- C1 1A            CMP (HGR.SHAPE,X)  COMPARE TO # OF SHAPES IN TABLE
F73D- F0 02            BEQ .1       LAST SHAPE IN TABLE
F73F- B0 A5            BCS <a href="#GGERR">GGERR</a>    SHAPE # TOO LARGE
F741- 0A        .1     ASL          DOUBLE SHAPE# TO MAKE AN INDEX
F742- 90 03            BCC .2          ADD 256 IF SHAPE # &gt; 127
F744- E6 1B            INC HGR.SHAPE+1
F746- 18               CLC
F747- A8        .2     TAY          USE INDEX TO LOOK UP OFFSET FOR SHAPE
F748- B1 1A            LDA (HGR.SHAPE),Y    IN OFFSET TABLE
F74A- 65 1A            ADC HGR.SHAPE
F74C- AA               TAX
F74D- C8               INY
F74E- B1 1A            LDA (HGR.SHAPE),Y
F750- 65 E9            ADC HGR.SHAPE.PNTR+1
F752- 85 1B            STA HGR.SHAPE+1   SAVE ADDRESS OF SHAPE
F754- 86 1A            STX HGR.SHAPE
F756- 20 B7 00         JSR <a href="#CHRGOT">CHRGOT</a>   IS THERE ANY "AT" PHRASE?
F759- C9 C5            CMP #TOKEN.AT
F75B- D0 09            BNE .3       NO, DRAW RIGHT WHERE WE ARE
F75D- 20 C0 DE         JSR <a href="#SYNCHR">SYNCHR</a>   SCAN OVER "AT"
F760- 20 B9 F6         JSR <a href="#HFNS">HFNS</a>     GET X- AND Y-COORDS TO START DRAWING AT
F763- 20 11 F4         JSR <a href="#HPOSN">HPOSN</a>    SET UP CURSOR THERE
F766- A5 F9     .3     LDA HGR.ROTATION     ROTATION VALUE
F768- 60               RTS
                *--------------------------------
                *      "DRAW" STATEMENT
                *--------------------------------
F769- 20 2D F7  <b><a name="DRAW" id="DRAW">DRAW</a></b>   JSR <a href="#DRWPNT">DRWPNT</a>
F76C- 4C 05 F6         JMP <a href="#DRAW1">DRAW1</a>
                *--------------------------------
                *      "XDRAW" STATEMENT
                *--------------------------------
F76F- 20 2D F7  <b><a name="XDRAW" id="XDRAW">XDRAW</a></b>  JSR <a href="#DRWPNT">DRWPNT</a>
F772- 4C 61 F6         JMP <a href="#XDRAW1">XDRAW1</a>
                *--------------------------------
                *      "SHLOAD" STATEMENT
                *
                *      READS A SHAPE TABLE FROM CASSETTE TAPE
                *      TO A POSITION JUST BELOW HIMEM.
                *      HIMEM IS THEN MOVED TO JUST BELOW THE TABLE
                *--------------------------------
F775- A9 00     <b><a name="SHLOAD" id="SHLOAD">SHLOAD</a></b> LDA /LINNUM  SET UP TO READ TWO BYTES
F777- 85 3D            STA MON.A1H  INTO LINNUM,LINNUM+1
F779- 85 3F            STA MON.A2H
F77B- A0 50            LDY #LINNUM
F77D- 84 3C            STY MON.A1L
F77F- C8               INY          LINNUM+1
F780- 84 3E            STY MON.A2L
F782- 20 FD FE         JSR <a href="#MON.READ">MON.READ</a> READ TAPE
F785- 18               CLC          SETUP TO READ (LINNUM) BYTES
F786- A5 73            LDA MEMSIZ   ENDING AT HIMEM-1
F788- AA               TAX
F789- CA               DEX          FORMING HIMEM-1
F78A- 86 3E            STX MON.A2L
F78C- E5 50            SBC LINNUM   FORMING HIMEM-(LINNUM)
F78E- 48               PHA
F78F- A5 74            LDA MEMSIZ+1
F791- A8               TAY
F792- E8               INX          SEE IF HIMEM LOW-BYTE WAS ZERO
F793- D0 01            BNE .1       NO
F795- 88               DEY          YES, HAVE TO DECREMENT HIGH BYTE
F796- 84 3F     .1     STY MON.A2H
F798- E5 51            SBC LINNUM+1
F79A- C5 6E            CMP STREND+1 RUNNING INTO VARIABLES?
F79C- 90 02            BCC .2       YES, OUT OF MEMORY
F79E- D0 03            BNE .3       NO, STILL ROOM
F7A0- 4C 10 D4  .2     JMP <a href="#MEMERR">MEMERR</a>   MEM FULL ERR
F7A3- 85 74     .3     STA MEMSIZ+1
F7A5- 85 70            STA FRETOP+1 CLEAR STRING SPACE
F7A7- 85 3D            STA MON.A1H  (BUT NAMES ARE STILL IN VARTBL!)
F7A9- 85 E9            STA HGR.SHAPE.PNTR+1
F7AB- 68               PLA
F7AC- 85 E8            STA HGR.SHAPE.PNTR
F7AE- 85 73            STA MEMSIZ
F7B0- 85 6F            STA FRETOP
F7B2- 85 3C            STA MON.A1L
F7B4- 20 FA FC         JSR <a href="#MON.RD2BIT">MON.RD2BIT</a>   READ TO TAPE TRANSITIONS
F7B7- A9 03            LDA #3       SHORT DELAY FOR INTERMEDIATE HEADER
F7B9- 4C 02 FF         JMP <a href="#MON.READ2">MON.READ2</a>    READ SHAPES
                *--------------------------------
                *      CALLED FROM STORE AND RECALL
                *--------------------------------
                <b><a name="TAPEPNT" id="TAPEPNT">TAPEPNT</a></b>
F7BC- 18               CLC
F7BD- A5 9B            LDA LOWTR
F7BF- 65 50            ADC LINNUM
F7C1- 85 3E            STA MON.A2L
F7C3- A5 9C            LDA LOWTR+1
F7C5- 65 51            ADC LINNUM+1
F7C7- 85 3F            STA MON.A2H
F7C9- A0 04            LDY #4
F7CB- B1 9B            LDA (LOWTR),Y
F7CD- 20 EF E0         JSR <a href="#GETARY2">GETARY2</a>
F7D0- A5 94            LDA HIGHDS
F7D2- 85 3C            STA MON.A1L
F7D4- A5 95            LDA HIGHDS+1
F7D6- 85 3D            STA MON.A1H
F7D8- 60               RTS
                *--------------------------------
                *      CALLED FROM STORE AND RECALL
                *--------------------------------
                <b><a name="GETARYPT" id="GETARYPT">GETARYPT</a></b>
F7D9- A9 40            LDA #$40
F7DB- 85 14            STA SUBFLG
F7DD- 20 E3 DF         JSR <a href="#PTRGET">PTRGET</a>
F7E0- A9 00            LDA #0
F7E2- 85 14            STA SUBFLG
F7E4- 4C F0 D8         JMP <a href="#VARTIO">VARTIO</a>
                *--------------------------------
                *      "HTAB" STATEMENT
                *
                *      NOTE THAT IF WNDLEFT IS NOT 0, HTAB CAN PRINT
                *      OUTSIDE THE SCREEN (EG., IN THE PROGRAM)
                *--------------------------------
F7E7- 20 F8 E6  <b><a name="HTAB" id="HTAB">HTAB</a></b>   JSR <a href="#GETBYT">GETBYT</a>
F7EA- CA               DEX
F7EB- 8A               TXA
F7EC- C9 28     .1     CMP #40
F7EE- 90 0A            BCC .2
F7F0- E9 28            SBC #40
F7F2- 48               PHA
F7F3- 20 FB DA         JSR <a href="#CRDO">CRDO</a>
F7F6- 68               PLA
F7F7- 4C EC F7         JMP .1
F7FA- 85 24     .2     STA MON.CH
F7FC- 60               RTS
                *--------------------------------
F7FD- CB D2 D7         .AS -/KRW/   SOMEONE'S INITIALS?
                                                                                                                                                                                     </pre>
</body>
</html>
